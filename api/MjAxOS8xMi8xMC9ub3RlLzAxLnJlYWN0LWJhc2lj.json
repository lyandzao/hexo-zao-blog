{"title":"01.react-basic","date":"2019-12-10T05:39:02.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"author":"zao","link":"2019/12/10/note/01.react-basic","tags":["react"],"categories":["note"],"updated":"2019-12-10T05:39:02.000Z","content":"<h2 id=\"react-基础\">react 基础<a href=\"#react-基础\" title=\"react 基础\"></a></h2><h3 id=\"jsx\">JSX<a href=\"#jsx\" title=\"JSX\"></a></h3><ul><li>JSX是一个 JavaScript 的语法扩展,可以很好地描述 UI 应该呈现出它应有交互的本质形式。</li>\n<li>React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。</li>\n<li>JSX 里的 class 变成了 className</li>\n</ul><h6 id=\"深入了解：\">深入了解：<a href=\"#深入了解：\" title=\"深入了解：\"></a></h6><p>JSX 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。</p>\n<p>如下JSX代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MyButton color&#x3D;&quot;blue&quot; shadowSize&#x3D;&#123;2&#125;&gt;</span><br><span class=\"line\">  Click Me</span><br><span class=\"line\">&lt;&#x2F;MyButton&gt;</span><br></pre></td></tr></table></figure>\n<p>会编译为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">React.createElement(</span><br><span class=\"line\">  MyButton,</span><br><span class=\"line\">  &#123;color: &#39;blue&#39;, shadowSize: 2&#125;,</span><br><span class=\"line\">  &#39;Click Me&#39;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"元素\">元素<a href=\"#元素\" title=\"元素\"></a></h3><ul><li>元素是构成 React 应用的最小砖块。</li>\n<li>React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。</li>\n<li>组件是由元素构成的。</li>\n<li><code>false</code>, <code>null</code>, <code>undefined</code>, <code>true</code> 是合法的子元素。但它们并不会被渲染。</li>\n</ul><p>以下的 JSX 表达式渲染结果相同：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;false&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;null&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;undefined&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;true&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件\">组件<a href=\"#组件\" title=\"组件\"></a></h3><p>组件名称必须以大写字母开头(React 会将以小写字母开头的组件视为原生 DOM 标签)</p>\n<ul><li><p>函数组件（以前称之为无状态组件，但<code>Hook</code>出来之后叫为函数组件）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Welcome(props) &#123;</span><br><span class=\"line\">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>class组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Welcome extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul><h3 id=\"props\">props<a href=\"#props\" title=\"props\"></a></h3><p>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 “props”。组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 这段代码会在页面上渲染 “Hello, Sara”</span><br><span class=\"line\">function Welcome(props) &#123;</span><br><span class=\"line\">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;;</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  element,</span><br><span class=\"line\">  document.getElementById(&#39;root&#39;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;上段代码渲染时发生了什么：</span><br><span class=\"line\">  1. 我们调用 ReactDOM.render() 函数，并传入 &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt; 作为参数。</span><br><span class=\"line\">  2. React 调用 Welcome 组件，并将 &#123;name: &#39;Sara&#39;&#125; 作为 props 传入。</span><br><span class=\"line\">  3. Welcome 组件将 &lt;h1&gt;Hello, Sara&lt;&#x2F;h1&gt; 元素作为返回值。</span><br><span class=\"line\">  4. React DOM 将 DOM 高效地更新为 &lt;h1&gt;Hello, Sara&lt;&#x2F;h1&gt;。</span><br></pre></td></tr></table></figure>\n<p>有多种方式可以在 JSX 中指定 props。</p>\n<ul><li>JavaScript 表达式作为 Props</li>\n<li>字符串字面量</li>\n<li>props 默认值为<code>true</code></li>\n</ul><h3 id=\"state\">State<a href=\"#state\" title=\"State\"></a></h3><ul><li>使用<code>this.setState()</code>设置state的值</li>\n<li><code>this.setState()</code>可能是异步的</li>\n<li>调用<code>this.setState()</code>的时候，React 会把你提供的对象合并到当前的 state。</li>\n</ul><h3 id=\"数据流\">数据流<a href=\"#数据流\" title=\"数据流\"></a></h3><p><code>react</code>是单向数据流，任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p>\n<h3 id=\"生命周期\">生命周期<a href=\"#生命周期\" title=\"生命周期\"></a></h3><p>在 V16 版本中引入了 Fiber 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 2 个 API 来解决问题。（Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 state，那么调用栈可能会很长，调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。Fiber 就是为了解决该问题而生。）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExampleComponent extends React.Component &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 用于初始化 state</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props)</span><br><span class=\"line\">    this.state &#x3D; &#123; hasError: false &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 用于替换 &#96;componentWillReceiveProps&#96; ，该函数会在初始化和 &#96;update&#96; 时被调用</span><br><span class=\"line\">  &#x2F;&#x2F; 因为该函数是静态函数，所以取不到 &#96;this&#96;, 如果需要对比 &#96;prevProps&#96; 需要单独在 &#96;state&#96; 中维护</span><br><span class=\"line\">  &#x2F;&#x2F; 它应返回一个对象来更新 state</span><br><span class=\"line\">  static getDerivedStateFromProps(nextProps, prevState) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 判断是否需要更新组件，多用于组件性能优化</span><br><span class=\"line\">  shouldComponentUpdate(nextProps, nextState) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 组件挂载后调用</span><br><span class=\"line\">  &#x2F;&#x2F; 可以在该函数中进行请求或者订阅</span><br><span class=\"line\">  componentDidMount() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 用于替换 componentWillUpdate ，该函数会在 update 后 DOM 更新前被调用</span><br><span class=\"line\">  &#x2F;&#x2F; 用于读取最新的 DOM 数据。</span><br><span class=\"line\">  getSnapshotBeforeUpdate() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 组件即将销毁</span><br><span class=\"line\">  &#x2F;&#x2F; 可以在此处移除订阅，定时器等等</span><br><span class=\"line\">  componentWillUnmount() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 组件销毁后调用</span><br><span class=\"line\">  componentDidUnMount() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 组件更新后调用</span><br><span class=\"line\">  componentDidUpdate() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 错误边界 - 渲染备用 UI</span><br><span class=\"line\">  &#x2F;&#x2F; 更新 state 使下一次渲染能够显示降级后的 UI</span><br><span class=\"line\">  &#x2F;&#x2F; 注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误</span><br><span class=\"line\">  static getDerivedStateFromError(error) &#123;</span><br><span class=\"line\">    return &#123; hasError: true &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 错误边界 - 打印错误信息</span><br><span class=\"line\">  &#x2F;&#x2F; 你同样可以将错误日志上报给服务器</span><br><span class=\"line\">  &#x2F;&#x2F; 注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误</span><br><span class=\"line\">  componentDidCatch(error, info) &#123;</span><br><span class=\"line\">    console.log(error, info);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 渲染组件函数</span><br><span class=\"line\">  render() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; 以下函数不建议使用</span><br><span class=\"line\">  UNSAFE_componentWillMount() &#123;&#125;</span><br><span class=\"line\">  UNSAFE_componentWillUpdate(nextProps, nextState) &#123;&#125;</span><br><span class=\"line\">  &#x2F;&#x2F; 接收到新的props时调用</span><br><span class=\"line\">  UNSAFE_componentWillReceiveProps(nextProps) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。</p>\n<ul><li>Reconciliation 阶段：<ul><li>componentWillMount</li>\n<li>componentWillReceiveProps</li>\n<li>shouldComponentUpdate</li>\n<li>componentWillUpdate</li>\n</ul></li>\n<li>Commit 阶段：<ul><li>componentDidMount</li>\n<li>componentDidUpdate</li>\n<li>componentWillUnmount</li>\n</ul></li>\n</ul><p>因为 reconciliation 阶段是可以被打断的，所以 reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。所以对于 reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用。</p>\n<h4 id=\"v164以后生命周期图解（不包含官方不建议使用的）\">V16.4以后生命周期图解（不包含官方不建议使用的）<a href=\"#v164以后生命周期图解（不包含官方不建议使用的）\" title=\"V16.4以后生命周期图解（不包含官方不建议使用的）\"></a></h4><p><img src=\"../assets/img/reactLifecycle.png\" class=\"φcy\" alt=\"生命周期\"></p>\n<h3 id=\"事件处理\">事件处理<a href=\"#事件处理\" title=\"事件处理\"></a></h3><ul><li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li>\n<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li>\n</ul><p>为JSX内时间绑定this的几种方式：</p>\n<ul><li>constructor内处理：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor() &#123;</span><br><span class=\"line\">  this.handleClick &#x3D; this.handleClick.bind(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>JSX内使用bind:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick&#x3D;&#123;this.handleClick.bind(this, id)&#125;&gt;Delete Row&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></li>\n<li>箭头函数：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.handleClick(id)&#125;&gt;Delete Row&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul><h3 id=\"key\">key<a href=\"#key\" title=\"key\"></a></h3><p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。<br>key 只是在兄弟节点之间必须唯一</p>\n<h3 id=\"受控组件\">受控组件<a href=\"#受控组件\" title=\"受控组件\"></a></h3><p>使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做<code>受控组件</code>。</p>\n<h3 id=\"非受控组件\">非受控组件<a href=\"#非受控组件\" title=\"非受控组件\"></a></h3><p>表单数据将交由 DOM 节点来处理。使用非受控组件时如果想赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 <code>defaultValue</code> 属性，而不是 value。</p>\n<p><code>&lt;input type=&quot;file&quot; /&gt;</code> 始终是一个非受控组件</p>\n<h3 id=\"进阶\">进阶<a href=\"#进阶\" title=\"进阶\"></a></h3><p><a href=\"https://github.com/TigerHee/shareJS/blob/master/react/02.react-advance.md\" target=\"_blank\">redux-adcanve</a></p>\n","prev":{"title":"webpack4","link":"2019/12/10/note/webpack4"},"next":{"title":"02.react-advance","link":"2019/12/10/note/02.react-advance"},"plink":"https://www.hansomezao.com/2019/12/10/note/01.react-basic/","toc":[{"id":"react-基础","title":"react 基础","index":"1","children":[{"id":"jsx","title":"JSX","index":"1.1"},{"id":"元素","title":"元素","index":"1.2"},{"id":"组件","title":"组件","index":"1.3"},{"id":"props","title":"props","index":"1.4"},{"id":"state","title":"State","index":"1.5"},{"id":"数据流","title":"数据流","index":"1.6"},{"id":"生命周期","title":"生命周期","index":"1.7"},{"id":"事件处理","title":"事件处理","index":"1.8"},{"id":"key","title":"key","index":"1.9"},{"id":"受控组件","title":"受控组件","index":"1.10"},{"id":"非受控组件","title":"非受控组件","index":"1.11"},{"id":"进阶","title":"进阶","index":"1.12"}]}]}