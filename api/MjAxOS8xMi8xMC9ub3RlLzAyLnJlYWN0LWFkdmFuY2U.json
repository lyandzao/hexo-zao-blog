{"title":"02.react-advance","date":"2019-12-10T05:39:02.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"author":"zao","link":"2019/12/10/note/02.react-advance","tags":["react"],"categories":["note"],"updated":"2019-12-10T05:39:02.000Z","content":"<h2 id=\"react-进阶\">react 进阶<a href=\"#react-进阶\" title=\"react 进阶\"></a></h2><h3 id=\"懒加载\">懒加载<a href=\"#懒加载\" title=\"懒加载\"></a></h3><p><code>React.lazy</code>函数能让你像渲染常规组件一样处理动态引入（的组件）。<br><code>Suspense</code>加载指示器为组件做优雅降级。<br><code>fallback</code>属性接受任何在组件加载过程中你想展示的 React 元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const OtherComponent &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;OtherComponent&#39;));</span><br><span class=\"line\"></span><br><span class=\"line\">function MyComponent() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;Suspense fallback&#x3D;&#123;&lt;div&gt;Loading...&lt;&#x2F;div&gt;&#125;&gt;</span><br><span class=\"line\">        &lt;OtherComponent &#x2F;&gt;</span><br><span class=\"line\">      &lt;&#x2F;Suspense&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"context\">Context<a href=\"#context\" title=\"Context\"></a></h3><p><code>Context</code>提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法，设计目的是为了共享那些对于一个组件树而言是“全局”的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span><br><span class=\"line\">&#x2F;&#x2F; 为当前的 theme 创建一个 context（“light”为默认值）。</span><br><span class=\"line\">const ThemeContext &#x3D; React.createContext(&#39;light&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span><br><span class=\"line\">    &#x2F;&#x2F; 无论多深，任何组件都能读取这个值。</span><br><span class=\"line\">    &#x2F;&#x2F; 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;ThemeContext.Provider value&#x3D;&quot;dark&quot;&gt;</span><br><span class=\"line\">        &lt;Toolbar &#x2F;&gt;</span><br><span class=\"line\">      &lt;&#x2F;ThemeContext.Provider&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 中间的组件再也不必指明往下传递 theme 了。</span><br><span class=\"line\">function Toolbar(props) &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;ThemedButton &#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ThemedButton extends React.Component &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 指定 contextType 读取当前的 theme context。</span><br><span class=\"line\">  &#x2F;&#x2F; React 会往上找到最近的 theme Provider，然后使用它的值。</span><br><span class=\"line\">  &#x2F;&#x2F; 在这个例子中，当前的 theme 值为 “dark”。</span><br><span class=\"line\">  static contextType &#x3D; ThemeContext;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;Button theme&#x3D;&#123;this.context&#125; &#x2F;&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请谨慎使用，因为这会使得组件的复用性变差。</p>\n<h6 id=\"api\">API:<a href=\"#api\" title=\"API:\"></a></h6><p><code>React.createContext</code>：<br>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。</p>\n<p><code>Context.Provider</code>：<br>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。</p>\n<p><code>Class.contextType</code>：<br>挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。</p>\n<p><code>Context.Consumer</code>：<br>这里，React 组件也可以订阅到 context 变更。这能让你在函数式组件中完成订阅 context。</p>\n<h3 id=\"refs\">Refs<a href=\"#refs\" title=\"Refs\"></a></h3><p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。不能在函数组件上使用 ref 属性，因为他们没有实例，可以在函数组件内部使用 ref 属性。</p>\n<p><em>适合使用 refs 的情况：</em></p>\n<ul><li>管理焦点，文本选择或媒体播放。</li>\n<li>触发强制动画。</li>\n<li>集成第三方 DOM 库。</li>\n</ul><p><em>使用方法：</em></p>\n<ol><li><p>创建 Refs</p>\n<ul><li>Refs 是使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyComponent extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.myRef &#x3D; React.createRef();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;div ref&#x3D;&#123;this.myRef&#125; &#x2F;&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul></li>\n<li><p>访问 Refs</p>\n<ul><li>在 ref 的 <code>current</code> 属性中被访问<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const node &#x3D; this.myRef.current;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul></li>\n</ol><h3 id=\"refs-转发\">Refs 转发<a href=\"#refs-转发\" title=\"Refs 转发\"></a></h3><p>Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。子组件使用<code>React.forwardRef</code>接收ref。可用于<code>Hoc</code>处理ref。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const FancyButton &#x3D; React.forwardRef((props, ref) &#x3D;&gt; (</span><br><span class=\"line\">  &lt;button ref&#x3D;&#123;ref&#125; className&#x3D;&quot;FancyButton&quot;&gt;</span><br><span class=\"line\">    &#123;props.children&#125;</span><br><span class=\"line\">  &lt;&#x2F;button&gt;</span><br><span class=\"line\">));</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 你可以直接获取 DOM button 的 ref：</span><br><span class=\"line\">const ref &#x3D; React.createRef();</span><br><span class=\"line\">&lt;FancyButton ref&#x3D;&#123;ref&#125;&gt;Click me!&lt;&#x2F;FancyButton&gt;;</span><br></pre></td></tr></table></figure>\n<p>上例中，<code>FancyButton</code> 使用 <code>React.forwardRef</code> 来获取传递给它的 <code>ref</code>，然后转发到它渲染的 DOM <code>button</code>。这样，使用 <code>FancyButton</code> 的组件可以获取底层 DOM 节点 <code>button</code> 的 <code>ref</code> ，并在必要时访问，就像其直接使用 DOM <code>button</code> 一样。</p>\n<h3 id=\"fragments\">Fragments<a href=\"#fragments\" title=\"Fragments\"></a></h3><p>Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。key 是唯一可以传递给 Fragment 的属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;React.Fragment&gt;</span><br><span class=\"line\">      &lt;ChildA &#x2F;&gt;</span><br><span class=\"line\">      &lt;ChildB &#x2F;&gt;</span><br><span class=\"line\">      &lt;ChildC &#x2F;&gt;</span><br><span class=\"line\">    &lt;&#x2F;React.Fragment&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code>可简写为<code>&lt;&gt;&lt;/&gt;</code></p>\n<h3 id=\"高阶组件（hoc）\">高阶组件（HOC）<a href=\"#高阶组件（hoc）\" title=\"高阶组件（HOC）\"></a></h3><p>HOC是参数为组件，返回值为新组件的函数。</p>\n<p>HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 此函数接收一个组件...</span><br><span class=\"line\">function withSubscription(WrappedComponent, selectData) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...并返回另一个组件...</span><br><span class=\"line\">  return class extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class=\"line\">      this.state &#x3D; &#123;</span><br><span class=\"line\">        data: selectData(DataSource, props)</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; ...负责订阅相关的操作...</span><br><span class=\"line\">      DataSource.addChangeListener(this.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      DataSource.removeChangeListener(this.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange() &#123;</span><br><span class=\"line\">      this.setState(&#123;</span><br><span class=\"line\">        data: selectData(DataSource, this.props)</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; ... 并使用新数据渲染被包装的组件!</span><br><span class=\"line\">      &#x2F;&#x2F; 请注意，我们可能还会传递其他属性</span><br><span class=\"line\">      return &lt;WrappedComponent data&#x3D;&#123;this.state.data&#125; &#123;...this.props&#125; &#x2F;&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上例中class组件为HOC的容器组件，容器组件担任分离将高层和低层关注的责任，由容器管理订阅和状态，并将 prop 传递给处理渲染 UI。HOC 使用容器作为其实现的一部分，你可以将 HOC 视为参数化容器组件。</p>\n<p><em>注意事项：</em></p>\n<ul><li><p>不要在 render 方法中使用 HOC。</p>\n<p>在render中使用会导致diff 算法在对比组件变化时每次检测都不一样，每次渲染都会进行卸载，和重新挂载的操作，这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。</p>\n</li>\n<li><p>务必复制静态方法到容器组件上。</p>\n<p>可以使用<code>hoist-non-react-statics</code>自动拷贝所有非 React 静态方法</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import hoistNonReactStatic from &#39;hoist-non-react-statics&#39;;</span><br><span class=\"line\">function enhance(WrappedComponent) &#123;</span><br><span class=\"line\">  class Enhance extends React.Component &#123;&#x2F;*...*&#x2F;&#125;</span><br><span class=\"line\">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class=\"line\">  return Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Refs 不会被传递。</p>\n<p>可用过Refs 转发解决</p>\n</li>\n</ul><h5 id=\"常见的hoc\">常见的HOC:<a href=\"#常见的hoc\" title=\"常见的HOC:\"></a></h5><p>redux的 <code>connect</code></p>\n<h3 id=\"reactpurecomponent\">React.PureComponent<a href=\"#reactpurecomponent\" title=\"React.PureComponent\"></a></h3><p>大部分情况下，你可以使用 React.PureComponent 来代替手写 shouldComponentUpdate。只有当检测数据是数组或对象时，由于浅拷贝的问题会导致比较出现偏差不能使用，此时使用深拷贝仍可继续使用。</p>\n<p>如以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CounterButton extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state &#x3D; &#123;count: 1&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    if (this.props.color !&#x3D;&#x3D; nextProps.color) &#123;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.state.count !&#x3D;&#x3D; nextState.count) &#123;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;button</span><br><span class=\"line\">        color&#x3D;&#123;this.props.color&#125;</span><br><span class=\"line\">        onClick&#x3D;&#123;() &#x3D;&gt; this.setState(state &#x3D;&gt; (&#123;count: state.count + 1&#125;))&#125;&gt;</span><br><span class=\"line\">        Count: &#123;this.state.count&#125;</span><br><span class=\"line\">      &lt;&#x2F;button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可替换为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CounterButton extends React.PureComponent &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state &#x3D; &#123;count: 1&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;button</span><br><span class=\"line\">        color&#x3D;&#123;this.props.color&#125;</span><br><span class=\"line\">        onClick&#x3D;&#123;() &#x3D;&gt; this.setState(state &#x3D;&gt; (&#123;count: state.count + 1&#125;))&#125;&gt;</span><br><span class=\"line\">        Count: &#123;this.state.count&#125;</span><br><span class=\"line\">      &lt;&#x2F;button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"portals\">Portals<a href=\"#portals\" title=\"Portals\"></a></h3><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p>\n<p>一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; React 并*没有*创建一个新的 div。它只是把子元素渲染到 &#96;domNode&#96; 中。</span><br><span class=\"line\">  &#x2F;&#x2F; &#96;domNode&#96; 是一个可以在任何位置的有效 DOM 节点。</span><br><span class=\"line\">  return ReactDOM.createPortal(</span><br><span class=\"line\">    this.props.children,</span><br><span class=\"line\">    domNode</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"reactstrictmode\">React.StrictMode<a href=\"#reactstrictmode\" title=\"React.StrictMode\"></a></h3><p>StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。严格模式检查仅在开发模式下运行；它们不会影响生产构建。</p>\n<h6 id=\"作用：\">作用：<a href=\"#作用：\" title=\"作用：\"></a></h6><ul><li>识别不安全的生命周期</li>\n<li>关于使用过时字符串 ref API 的警告</li>\n<li>关于使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>检测过时的 context API</li>\n</ul><h3 id=\"reactmemo\">React.memo<a href=\"#reactmemo\" title=\"React.memo\"></a></h3><p><code>React.memo</code> 为高阶组件。它与 React.PureComponent 非常相似，但它适用于函数组件，但不适用于 class 组件。</p>\n<p>如果你的函数组件在给定相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p>\n<p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const MyComponent &#x3D; React.memo(function MyComponent(props) &#123;</span><br><span class=\"line\">  &#x2F;* 使用 props 渲染 *&#x2F;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","prev":{"title":"webpack4","link":"2019/12/10/note/webpack4"},"next":{"title":"04.redux","link":"2019/12/10/note/04.redux"},"plink":"https://www.hansomezao.com/2019/12/10/note/02.react-advance/","toc":[{"id":"react-进阶","title":"react 进阶","index":"1","children":[{"id":"懒加载","title":"懒加载","index":"1.1"},{"id":"context","title":"Context","index":"1.2"},{"id":"refs","title":"Refs","index":"1.3"},{"id":"refs-转发","title":"Refs 转发","index":"1.4"},{"id":"fragments","title":"Fragments","index":"1.5"},{"id":"高阶组件（hoc）","title":"高阶组件（HOC）","index":"1.6"},{"id":"reactpurecomponent","title":"React.PureComponent","index":"1.7"},{"id":"portals","title":"Portals","index":"1.8"},{"id":"reactstrictmode","title":"React.StrictMode","index":"1.9"},{"id":"reactmemo","title":"React.memo","index":"1.10"}]}]}