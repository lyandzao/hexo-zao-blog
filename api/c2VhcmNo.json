[{"title":"docker gitlab jenkins搭建前端持续化部署环境","date":"2020-07-21T07:44:06.000Z","date_formatted":{"ll":"2020年7月21日","L":"2020/07/21","MM-DD":"07-21"},"author":"zao","updated":"2020-07-21T07:44:06.000Z","content":"gitlab安装1docker pull gitlab/gitlab-ce\n\n12345678910111213 docker run \\--detach \\ # 后台运行--publish 8443:443 \\ # 映射https端口--publish 80:80 \\ # 映射80端口--publish 8022:22 \\ # 映射ssh 22端口--name gitlab \\ --restart always \\--hostname 39.108.51.10 \\-v /home/gitlab/etc:/etc/gitlab \\ # 挂载gitlab的配置文件-v /home/gitlab/logs:/var/log/gitlab \\ # 挂载gitlab的日志文件-v /home/gitlab/data:/var/opt/gitlab \\ # 挂载gitlab的数据-v /etc/localtime:/etc/localtime:ro \\ # 保持宿主机和容器时间同步--privileged=true gitlab/gitlab-ce # 在容器内以root身份执行操作\n\njenkins安装和加速配置jenkins安装和启动1docker pull jenkins&#x2F;jenkins\n\n1docker run --name my-jenkins --user=root -p 8080:8080 -p 50000:50000 -v /home/myjenkins/jenkins_home:/var/jenkins_home -d jenkins/jenkins\n\n加速设置进入到Jenkins工作目录\n我这里是\n1cd /home/myjenkins/jenkins_home/updates\n\n配置清华镜像\n1sed -i 's/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g' default.json &amp;&amp; sed -i 's/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g' default.json\n\n重启jenkins容器\n","plink":"https://www.hansomezao.com/2020/07/21/articles/docker gitlab jenkins搭建前端持续化部署环境/"},{"title":"docker安装和使用","date":"2020-07-10T03:48:33.000Z","date_formatted":{"ll":"2020年7月10日","L":"2020/07/10","MM-DD":"07-10"},"author":"zao","updated":"2020-07-10T03:48:33.000Z","content":"\n以下操作仅在ubnutu18.04以及wsl2环境下运行过\n\ndocker相关安装以及镜像源设置docker安装脚本自动安装\n1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n\ndocker-compose安装1curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\n\n1sudo chmod +x /usr/local/bin/docker-compose\n\n添加docker镜像源1sudo vim /etc/docker/daemon.json\n\n1234// 这里改成你自己的加速地址就行了&#123;  \"registry-mirrors\": [\"https://klpsba92.mirror.aliyuncs.com\"]&#125;\n\n1sudo service docker restart\n\n常用命令镜像获取镜像\n123# 拉取镜像docker pull [image]:[version]docker pull nginx:alpine\n\n查看镜像信息\n12345678# 列出下载的镜像docker images# 使用tag可以为镜像添加tag，指向仍然是同一个镜像docker tag [image]:[version] [target tag]:[version]docker tag ubuntu:latest myubuntu:latest# 使用inspect查看镜像详细信息docker inspect [image]:[version]docker inspect nginx:alpine\n\n搜寻镜像\n1docker search [image]\n\n删除镜像\n123# 删除镜像docker rmi [options] [image]:[version]docker rmi [options] [image id]\n\n\n-f，-force：强制删除镜像，即使有容器依赖它；\n-no-prune：不要清理未带标签的父镜像\n\n\n清理镜像\n12# 清除系统遗留的一些临时镜像文件，以及一些没有被使用的镜像docker image [options] prune\n\n\n-a，-all：删除所有无用镜像，不光是临时镜像；\n-filter filter：只清理符合给定过滤器的镜像；\n-f，-force：强制删除镜像。\n\n\n创建镜像\n123456# 基于已有容器创建镜像docker commit [options] [container]docker commit -m \"init\" -a \"zao\" -p meeting-system# 基于Dockerfile创建docker build -t [image]:[version] .docker build -t ms:1 .\n\n\n-a，–author=“”：作者信息；\n-c，–change=[]：提交的时候执行Dockerfile指令，包括CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR；\n-m，–message=“”：提交信息；\n-p，–pause=true：提交时暂停容器运行\n\n\n上传镜像\n1docker push [image]:[version]\n\n\n容器列出容器\n1docker ps [options]\n\n\n-a :显示所有的容器，包括未运行的。\n-f :根据条件过滤显示的内容。\n–format :指定返回值的模板文件。\n-l :显示最近创建的容器。\n-n :列出最近创建的n个容器。\n–no-trunc :不截断输出。\n-q :静默模式，只显示容器编号。\n-s :显示总的文件大小。\n\n\n新建容器\n12# 新建容器，此时容器处于停止状态，可以通过start启动docker create [options] [image]:[version]\n\n\n与容器运行模式相关\n-a，–attach= [] 是否绑定到标准输人、输出和错误\n-d，–detach=true| false 是否在后台运行容器，默认为否\n–detach-keys=”” 从attach模式退出的快捷键\n–entrypoint=”” 镜像存在人口命令时，覆盖为新的命令\n– expose= [] 指定容器会暴露出来的端口或端口范围\n–group-add= [] 运行容器的用户组\n-i，– interactive=true| false 保持标准输人打开，默认为false\n–ipc=”” 容器IPC命名空间，可以为其他容器或主机\n– isolation= “default” 容器使用的隔离机制\n– log-driver= “json-file” 指定容器的日志驱动类型，可以为json-file、syslog、journald、gelf、fluentd、awslogs、splunk、etwlogs、gcplogs或none\n–log-opt=[] 传递给日志驱动的选项\n- -net= “bridge” 指定容器网络模式，包括bridge、none、 其他容器内网络、host 的网络或某个现有网络等\n–net-alias= [] 容器在网络中的别名\n-P，–publish-all=true | false 通过NAT机制将容器标记暴露的端口自动映射到本地主机的临时端口\n-p， –publish=[] 指定如何映射到本地主机端口，例如-p 11234-12234:1234-2234\n–pid=host 容器的PID命名空间\n–userns=”” 启用userns - remap时配置用户命名空间的模式\n–uts=host 容器的utS命名空间\n– restart= “no” 容器的重启策略，包括no、on- failure[:max-retry]、always、unless- stopped等\n– rm=true | false 容器退出后是否自动删除，不能跟-d同时使用\n-t，–tty=true | false 是否分配-一个伪终端，默认为false\n– tmpfs= [] 挂载临时文件系统到容器\n-v| –volume [= [ [HOST- DIR: ] CONTAINER -DIR [:OPTIONS]]] 挂载主机上的文件卷到容器内\n- -volume - driver=”” 挂载文件卷的驱动类型\n–volumes- from= [] 从其他容器挂载卷\n-W，–workdir= ”” 容器内的默认工作目录\n\n与容器环境和配置相关\n– add-host= [] 在容器内添加一个 主机名到IP地址的映射关 系(通过/etc/hosts 文件)\n– device= [] 映射物理机上的设备到容器内\n–dns - search= [] DNS搜索域\n–dns -opt= [] 自定义的DNS选项\n–dns= [] 自定义的DNS服务器\n-e，–env= [] 指定容器内环境变量\n–env-file= [] 从文件中读取环境变量到容器内\n-h，– hostname=” “ 指定容器内的主机名\n–name=” “ 指定容器的别名\n\n与容器资源限制和安全保护相关\n-U，–user=”” 指定在容器内执行命令的用户信息\n–userns=”” 指定用户命名空间\n–ulimit=[] 通过ulimit来限制最大文件数、最大进程数\n\n\n启动容器\n1docker start [container]\n\n启动并运行容器\n1docker run [options] [image]:[version]\n\n查看容器输出\n1docker logs [options] [container]\n\n\n-details：打印详细信息；\n-f，-follow：持续保持输出；\n-since string：输出从某个时间开始的日志；\n-tail string：输出最近的若干日志；\n-t，-timestamps：显示时间戳信息；\n-until string：输出某个时间之前的日志；\n\n\n暂停容器\n1docker pause [container]\n\n停止容器\n1docker stop [container]\n\n进入容器\n1# attach命令docker attach [options] [container]\n\n\n–detach-keys[=[]]：指定退出attach模式的快捷键序列，默认是CTRL-p CTRL-q；\n–no-stdin=true|false：是否关闭标准输入，默认是保持打开；\n–sig-proxy=true|false：是否代理收到的系统信号给应用进程，默认是true。\n\n123# exec命令docker exec [options] [container]docker exec -it 12kjhjasdasda /bin/bash\n\n\n-d，–detach：在容器中后台执行命令；\n–detach-keys=“”：指定将容器切回后台的按键；\n-e，–env=[]：指定环境变量列表；\n-i，–interactive=true|false：打开标准输入接受用户输入命令，默认值为false；\n–privileged=true|false：是否给执行命令以最高权限，默认值为false；\n-t，–tty=true|false：分配伪终端，默认值为false；\n-u，–user=“”：执行命令的用户名或ID。\n\n\n删除容器\n1docker rm [options] container\n\n\n-f，–force=false：是否强制终止并删除一个运行中的容器；\n-l，–link=false：删除容器的连接，但保留容器；\n-v，–volumes=false：删除容器挂载的数据卷。\n\n\n查看容器\n1234# 查看容器详情docker container inspect [container]# 查看容器内进程docker top [container]\n\n12# 查看统计信息docker stats [container]\n\n\n-a，-all：输出所有容器统计信息，默认仅在运行中；\n-format string：格式化输出信息；\n-no-stream：不持续输出，默认会自动更新持续实时结果；\n-no-trunc：不截断输出信息。\n\n\n复制文件\n1docker cp [path] [container]:[path]\n\n查看容器内文件系统的变更\n1docker container diff [container]\n\n查看端口映射\n1docker container port [container]\n\n更新配置\n1docker update [options] [container]\n\n\n","plink":"https://www.hansomezao.com/2020/07/10/articles/docker安装和使用/"},{"title":"liunx终端美化（ubuntu）","date":"2020-07-10T03:45:31.000Z","date_formatted":{"ll":"2020年7月10日","L":"2020/07/10","MM-DD":"07-10"},"author":"zao","updated":"2020-07-10T03:45:31.000Z","content":"安装zsh1sudo apt install zsh\n\n安装Oh-My-Zsh1sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"\n\n\n有可能出现443，被墙了，则进行下列操作\n在https://www.ipaddress.com/查询raw.githubusercontent.com的真实IP\n\n修改hosts文件\n1sudo vim &#x2F;etc&#x2F;hosts\n\n添加\n1199.232.68.133  raw.githubusercontent.com\n\n安装zsh插件1cd ~/.oh-my-zsh/plugins\n\nzsh-syntax-highlighting\n1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting\n\nzsh-autosuggestions\n1git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions\n\n\n1vim ~/.zshrc\n\n添加\n\n1source ~/.zshrc","plink":"https://www.hansomezao.com/2020/07/10/articles/liunx终端美化（ubuntu）/"},{"title":"windows terminal加powershell7美化命令行操作","date":"2020-05-28T03:36:53.000Z","date_formatted":{"ll":"2020年5月28日","L":"2020/05/28","MM-DD":"05-28"},"author":"zao","updated":"2020-05-28T03:36:53.000Z","content":"之前写过一篇文章vscode+wsl+windows terminal美化和搭建linux开发环境\n[博客链接](https://www.hansomezao.com/2020/05/28/articles/windows terminal加powershell7美化命令行操作)\nwsl挺好用的，不过比较麻烦，而且windows下的liunx子系统不完整，很多东西不能用，毕竟不是虚拟机。看到powershell7，心动了，本篇文章就如标题所言美化命令行操作。\n下载windows terminalMicrosoft Store就有下载\n下载并安装powershell7选个最新的就行，我下载的是7.1.0-preview3，powershell7下载\n下载scoop或者 chocolatey (windows包管理工具)也可以用powershell的Install-Module，不过还是推荐使用scoop或者chocolatey\n以scoop为例:\n安装scoop\n1234Invoke-Expression (New-Objec System.Net.WebClient).DownloadString('https://get.scoop.sh')# oriwr -useb get.scoop.sh | iex复制代码\n\n美化powershell这里主要用到两个包，PSReadLine命令行提示记录，starship美化显示样式，colortool颜色配置\n安装\n123Install-Module -Name PSReadLine -AllowPrerelease -Force # PSReadLinescoop install colortoolscoop install starship\n\n写powershell的配置文件\n打开配置文件\n123notepad.exe $Profile# or 用vscodecode $Profile\n\n写入\n123456789101112131415161718192021222324252627282930313233#-----------------------------------------------------PSReadline# 设置 Tab 键补全Set-PSReadlineKeyHandler -Key Tab -Function Complete# 设置 Ctrl+d 为菜单补全和 Intellisense# Set-PSReadLineKeyHandler -Key \"Tab\" -Function MenuComplete# 设置 Ctrl+d 为退出 PowerShellSet-PSReadlineKeyHandler -Key \"Ctrl+d\" -Function ViExit# 设置 Ctrl+z 为撤销Set-PSReadLineKeyHandler -Key \"Ctrl+z\" -Function Undo# 设置向上键为后向搜索历史记录Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward# 设置向下键为前向搜索历史纪录Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward# 一些PSReadline配置$PSReadLineOptions = @&#123;    EditMode = \"Emacs\"    HistoryNoDuplicates = $true    HistorySearchCursorMovesToEnd = $true    Colors = @&#123;        # 提示文字颜色，原来的颜色太浅了，我这里换了        Prediction = '#8F8B8B'    &#125;&#125;Set-PSReadLineOption @PSReadLineOptions#-----------------------------------------------------starshipInvoke-Expression (&amp;starship init powershell)\n\n配置starship\n创建这个文件夹并创建startship.toml\n1mkdir -p ~/.config &amp;&amp; touch ~/.config/starship.toml\n\n如果你创建失败，说明有这个.config这个文件夹，直接\n1touch ~/.config/starship.toml\n\n123notepad.exe ~/.config/starship.toml# orcode ~/.config/starship.toml\n\n具体配置看官网，这里出现的小方框或者乱码是字体缺失，我这里用的是FiraCode Nerd Font字体，这个后面再说\n大概像这个样子\n\n\n   1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465[character]      symbol &#x3D; &quot;➜&quot;    [aws]symbol &#x3D; &quot; &quot;[battery]full_symbol &#x3D; &quot;&quot;charging_symbol &#x3D; &quot;&quot;discharging_symbol &#x3D; &quot;&quot;[conda]symbol &#x3D; &quot; &quot;[docker]symbol &#x3D; &quot; &quot;[elixir]symbol &#x3D; &quot; &quot;[elm]symbol &#x3D; &quot; &quot;[git_branch]symbol &#x3D; &quot; &quot;[golang]symbol &#x3D; &quot; &quot;[haskell]symbol &#x3D; &quot; &quot;[hg_branch]symbol &#x3D; &quot; &quot;[java]symbol &#x3D; &quot; &quot;[julia]symbol &#x3D; &quot; &quot;[memory_usage]symbol &#x3D; &quot; &quot;[nix_shell]symbol &#x3D; &quot; &quot;[nodejs]# symbol &#x3D; &quot; &quot;symbol&#x3D;&quot; &quot;[package]symbol &#x3D; &quot; &quot;[php]symbol &#x3D; &quot; &quot;[python]symbol &#x3D; &quot; &quot;[ruby]symbol &#x3D; &quot; &quot;[rust]symbol &#x3D; &quot; &quot;\n\n配置colortool\n12colortool -s # 颜色表colortool  OneHalfDark.itermcolors # colortools后面跟主题名字就行\n\n\n\n\n\n下载并配置FiraCode Nerd Font字体下载FiraCode Nerd Font字体\n打开nerdfonts网站，滑到最下面找到FiraCode Nerd Font下载解压，全选&amp;右键安装\n\n\n在vscode中配置字体\n打开vscode配置文件，写入\n1\"editor.fontFamily\": \"FiraCode Nerd Font,Consolas, 'Courier New', monospace\"\n\n这时候你打开starship.toml就可以看到缺失的字体了\n\n在windows terminal中配置字体\n在后续windows terminal配置中见\n\n配置windows terminal1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&#123;    \"$schema\": \"https://aka.ms/terminal-profiles-schema\",    // \"defaultProfile\": \"&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;\",    \"defaultProfile\": \"&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;\",    \"copyOnSelect\": true,    \"profiles\": &#123;        \"defaults\": &#123;            \"startingDirectory\": \"./\",            \"useAcrylic\": true,            \"acrylicOpacity\": 0.8        &#125;,        \"list\": [&#123;                \"guid\": \"&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;\",                \"name\": \"Windows PowerShell\",                \"commandline\": \"powershell.exe\",                \"hidden\": false,                \"useAcrylic\": true            &#125;,            &#123;                \"guid\": \"&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;\",                \"name\": \"cmd\",                \"commandline\": \"cmd.exe\",                \"hidden\": false            &#125;,            &#123;                \"guid\": \"&#123;2c4de342-38b7-51cf-b940-2309a097f518&#125;\",                \"hidden\": false,                \"name\": \"Ubuntu\",                \"source\": \"Windows.Terminal.Wsl\"            &#125;,            &#123;                \"guid\": \"&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;\",                \"hidden\": false,                \"name\": \"Azure Cloud Shell\",                \"source\": \"Windows.Terminal.Azure\"            &#125;,            // powershell 7            &#123;                \"guid\": \"&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;\",                \"hidden\": false,                \"name\": \"PowerShell\",                \"commandline\": \"C:/Program Files/PowerShell/7-preview/pwsh.exe -nologo\",                \"fontSize\": 12,                // 字体配置                \"fontFace\": \"FiraCode Nerd Font\",                \"historySize\": 9001,                \"padding\": \"5, 5, 20, 25\",                \"snapOnInput\": true,                \"colorScheme\": \"Andromeda\",                \"source\": \"Windows.Terminal.PowershellCore\"            &#125;        ]    &#125;,    \"schemes\": [ &#123;        \"name\": \"Andromeda\",        \"black\": \"#000000\",        \"red\": \"#cd3131\",        \"green\": \"#05bc79\",        \"yellow\": \"#e5e512\",        \"blue\": \"#2472c8\",        \"purple\": \"#bc3fbc\",        \"cyan\": \"#0fa8cd\",        \"white\": \"#e5e5e5\",        \"brightBlack\": \"#666666\",        \"brightRed\": \"#cd3131\",        \"brightGreen\": \"#05bc79\",        \"brightYellow\": \"#e5e512\",        \"brightBlue\": \"#2472c8\",        \"brightPurple\": \"#bc3fbc\",        \"brightCyan\": \"#0fa8cd\",        \"brightWhite\": \"#e5e5e5\",        \"background\": \"#262a33\",        \"foreground\": \"#e5e5e5\"    &#125;],    \"keybindings\": []&#125;\n\n这个时候打开windows terminal\n\nwindows terminal 加入系统右键win+r输入regedit找到计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell 新建项Terminal(名字随便取)\n\n\n选中Terminal，(默认)为写入右键的文本\n\nIcon为右键图标，自己找一个ico\n\n右键Terminal新建项command，在默认下写入值C:\\Users\\niwen\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe\n这里的niwen是我电脑用户的名称，你们自己找到wt.exe然后把地址写上去就行\n\nok搞定现在试一下右键点击Terminal Here\n\n","plink":"https://www.hansomezao.com/2020/05/28/articles/windows-terminal加powershell7美化命令行操作/"},{"title":"前端下载后台返回的文件流","date":"2020-04-16T03:32:23.000Z","date_formatted":{"ll":"2020年4月16日","L":"2020/04/16","MM-DD":"04-16"},"author":"zao","updated":"2020-04-16T03:32:23.000Z","content":"问题后台返回\n12content-disposition: attachment;filename=245484+%282%29.jpgcontent-type: application/octet-stream\n\n打开response为乱码\n解决方法做响应拦截,判断当content-type为application/octet-stream,设置responseType为blob\n以umi-request为例\n1234567// 拦截响应request.interceptors.response.use(async (response: Response, options: RequestOptionsInit) =&gt; &#123;  if (response.headers.get('Content-Type') === 'application/octet-stream') &#123;    options.responseType='blob'  &#125;  return response&#125;)\n\n封装download函数\n1234567891011121314151617/*** 下载文件* @param content 文件流* @param fileName 文件名称*/ export const download = (content: any, fileName: string) =&gt; &#123;   const blob = new Blob([content], &#123;     type: 'application/octet-stream'   &#125;);   const a = document.createElement(\"a\");   const url = window.URL.createObjectURL(blob);   const filename = fileName;   a.href = url;   a.download = filename;   a.click();   window.URL.revokeObjectURL(url); &#125;\n\n请求，以umijs的useRequest为例\n12345678910const downloadFileR = useRequest((meetingId, fileName) =&gt; downloadFile(meetingId, fileName), &#123; manual: true, onSuccess: (result, params) =&gt; &#123;   if (result.code &lt; 0) &#123;     message.error(result.message)   &#125; else &#123;     download(result, params[1])   &#125; &#125;&#125;)\n\n其他的请求库和封装方式类似，不再举例\n\n","plink":"https://www.hansomezao.com/2020/04/16/articles/前端下载后台返回的文件流/"},{"title":"vscode+wsl+windows terminal美化和搭建linux开发环境","date":"2020-03-11T03:23:23.000Z","date_formatted":{"ll":"2020年3月11日","L":"2020/03/11","MM-DD":"03-11"},"author":"zao","updated":"2020-03-11T03:23:23.000Z","content":"链接➡\nvscode + wsl + windows terminal 美化和搭建linux开发环境\n没钱买mac,windwos下命令行挺难用的,之前一直用cmder还不错,但后期卡卡的,改用了windows terminal,真香啊,速度和外观都不错,刚好最近在学linux,一直用的阿里云做测试,想着统一一下包管理和命令行,发现了wsl这个东西,就打算改造一下windows,个人电脑系统为windwos 10 1909,详细操作如下:\n1. 开启wsl、安装linux被这个坑惨了,windows版本更新不上,一直勾选不了,后来下了补丁,打开windows功能一片空白,我服了,唉,最后只有重装系统了\n\n在windwos商店安装ubuntu或者其他liunx\n2. 配置ubuntu下载完ubuntu,会设置用户名和密码,输入密码时shell上并不可见,这里不用担心。\n替换下载源为阿里源12345678910111213sudo vim &#x2F;etc&#x2F;apt&#x2F;sources.listdeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversesudo apt-get updatesudo apt-get upgade\n\n安装zsh、oh-my-zsh来美化bash123sudo apt install zshsh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;\n\n下载node、n、git、yarn、nrm、yrm略\n配置windows terminal打开windows terminal设置设置defaultProfile即默认打开的terminal\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123;    \"$schema\": \"https://aka.ms/terminal-profiles-schema\",    // \"defaultProfile\": \"&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;\",    \"defaultProfile\": \"&#123;2c4de342-38b7-51cf-b940-2309a097f518&#125;\",    \"copyOnSelect\": true,    \"profiles\": &#123;        \"defaults\": &#123;            // Put settings here that you want to apply to all profiles            \"startingDirectory\": \"./\",            \"useAcrylic\": true,            \"acrylicOpacity\": 0.8        &#125;,        \"list\": [&#123;                // Make changes here to the powershell.exe profile                \"guid\": \"&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;\",                \"name\": \"Windows PowerShell\",                \"commandline\": \"powershell.exe\",                \"hidden\": false,                \"useAcrylic\": true            &#125;,            &#123;                // Make changes here to the cmd.exe profile                \"guid\": \"&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;\",                \"name\": \"cmd\",                \"commandline\": \"cmd.exe\",                \"hidden\": false            &#125;,            &#123;                \"guid\": \"&#123;2c4de342-38b7-51cf-b940-2309a097f518&#125;\",                \"hidden\": false,                \"name\": \"Ubuntu\",                \"source\": \"Windows.Terminal.Wsl\"            &#125;,            &#123;                \"guid\": \"&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;\",                \"hidden\": false,                \"name\": \"Azure Cloud Shell\",                \"source\": \"Windows.Terminal.Azure\"            &#125;        ]    &#125;,    // Add custom color schemes to this array    \"schemes\": [],    // Add any keybinding overrides to this array.    // To unbind a default keybinding, set the command to \"unbound\"    \"keybindings\": []&#125;\n\n系统级右键菜单,写入注册表win+r输入regedit找到计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell 新建项Terminal(名字随便取)\n\n默认为右键文本\n\nIcon为图标,值为图标地址,自己在官网找的ico\n新建项command,在默认下键入值C:\\Users\\niwen\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe 这里的niwen你要改为你自己电脑用户的名称\n将同样配置写在计算机\\HKEY_CLASSES_ROOT\\Directory\\shell下\n配置windows terminal的&quot;startingDirectory&quot;: &quot;./&quot;\n试一试右键点击Terminal here\n\n接入vscode下载插件Remote - WSL\n打开setting.json配置terminal打开方式 “terminal.integrated.shell.windows”: “C:\\WINDOWS\\System32\\wsl.exe” 现在试一试效果,舒服\n\n接入code runner现在你的所有包都放在wsl中,跑code runner是不行的,除非你自己又在windows上安装一遍\n只需要在setting.json中配置\n12\"code-runner.runInTerminal\": true,    \"code-runner.terminalRoot\": \"/mnt/\",\n\n就完事了\n\n终于结束了,我是这样配置的,如果有什么问题欢迎提出\n","plink":"https://www.hansomezao.com/2020/03/11/articles/vscode-wsl-windows-terminal美化和搭建linux开发环境/"},{"title":"hooks迁移-实现class中setState的效果","date":"2020-03-03T10:07:26.000Z","date_formatted":{"ll":"2020年3月3日","L":"2020/03/03","MM-DD":"03-03"},"author":"zao","updated":"2020-03-03T10:07:26.000Z","content":"hooks中实现class的setState的效果问题setState有回调函数，可以取得最新的state，而hooks的useState没有回调，不能立即取得最新值，这是由于useState的Capture value的特性造成的，网上解释挺多的，这里就不展开了。\n解决方式核心是通过ref来接收state，ref不受Capture value的影响且可以在作用域内访问\n源码取得最新值2019年了，整理了N个实用案例帮你快速迁移到React Hooks整挺好的，我只用ts重写一遍，后面继续用\nuseRefState.ts1234567891011121314151617181920212223242526272829303132333435363738394041import &#123;  useState,  useRef,  useCallback,  Dispatch,  SetStateAction,  MutableRefObject&#125; from 'react';const useRefState=&lt;T&gt;(  initialState: T | (() =&gt; T)): [T, Dispatch&lt;SetStateAction&lt;T&gt;&gt;, MutableRefObject&lt;T&gt;] &#123;  const ins = useRef&lt;any&gt;();  const [state, setState] = useState(() =&gt; &#123;    // 初始化    const value =      typeof initialState === 'function'        ? (initialState as () =&gt; T)()        : initialState;    ins.current = value;    return value;  &#125;);  const setValue = useCallback(value =&gt; &#123;    if (typeof value === 'function') &#123;      setState(prevState =&gt; &#123;        const finalValue = value(prevState);        ins.current = finalValue;        return finalValue;      &#125;);    &#125; else &#123;      ins.current = value;      setState(value);    &#125;  &#125;, []);  return [state, setValue, ins];&#125;export default useRefState;\n\n回调函数结合上面的hooks\nuseCBState.ts1234567891011121314151617181920212223242526272829import &#123; useEffect, useRef, MutableRefObject &#125; from 'react';import useRefState from './useRefState';const useCBState = &lt;T&gt;(  initState: T | (() =&gt; T)): [  T,  (state: T | ((prev: T) =&gt; T), cb: () =&gt; any) =&gt; void,  MutableRefObject&lt;T|undefined&gt;] =&gt; &#123;  const [state, setState, ins] = useRefState(initState);  let isUpdate = useRef&lt;any&gt;();  const setCBState = (state: T | ((prev: T) =&gt; T), cb: () =&gt; any) =&gt; &#123;    setState(prev =&gt; &#123;      isUpdate.current = cb;      return typeof state === 'function'        ? (state as (prev: T) =&gt; T)(prev)        : state;    &#125;);  &#125;;  useEffect(() =&gt; &#123;    if (isUpdate.current) &#123;      isUpdate.current();    &#125;  &#125;);  return [state, setCBState, ins];&#125;;export default useCBState;\n\n实际上，到这里差不多就完了，要完全实现setState的功能即在回调函数里取得最新值，也可以把最新值放到它的函数作用域内。\n","plink":"https://www.hansomezao.com/2020/03/03/articles/hooks迁移-实现class中setState的效果/"},{"title":"原md批量修改为hexo文章格式","date":"2020-03-02T09:12:33.000Z","date_formatted":{"ll":"2020年3月2日","L":"2020/03/02","MM-DD":"03-02"},"author":"zao","updated":"2020-03-02T09:12:33.000Z","content":"需求我想把以前收集的笔记和文章全部迁移到我的 hexo 博客下,一个个复制粘贴 front-matter 好麻烦哦,于是想到利用 node.js 批量生成\n核心步骤挺简单的,也没什么好说的\n读取源文件夹下的所有 md 文件\n循环遍历 md 文件执行读取文件信息\n生成摸板把信息嵌入进去\n读取源文件保存数据并在数据开头添加模板\n写入文件\n\n源代码mdToHexoPost.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657let fs = require('fs');let path = require('path');/** * 在md头部写入hexo文章信息 * @param &#123;string&#125; sourceRoot 目标文件的根路径 * @param &#123;string&#125; sourceFilePath 目标文件在根路径下的路径 * @param &#123;string&#125; tag 文章标签 */async function writeFileToLine(sourceRoot, targetRoot, sourceFilePath, tag) &#123;  try &#123;    let targetRootPath = path.join(targetRoot, `copy/$&#123;sourceFilePath&#125;`);    let filePath = path.join(sourceRoot, sourceFilePath);    let fileInfo = await fs.statSync(filePath);    let cTime = fileInfo.ctime      .toLocaleString()      .replace('T', ' ')      .slice(0, 19);    let title = sourceFilePath.slice(0, -3);    let template = `---title: $&#123;title&#125;date: $&#123;cTime&#125;tags: $&#123;tag&#125;category: noteauthor: zaotoc: truereward: falsecopyright: false---`;    let data = await fs.readFileSync(filePath, 'utf8').split(/\\r\\n|\\n|\\r/gm);    data.splice(-data.length, 0, template);    await fs.writeFileSync(targetRootPath, data.join('\\n'));  &#125; catch (error) &#123;    console.log('失败');    console.log(error);  &#125;&#125;/** * 循环生成post * @param &#123;string&#125; sourceRoot 源文件根路径 * @param &#123;string&#125; targetRoot 目标文件根路径 * @param &#123;string&#125; tag 文章tag */async function writeFileLoop(sourceRoot, targetRoot, tag) &#123;  // let root = __dirname;  let targetDir = path.join(targetRoot, 'copy');  if (!fs.readdirSync(targetRoot).includes('copy')) &#123;    await fs.mkdirSync(targetDir);  &#125;  let files = await fs.readdirSync(sourceRoot);  let mdList = files.filter(item =&gt; item.match(/(.*)\\.md/));  mdList.forEach(file =&gt; writeFileToLine(sourceRoot, targetRoot, file, tag));&#125;writeFileLoop('c:\\\\Users\\\\Administrator\\\\Desktop', __dirname, 'js');\n\nps核心思想挺简单的,具体情况还是要改哈代码,我只是根据我自己的情况这么写的,不过核心思想没变,😂\n","plink":"https://www.hansomezao.com/2020/03/02/articles/原md批量修改为hexo文章格式/"},{"title":"hexo","date":"2020-02-29T04:55:20.000Z","date_formatted":{"ll":"2020年2月29日","L":"2020/02/29","MM-DD":"02-29"},"author":"zao","updated":"2020-02-29T04:55:20.000Z","content":"一、文件目录结构12345678.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes\n\nscaffolds:\n模板文件夹，新建文章时，hexo会根据scaffold来建立文件\n\nsource\n资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\n\nthemes\n主体文件夹，hexo根据主题，核心是ejs，来生成静态页面\n\nsource资源文件夹asset资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。\n文章资源文件夹对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。\n1_config.ymlpost_asset_folder: true\n\n当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。\n相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。\n1&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;\n\n比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）\n正确的引用图片方式是使用下列的标签插件而不是 markdown ：\n1&#123;% asset_img example.jpg This is an example image %&#125;\n\n通过这种方式，图片将会同时出现在文章和主页以及归档页中。\n数据文件_data有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。\n举例来说，在 source/_data 文件夹中新建 menu.yml 文件：\n1Home: &#x2F;Gallery: &#x2F;gallery&#x2F;Archives: &#x2F;archives&#x2F;\n\n您就能在模板中使用这些资料：\n1&lt;% for (var link in site.data.menu) &#123; %&gt;  &lt;a href&#x3D;&quot;&lt;%&#x3D; site.data.menu[link] %&gt;&quot;&gt; &lt;%&#x3D; link %&gt; &lt;&#x2F;a&gt;&lt;% &#125; %&gt;\n\n渲染结果如下 :\n1&lt;a href&#x3D;&quot;&#x2F;&quot;&gt; Home &lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;&#x2F;gallery&#x2F;&quot;&gt; Gallery &lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;&#x2F;archives&#x2F;&quot;&gt; Archives &lt;&#x2F;a&gt;\n\n_config.yml网站\n参数描述\n\ntitle网站标题\n\nsubtitle网站副标题\n\ndescription网站描述\n\nkeywords网站的关键词。使用半角逗号 , 分隔多个关键词。\n\nauthor您的名字\n\nlanguage网站使用的语言\n\ntimezone网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。\n其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。\n网址\n参数描述默认值\n\nurl网址\n\nroot网站根目录\n\npermalink文章的 永久链接 格式:year/:month/:day/:title/\n\npermalink_defaults永久链接中各部分的默认值\n\npretty_urls改写 permalink 的值来美化 URL\n\npretty_urls.trailing_index是否在永久链接中保留尾部的 index.html，设置为 false 时去除true\n\npretty_urls.trailing_html是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效)true\n目录\n参数描述默认值\n\nsource_dir资源文件夹，这个文件夹用来存放内容。source\n\npublic_dir公共文件夹，这个文件夹用于存放生成的站点文件。public\n\ntag_dir标签文件夹tags\n\narchive_dir归档文件夹archives\n\ncategory_dir分类文件夹categories\n\ncode_dirInclude code 文件夹，source_dir 下的子目录downloads/code\n\ni18n_dir国际化（i18n）文件夹:lang\n\nskip_render跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。\n文章\n参数描述默认值\n\nnew_post_name新文章的文件名称:title.md\n\ndefault_layout预设布局post\n\nauto_spacing在中文和英文之间加入空格false\n\ntitlecase把标题转换为 title casefalse\n\nexternal_link在新标签中打开链接true\n\nexternal_link.enable在新标签中打开链接true\n\nexternal_link.field对整个网站（site）生效或仅对文章（post）生效site\n\nexternal_link.exclude需要排除的域名。主域名和子域名如 www 需分别配置[]\n\nfilename_case把文件名称转换为 (1) 小写或 (2) 大写0\n\nrender_drafts显示草稿false\n\npost_asset_folder启动 Asset 文件夹false\n\nrelative_link把链接改为与根目录的相对位址false\n\nfuture显示未来的文章true\n\nhighlight代码块的设置\n\nhighlight.enable开启代码块高亮true\n\nhighlight.auto_detect如果未指定语言，则启用自动检测false\n\nhighlight.line_number显示行数 Enabling this option will also enable wrap optiontrue\n\nhighlight.tab_replace用 n 个空格替换 tabs；如果值为空，则不会替换 tabs&#39;&#39;\n\nhighlight.wrapWrap the code block in ``true\n\nhighlight.hljsUse the hljs-* prefix for CSS classesfalse\n分类 &amp; 标签\n参数描述默认值\n\ndefault_category默认分类uncategorized\n\ncategory_map分类别名\n\ntag_map标签别名\n日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。\n\n参数描述默认值\n\ndate_format日期格式YYYY-MM-DD\n\ntime_format时间格式HH:mm:ss\n\nuse_date_for_updated启用以后，如果 Front Matter 中没有指定 updated， post.updated 将会使用 date 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用true\n分页\n参数描述默认值\n\nper_page每页显示的文章量 (0 = 关闭分页功能)10\n\npagination_dir分页目录page\n扩展\n参数描述\n\ntheme当前主题名称。值为false时禁用主题\n\ntheme_config主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置\n\ndeploy部署部分的设置\n\nmeta_generatorMeta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签\nthemes目录结构123456.├── _config.yml├── languages├── layout├── scripts└── source\n\n_config.yml主题的配置文件。修改时自动更新，无需重启服务器。\nlanguages语言文件夹\nlayout布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式，Hexo 内建 Swig 模板引擎，您可以另外安装插件来获得 EJS、Haml 或 Jade 支持，Hexo 根据模板文件的扩展名来决定所使用的模板引擎，例如：\n12layout.ejs   - 使用 EJSlayout.swig  - 使用 Swig\n\nscripts脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件，请参见 插件 以获得更多信息。\nsource资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。文件或文件夹开头名称为 _（下划线线）或隐藏的文件会被忽略。\n如果文件可以被渲染的话，会经过解析然后储存到 public 文件夹，否则会直接拷贝到 public 文件夹。\n指令生成文件使用 Hexo 生成静态文件快速而且简单。\n1$ hexo generate\n\n监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。\n1$ hexo generate --watch\n\n完成后部署您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。\n1$ hexo generate --deploy$ hexo deploy --generate\n\n\n简写\n上面两个命令可以简写为$ hexo g -d$ hexo d -g\n\ninit1`$ hexo init [folder]`\n\nnew1`$ hexo new [layout] &lt;title&gt;`\n\n新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。\n1$ hexo new \"post title with whitespace\"\n\n\n参数描述\n\n-p, --path自定义新文章的路径\n\n-r, --replace如果存在同名文章，将其替换\n\n-s, --slug文章的 Slug，作为新文章的文件名和发布后的 URL\n默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录：\n1hexo new page --path about/me \"About me\"\n\n以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot;\n注意！title 是必须指定的！如果你这么做并不能达到你的目的：\n1hexo new page --path about/me\n\n此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 &quot;page&quot;。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。\ngenerate1$ hexo generate\n\n生成静态文件。\n\n选项描述\n\n-d, --deploy文件生成后立即部署网站\n\n-w, --watch监视文件变动\n\n-b, --bail生成过程中如果发生任何未处理的异常则抛出异常\n\n-f, --force强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate\n\n-c, --concurrency最大同时生成文件的数量，默认无限制\n该命令可以简写为\n1$ hexo g\n\npublish1$ hexo publish [layout] &lt;filename&gt;\n\n发表草稿。\nserver1$ hexo server\n\n启动服务器。默认情况下，访问网址为： http://localhost:4000/。\n\n选项描述\n\n-p, --port重设端口\n\n-s, --static只使用静态文件\n\n-l, --log启动日记记录，使用覆盖记录格式\ndeploy1$ hexo deploy\n\n部署网站。\n\n参数描述\n\n-g, --generate部署之前预先生成静态文件\n该命令可以简写为：\n1$ hexo d\n\nrender1$ hexo render &lt;file1&gt; [file2] ...\n\n渲染文件。\n\n参数描述\n\n-o, --output设置输出路径\nmigrate1$ hexo migrate &lt;type&gt;\n\n从其他博客系统 迁移内容。\nclean1$ hexo clean\n\n清除缓存文件 (db.json) 和已生成的静态文件 (public)。\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\nlist1$ hexo list &lt;type&gt;\n\n列出网站资料。\n自定义配置文件的路径1234567# 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高$ hexo generate --config custom.yml,custom2.json,custom3.yml\n\n自定义配置文件的路径，指定这个参数后将不再使用默认的 _config.yml。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：\n1234567# 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json$ hexo generate --config custom.yml,custom2.json,custom3.yml\n\n当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。\noptions$ hexo --safe\n1232. &#96;&#96;&#96;shell   $ hexo --debug\n\n$ hexo --silent\n1234. &#96;&#96;&#96;shell   $ hexo --draft&#96;\n\n```shell$ hexo –cwd /path/to/cwd`\n1234## Front-matterFront-matter 是文件最上方以 &#96;---&#96; 分隔的区域，用于指定个别文件的变量，举例来说：\n—title: Hello Worlddate: 2013/7/13 20:46:25—\n12345678910111213141516171819202122232425以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。| 参数         | 描述                                                 | 默认值       || :----------- | :--------------------------------------------------- | :----------- || &#96;layout&#96;     | 布局                                                 |              || &#96;title&#96;      | 标题                                                 | 文章的文件名 || &#96;date&#96;       | 建立日期                                             | 文件建立日期 || &#96;updated&#96;    | 更新日期                                             | 文件更新日期 || &#96;comments&#96;   | 开启文章的评论功能                                   | true         || &#96;tags&#96;       | 标签（不适用于分页）                                 |              || &#96;categories&#96; | 分类（不适用于分页）                                 |              || &#96;permalink&#96;  | 覆盖文章网址                                         |              || &#96;keywords&#96;   | 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） |              |### 分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 &#96;Foo, Bar&#96; 不等于 &#96;Bar, Foo&#96;；而标签没有顺序和层次。&#96;&#96;&#96;yamlcategories:  - Diarytags:  - PS3  - Games\n\n\n分类方法的分歧\n如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：\n123categories:  - Diary  - Life\n\n会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。\n如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。\n1234categories:  - [Diary, PlayStation]  - [Diary, Games]  - [Life]\n\n此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。\n\nJSON Front-matter除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可。\n123\"title\": \"Hello World\",\"date\": \"2013/7/13 20:46:25\";;;\n\n标签插件（Tag Plugins）标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。\n引用块在文章中插入引言，可包含作者、来源和标题。\n别号： quote\n123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125;\n\n样例没有提供参数，则只输出普通的 blockquote\n123&#123;% blockquote %&#125;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.&#123;% endblockquote %&#125;\n\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.\n\n引用书上的句子\n123&#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125;\n\n\nDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.\nDavid LevithanWide Awake\n\n引用 Twitter\n123&#123;% blockquote @DevDocs https:&#x2F;&#x2F;twitter.com&#x2F;devdocs&#x2F;status&#x2F;356095192085962752 %&#125;NEW: DevDocs now comes with syntax highlighting. http:&#x2F;&#x2F;devdocs.io&#123;% endblockquote %&#125;\n\n\nNEW: DevDocs now comes with syntax highlighting. http://devdocs.io\n@DevDocstwitter.com/devdocs/status/356095192085962752\n\n引用网络上的文章\n123&#123;% blockquote Seth Godin http:&#x2F;&#x2F;sethgodin.typepad.com&#x2F;seths_blog&#x2F;2009&#x2F;07&#x2F;welcome-to-island-marketing.html Welcome to Island Marketing %&#125;Every interaction is both precious and an opportunity to delight.&#123;% endblockquote %&#125;\n\n\nEvery interaction is both precious and an opportunity to delight.\nSeth GodinWelcome to Island Marketing\n\n代码块在文章中插入代码。\n别名： code\n123&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;code snippet&#123;% endcodeblock %&#125;\n\nSpecify additional options in option:value format, e.g. line_number:false first_line:5.\n\nExtra OptionsDescriptionDefault\n\nline_numberShow line numbertrue\n\nhighlightEnable code highlightingtrue\n\nfirst_lineSpecify the first line number1\n\nmarkLine highlight specific line(s), each value separated by a comma. Specify number range using a dash Example: mark:1,4-7,10 will mark line 1, 4 to 7 and 10.\n\nwrapWrap the code block in ``true\n样例普通的代码块\n12345&#123;% codeblock %&#125;alert(&#39;Hello World!&#39;);&#123;% endcodeblock %&#125;alert(&#39;Hello World!&#39;);\n\n指定语言\n12345&#123;% codeblock lang:objc %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];&#123;% endcodeblock %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];\n\n附加说明\n12345&#123;% codeblock Array.map %&#125;array.map(callback[, thisArg])&#123;% endcodeblock %&#125;Array.maparray.map(callback[, thisArg])\n\n附加说明和网址\n12345&#123;% codeblock _.compact http:&#x2F;&#x2F;underscorejs.org&#x2F;#compact Underscore.js %&#125;_.compact([0, 1, false, 2, &#39;&#39;, 3]);&#x3D;&gt; [1, 2, 3]&#123;% endcodeblock %&#125;_.compactUnderscore.js_.compact([0, 1, false, 2, &#39;&#39;, 3]);&#x3D;&gt; [1, 2, 3]\n\n反引号代码块另一种形式的代码块，不同的是它使用三个反引号来包裹。\n``` [language] [title] [url] [link text] code snippet ```\nPull Quote在文章中插入 Pull quote。\n123&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125;\n\njsFiddle在文章中嵌入 jsFiddle。\n1&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125;\n\nGist在文章中嵌入 Gist。\n1&#123;% gist gist_id [filename] %&#125;\n\niframe在文章中插入 iframe。\n1&#123;% iframe url [width] [height] %&#125;\n\nImage在文章中插入指定大小的图片。\n1&#123;% img [class names] &#x2F;path&#x2F;to&#x2F;image [width] [height] &#39;&quot;title text&quot; &quot;alt text&quot;&#39; %&#125;\n\nLink在文章中插入链接，并自动给外部链接添加 target=&quot;_blank&quot; 属性。\n1&#123;% link text url [external] [title] %&#125;\n\nInclude Code插入 source/downloads/code 文件夹内的代码文件。source/downloads/code 不是固定的，取决于你在配置文件中 code_dir 的配置。\n1&#123;% include_code [title] [lang:language] [from:line] [to:line] path&#x2F;to&#x2F;file %&#125;\n\n样例嵌入 test.js 文件全文1&#123;% include_code lang:javascript test.js %&#125;\n\n只嵌入第 3 行1&#123;% include_code lang:javascript from:3 to:3 test.js %&#125;\n\n嵌入第 5 行至第 8 行1&#123;% include_code lang:javascript from:5 to:8 test.js %&#125;\n\n嵌入第 5 行至文件结束1&#123;% include_code lang:javascript from:5 test.js %&#125;\n\n嵌入第 1 行至第 8 行1&#123;% include_code lang:javascript to:8 test.js %&#125;\n\nYoutube在文章中插入 Youtube 视频。\n1&#123;% youtube video_id %&#125;\n\nVimeo在文章中插入 Vimeo 视频。\n1&#123;% vimeo video_id %&#125;\n\n引用文章引用其他文章的链接。\n1&#123;% post_path filename %&#125;&#123;% post_link filename [title] [escape] %&#125;\n\n在使用此标签时可以忽略文章文件所在的路径或者文章的永久链接信息、如语言、日期。\n例如，在文章中使用  时，只需有一个名为 how-to-bake-a-cake.md 的文章文件即可。即使这个文件位于站点文件夹的 source/posts/2015-02-my-family-holiday 目录下、或者文章的永久链接是 2018/en/how-to-bake-a-cake，都没有影响。\n默认链接文字是文章的标题，你也可以自定义要显示的文本。此时不应该使用 Markdown 语法 []()。\n默认对文章的标题和自定义标题里的特殊字符进行转义。可以使用escape选项，禁止对特殊字符进行转义。\n链接使用文章的标题1&#123;% post_link hexo-3-8-released %&#125;\n\nHexo 3.8.0 Released\n链接使用自定义文字1&#123;% post_link hexo-3-8-released &#39;通往文章的链接&#39; %&#125;\n\n通往文章的链接\n对标题的特殊字符进行转义1&#123;% post_link hexo-4-released &#39;How to use &lt;b&gt; tag in title&#39; %&#125;\n\nHow to use  tag in title\n禁止对标题的特殊字符进行转义1&#123;% post_link hexo-4-released &#39;&lt;b&gt;bold&lt;&#x2F;b&gt; custom title&#39; false %&#125;\n\nbold custom title\n引用资源引用文章的资源。\n1&#123;% asset_path filename %&#125;&#123;% asset_img filename [title] %&#125;&#123;% asset_link filename [title] [escape] %&#125;\n\nRaw如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。\n1&#123;% raw %&#125;content&#123;% endraw %&#125;\n\n文章摘要和截断在文章中使用 &lt;!-- more --&gt;，那么 &lt;!-- more --&gt; 之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中。\n例如：\n1Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;!-- more --&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\n首页中将只会出现\n1Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n\n正文中则会出现\n1Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\n注意，摘要可能会被 Front Matter 中的 excerpt 覆盖。\n自定义永久链接（Permalinks）您可以在 _config.yml 配置中调整网站的永久链接或者在每篇文章的 Front-matter 中指定。\n变量除了下列变量外，您还可使用 Front-matter 中的所有属性。\n\n变量描述\n\n:year文章的发表年份（4 位数）\n\n:month文章的发表月份（2 位数）\n\n:i_month文章的发表月份（去掉开头的零）\n\n:day文章的发表日期 (2 位数)\n\n:i_day文章的发表日期（去掉开头的零）\n\n:hour文章发表时的小时 (2 位数)\n\n:minute文章发表时的分钟 (2 位数)\n\n:title文件名称\n\n:post_title文章标题\n\n:id文章 ID (not persistent across cache reset)\n\n:category分类。如果文章没有分类，则是 default_category 配置信息。\n您可在 permalink_defaults 参数下调整永久链接中各变量的默认值：\n12permalink_defaults:   lang: en\n\n示例假设 source/_posts 文件夹中有个 hello-world.md，包含以下内容：\n12345title: Hello Worlddate: 2013-07-14 17:01:34categories:  - foo  - bar\n\n\n参数结果\n\n:year/:month/:day/:title/2013/07/14/hello-world/\n\n:year-:month-:day-:title.html2013-07-14-hello-world.html\n\n:category/:title/foo/bar/hello-world/\n多语种支持若要建立一个多语种的网站，您可修改 new_post_name 和 permalink 参数，如下：\n12new_post_name: :lang/:title.mdpermalink: :lang/:title/\n\n当您建立新文章时，文章会被储存到：\n12$ hexo new \"Hello World\" --lang tw# =&gt; source/_posts/tw/Hello-World.md\n\n而网址会是：\n1http:&#x2F;&#x2F;localhost:4000&#x2F;tw&#x2F;hello-world&#x2F;\n\n模版模板决定了网站内容的呈现方式，每个主题至少都应包含一个 index 模板，以下是各页面相对应的模板名称：\n\n模板用途回退\n\nindex首页\n\npost文章index\n\npage分页index\n\narchive归档index\n\ncategory分类归档archive\n\ntag标签归档archive\n布局（Layout）如果页面结构类似，例如两个模板都有页首（Header）和页脚（Footer），您可考虑通过「布局」让两个模板共享相同的结构。一个布局文件必须要能显示 body 变量的内容，如此一来模板的内容才会被显示，举例来说：\n12345678index.ejsindexlayout.ejs&lt;!DOCTYPE html&gt;&lt;html&gt;   &lt;body&gt;&lt;%- body %&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n\n生成：\n1234&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;index&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n\n每个模板都默认使用 layout 布局，您可在 front-matter 指定其他布局，或是设为 false 来关闭布局功能，您甚至可在布局中再使用其他布局来建立嵌套布局。\n局部模版（Partial）局部模板让您在不同模板之间共享相同的组件，例如页首（Header）、页脚（Footer）或侧边栏（Sidebar）等，可利用局部模板功能分割为个别文件，让维护更加便利。举例来说：\n123456partial&#x2F;header.ejs&lt;h1 id&#x3D;&quot;logo&quot;&gt;&lt;%&#x3D; config.title %&gt;&lt;&#x2F;h1&gt;index.ejs&lt;%- partial(&#39;partial&#x2F;header&#39;) %&gt;&lt;div id&#x3D;&quot;content&quot;&gt;Home page&lt;&#x2F;div&gt;\n\n生成：\n12&lt;h1 id&#x3D;&quot;logo&quot;&gt;My Site&lt;&#x2F;h1&gt;&lt;div id&#x3D;&quot;content&quot;&gt;Home page&lt;&#x2F;div&gt;\n\n局部变量您可以在局部模板中指定局部变量并使用。\n123456partial&#x2F;header.ejs&lt;h1 id&#x3D;&quot;logo&quot;&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;h1&gt;index.ejs&lt;%- partial(&#39;partial&#x2F;header&#39;, &#123;title: &#39;Hello World&#39;&#125;) %&gt;&lt;div id&#x3D;&quot;content&quot;&gt;Home page&lt;&#x2F;div&gt;\n\n生成：\n12&lt;h1 id&#x3D;&quot;logo&quot;&gt;Hello World&lt;&#x2F;h1&gt;&lt;div id&#x3D;&quot;content&quot;&gt;Home page&lt;&#x2F;div&gt;\n\n优化如果您的主题太过于复杂，或是需要生成的文件量太过于庞大，可能会大幅降低性能，除了简化主题外，您可以考虑 Hexo 2.7 新增的局部缓存（Fragment Caching） 功能。\n本功能借鉴于 Ruby on Rails，它储存局部内容，下次便能直接使用缓存内容，可以减少文件夹查询并使生成速度更快。\n它可用于页首、页脚、侧边栏等文件不常变动的位置，举例来说：\n1&lt;%- fragment_cache(&#39;header&#39;, function()&#123;  return &#39;&lt;header&gt;&lt;&#x2F;header&gt;&#39;;&#125;);\n\n如果您使用局部模板的话，可以更简单：\n1&lt;%- partial(&#39;header&#39;, &#123;&#125;, &#123;cache: true&#125;);\n\n\nfragment_cache() 将会缓存第一次的渲染结果，并在之后直接输出缓存的结果。因此只有在不同页面的渲染结果都相同时才应使用局部缓存。比如，在配置中启用了 relative_link 后不应该使用局部缓存，因为相对链接在每个页面可能不同。\n\n变量全局变量\n变量描述类型\n\nsite网站变量object; 见 网站变量\n\npage针对该页面的内容以及 front-matter 中自定义的变量。object; 见 页面变量\n\nconfig网站配置object (站点的配置文件)\n\ntheme主题配置。继承自网站配置。object (主题配置文件)\n\n_ (单下划线)Lodash 函数库Lodash 文档\n\npath当前页面的路径（不含根路径）string\n\nurl当前页面的完整网址string\n\nenv环境变量???\n网站变量\n变量描述类型\n\nsite.posts所有文章array of post objects\n\nsite.pages所有分页array of page objects\n\nsite.categories所有分类object，包含了站点全部的分类\n\nsite.tags所有标签array，包含了站点全部的标签\n页面变量页面（page）\n变量描述类型\n\npage.title页面标题string\n\npage.date页面建立日期Moment.js 对象\n\npage.updated页面更新日期Moment.js 对象\n\npage.comments留言是否开启boolean\n\npage.layout布局名称string\n\npage.content页面的完整内容string\n\npage.excerpt页面摘要string\n\npage.more除了页面摘要的其余内容string\n\npage.source页面原始路径string\n\npage.full_source页面的完整原始路径string\n\npage.path页面网址（不含根路径）。我们通常在主题中使用 url_for(page.path)。string\n\npage.permalink页面的完整网址string\n\npage.prev上一个页面。如果此为第一个页面则为 null。string or null\n\npage.next下一个页面。如果此为最后一个页面则为 null。string or null\n\npage.raw文章的原始内容???\n\npage.photos文章的照片（用于相簿）array\n\npage.link文章的外部链接（用于链接文章）string\n文章 (post): 与 page 布局相同，但新增以下变量。\n\n变量描述类型\n\npage.published如果该文章已发布则为 trueboolean\n\npage.categories该文章的所有分类array of ???\n\npage.tags该文章的所有标签array of ???\n首页（index）\n\n变量描述类型\n\npage.per_page每页显示的文章数量number\n\npage.total总页数number\n\npage.current目前页数number\n\npage.current_url目前分页的网址string\n\npage.posts本页文章 (Data Model)object\n\npage.prev上一页的页数。如果此页是第一页的话则为 0。number\n\npage.prev_link上一页的网址。如果此页是第一页的话则为 &#39;&#39;。string\n\npage.next下一页的页数。如果此页是最后一页的话则为 0。number\n\npage.next_link下一页的网址。如果此页是最后一页的话则为 &#39;&#39;。string\n\npage.path当前页面的路径（不含根目录）。我们通常在主题中使用 url_for(page.path)。string\n归档 (archive)：与 index 布局相同，但新增以下变量。\n\n变量描述类型\n\npage.archive等于 trueboolean\n\npage.year年份归档 (4位)number\n\npage.month月份归档 (没有前导零的2位数)number\n分类 (category)：与 index 布局相同，但新增以下变量。\n\n变量描述类型\n\npage.category分类名称string\n标签 (tag)：与 index 布局相同，但新增以下变量。\n\n变量描述类型\n\npage.tag标签名称string\n","plink":"https://www.hansomezao.com/2020/02/29/note/hexo/"},{"title":"webpack4","date":"2019-12-10T05:39:30.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"author":"网上收集,来源不明","updated":"2019-12-10T05:39:30.000Z","content":"安装前先npm初始化\n本地服务\n复制html\n处理css\n处理less\n抽离css文件，通过link引入\n压缩css和js\n给css加上兼容浏览器的前缀\nes6 转 es5\n转es7的语法其他不兼容的高级语法\n\n语法检查 eslint\n全局变量引入法1：\n法2：\n法3. 如何在每个模块中注入：\n法4：\n\nwebpack图片打包\n当图片小于多少，用base64\n打包文件分类\n希望输出的时候，给这些css\\img加上前缀，传到服务器也能访问\n如果只希望处理图片\n打包多页应用\n配置source-map\nwatch 改完代表重新打包实体\nwebpack的其他三个小插件\nwebpack 跨域\n1.如果后端给的请求没有API 「跨域」\n2.前端只想单纯mock数据 「跨域」\n3.有服务端，不用代理, 服务端启动webpack 「跨域」\nwebpack解析resolve\n但是每次引入都很长，如何优雅引入\n省略扩展名\n定义环境变量\n区分两个不同的环境\nwebpack 优化\n优化：当某些包是独立的个体没有依赖\n优化：规则匹配设置范围\n优化：忽略依赖中不必要的语言包\n动态链接库\n多线程打包happypack\nwebpack 自带的优化\n抽取公共代码\n懒加载(延迟加载)\n热更新(当页面改变只更新改变的部分，不重新打包)\ntapable介绍 - SyncHook\ntapable介绍 - SyncBailHook\ntapable介绍 - SyncWaterfallHook\ntapable介绍 - SyncLoopHook\nAsyncParallelHook 与 AsyncParallelBailHookAsyncParallelHook\nAsyncParallelBailHook\n\n异步串行 —— AsyncSeriesHook\n异步串行 —— AsyncSeriesWaterfallHook\n手写webpack\nwebpack分析及处理\n创建依赖关系\nast递归解析\n生成打包工具\n增加loader\n增加plugins\nloader\n配置多个loader\nbabel-loader实现\nbanner-loader实现(自创)\n实现file-loader和url-loader\nless-loader和css-loader\ncss-loader\nwebpack 中的插件\n文件列表插件\n内联的webpack插件\n打包后自动发布\n安装前先npm初始化12npm init -ynpm i webpack webpack-cli -D\n\n\nwebpack.config.js1234567891011let path = require('path')   // 相对路径变绝对路径module.exports = &#123;  mode: 'production', // 模式 默认 production development  entry: './src/index',    // 入口  output: &#123;    filename: 'bundle.[hash:8].js',   // hash: 8只显示8位    path: path.resolve(__dirname, 'dist'),    publicPath: ''  // // 给所有打包文件引入时加前缀，包括css，js，img，如果只想处理图片可以单独在url-loader配置中加publicPath  &#125;&#125;\n本地服务npm i webpack-dev-server -D\n1234567devServer: &#123;  port: 3000,  progress: true          &#x2F;&#x2F; 滚动条  contentBase: &#39;.&#x2F;build&#39;  &#x2F;&#x2F; 起服务的地址  open: true              &#x2F;&#x2F; 自动打开浏览器  compress： true         &#x2F;&#x2F; gzip压缩&#125;\n\n\n复制htmlnpm i html-webpack-plugin -D\n123456789101112let HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)plugins: [ &#x2F;&#x2F; 放着所有webpack插件  new HtmlWebpackPlugin(&#123; &#x2F;&#x2F; 用于使用模板打包时生成index.html文件，并且在run dev时会将模板文件也打包到内存中    template: &#39;.&#x2F;index.html&#39;, &#x2F;&#x2F; 模板文件    filename: &#39;index.html&#39;, &#x2F;&#x2F; 打包后生成文件    hash: true, &#x2F;&#x2F; 添加hash值解决缓存问题    minify: &#123; &#x2F;&#x2F; 对打包的html模板进行压缩      removeAttributeQuotes: true, &#x2F;&#x2F; 删除属性双引号      collapseWhitespace: true &#x2F;&#x2F; 折叠空行变成一行    &#125;  &#125;)]\n\nhtml-webpack-plugin#options\n处理cssnpm i css-loader style-loader -D\n12345678910111213141516171819202122232425262728&#x2F;&#x2F; css-loader   作用：用来解析@import这种语法&#x2F;&#x2F; style-loader 作用：把 css 插入到head标签中&#x2F;&#x2F; loader的执行顺序： 默认是从右向左（从下向上）module: &#123;    &#x2F;&#x2F; 模块  rules: [   &#x2F;&#x2F; 规则    &#x2F;&#x2F; style-loader 把css插入head标签中    &#x2F;&#x2F; loader 功能单一    &#x2F;&#x2F; 多个loader 需要 []    &#x2F;&#x2F; 顺便默认从右到左    &#x2F;&#x2F; 也可以写成对象方式    &#123;      test: &#x2F;\\.css$&#x2F;,   &#x2F;&#x2F; css 处理      &#x2F;&#x2F; use: &#39;css-loader&#39;      &#x2F;&#x2F; use: [&#39;style-loader&#39;, &#39;css-loader&#39;],      use: [        &#x2F;&#x2F; &#123;        &#x2F;&#x2F;     loader: &#39;style-loader&#39;,        &#x2F;&#x2F;     options: &#123;        &#x2F;&#x2F;         insertAt: &#39;top&#39; &#x2F;&#x2F; 将css标签插入最顶头  这样可以自定义style不被覆盖        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; &#125;,        MiniCssExtractPlugin.loader,        &#39;css-loader&#39;, &#x2F;&#x2F; css-loader 用来解析@import这种语法,        &#39;postcss-loader&#39;      ]    &#125;  ]&#125;\n\n\n处理lessnpm i less-loader\n12345678910111213141516171819&#123;  test: &#x2F;\\.less$&#x2F;,   &#x2F;&#x2F; less 处理  &#x2F;&#x2F; use: &#39;css-loader&#39;  &#x2F;&#x2F; use: [&#39;style-loader&#39;, &#39;css-loader&#39;],  use: [    &#x2F;&#x2F; &#123;    &#x2F;&#x2F;     loader: &#39;style-loader&#39;,    &#x2F;&#x2F;     options: &#123;    &#x2F;&#x2F;         insertAt: &#39;top&#39; &#x2F;&#x2F; 将css标签插入最顶头  这样可以自定义style不被覆盖    &#x2F;&#x2F;     &#125;    &#x2F;&#x2F; &#125;,    MiniCssExtractPlugin.loader,   &#x2F;&#x2F; 这样相当于抽离成一个css文件， 如果希望抽离成分别不同的css, 需要再引入MiniCssExtractPlugin，再配置    &#39;css-loader&#39;, &#x2F;&#x2F; css-loader 用来解析@import这种语法    &#39;postcss-loader&#39;,    &#39;less-loader&#39; &#x2F;&#x2F; less-loader less -&gt; css    &#x2F;&#x2F; sass node-sass sass-loader    &#x2F;&#x2F; stylus stylus-loader  ]&#125;\n\nless-loader\n抽离css文件，通过link引入yarn add mini-css-extract-plugin -D\nmini-css-extract-plugin\n123456789101112131415161718192021222324252627let MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;)&#x2F;&#x2F; 压缩cssplugins: [  new MiniCssExtractPlugin(&#123;      filename: &#39;css&#x2F;main.css&#39;  &#125;)]&#123;  test: &#x2F;\\.css$&#x2F;,   &#x2F;&#x2F; css 处理  &#x2F;&#x2F; use: &#39;css-loader&#39;  &#x2F;&#x2F; use: [&#39;style-loader&#39;, &#39;css-loader&#39;],  use: [    &#x2F;&#x2F; &#123;    &#x2F;&#x2F;     loader: &#39;style-loader&#39;,    &#x2F;&#x2F;     options: &#123;    &#x2F;&#x2F;         insertAt: &#39;top&#39; &#x2F;&#x2F; 将css标签插入最顶头  这样可以自定义style不被覆盖    &#x2F;&#x2F;     &#125;    &#x2F;&#x2F; &#125;,    &#x2F;&#x2F; 此时不需要style-loader    MiniCssExtractPlugin.loader,   &#x2F;&#x2F; 抽离    &#39;css-loader&#39;, &#x2F;&#x2F; css-loader 用来解析@import这种语法,    &#39;postcss-loader&#39;  ]&#125;\n\n抽离css插件文件时可使用optimize-css-assets-webpack-plugin优化压缩css以及js文件\n压缩css和js12345678910111213141516171819&#x2F;&#x2F; 用了&#96;mini-css-extract-plugin&#96;抽离css为link需使用&#96;optimize-css-assets-webpack-plugin&#96;进行压缩css,使用此方法压缩了css需要&#96;uglifyjs-webpack-plugin&#96;压缩jsconst OptimizeCSSAssetsPlugin &#x3D; require(&quot;optimize-css-assets-webpack-plugin&quot;)const UglifyJsPlugin &#x3D; require(&quot;uglifyjs-webpack-plugin&quot;)module.exports &#x3D; &#123;  optimization: &#123;              &#x2F;&#x2F; 优化项    minimizer: [      new UglifyJsPlugin(&#123;     &#x2F;&#x2F; 优化js        cache: true,           &#x2F;&#x2F; 是否缓存        parallel: true,        &#x2F;&#x2F; 是否并发打包        &#x2F;&#x2F; sourceMap: true     &#x2F;&#x2F; 源码映射 set to true if you want JS source maps      &#125;),      new OptimizeCSSAssetsPlugin(&#123;&#125;)    &#x2F;&#x2F; css 的优化    ]  &#125;,  mode: &#39;production&#39;,  entry: &#39;&#39;,  output: &#123;&#125;,&#125;\n\n给css加上兼容浏览器的前缀yarn add postcss-loader autoprefixer -D\n12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F; css&#123;  test: &#x2F;\\.css$&#x2F;,   &#x2F;&#x2F; css 处理  &#x2F;&#x2F; use: &#39;css-loader&#39;  &#x2F;&#x2F; use: [&#39;style-loader&#39;, &#39;css-loader&#39;],  use: [    &#x2F;&#x2F; &#123;    &#x2F;&#x2F;     loader: &#39;style-loader&#39;,    &#x2F;&#x2F;     options: &#123;    &#x2F;&#x2F;         insertAt: &#39;top&#39; &#x2F;&#x2F; 将css标签插入最顶头  这样可以自定义style不被覆盖    &#x2F;&#x2F;     &#125;    &#x2F;&#x2F; &#125;,    MiniCssExtractPlugin.loader,    &#39;css-loader&#39;, &#x2F;&#x2F; css-loader 用来解析@import这种语法,    &#39;postcss-loader&#39;  ]&#125;&#x2F;&#x2F; less&#123;  test: &#x2F;\\.less$&#x2F;,   &#x2F;&#x2F; less 处理  &#x2F;&#x2F; use: &#39;css-loader&#39;  &#x2F;&#x2F; use: [&#39;style-loader&#39;, &#39;css-loader&#39;],  use: [    &#x2F;&#x2F; &#123;    &#x2F;&#x2F;     loader: &#39;style-loader&#39;,    &#x2F;&#x2F;     options: &#123;    &#x2F;&#x2F;         insertAt: &#39;top&#39; &#x2F;&#x2F; 将css标签插入最顶头  这样可以自定义style不被覆盖    &#x2F;&#x2F;     &#125;    &#x2F;&#x2F; &#125;,    MiniCssExtractPlugin.loader,   &#x2F;&#x2F; 这样相当于抽离成一个css文件， 如果希望抽离成分别不同的css, 需要再引入MiniCssExtractPlugin，再配置    &#39;css-loader&#39;, &#x2F;&#x2F; css-loader 用来解析@import这种语法    &#39;postcss-loader&#39;,    &#39;less-loader&#39; &#x2F;&#x2F; less-loader less -&gt; css    &#x2F;&#x2F; sass node-sass sass-loader    &#x2F;&#x2F; stylus stylus-loader  ]&#125;,\n\npostcss 需要配置文档   postcss.config1.js\npostcss-loader\n12345module.exports &#x3D; &#123;  plugins: [    require(&#39;autoprefixer&#39;)  ]&#125;\n\nes6 转 es5npm i babel-loader @babel/core  @babel/preset-env -D\n1234567891011121314151617181920212223module.exports &#x3D; &#123;  module: &#123;    rules: [      &#123;        test: &#x2F;\\.js$&#x2F;,        use: &#123;          loader: &#39;babel-loader&#39;,          options: &#123;            presets: [ &#x2F;&#x2F;预设              &#39;@babel&#x2F;preset-env&#39;             ],            plugins:[              &#x2F;&#x2F; 转es7的语法              [&quot;@babel&#x2F;plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125;],              [&quot;@babel&#x2F;plugin-proposal-class-properties&quot;, &#123; &quot;loose&quot; : true &#125;]            ]          &#125;        &#125;,        exclude: &#x2F;node_modules&#x2F;      &#125;    ]  &#125;&#125;\n\n\n转es7的语法12345&#x2F;&#x2F; 转classnpm i @babel&#x2F;plugin-proposal-class-properties -D&#x2F;&#x2F; 转装饰器npm i @babel&#x2F;plugin-proposal-decorators -D\n\n配置如上\n其他不兼容的高级语法1使用 @babel&#x2F;polyfill\n\n语法检查 eslintnpm i eslint eslint-loader -S\n根目录添加 .eslintrc.json 配置文件\n123456789101112131415161718192021222324252627module.exports &#x3D; &#123;  module: &#123;    rules: [      &#123;        test: &#x2F;\\.js$&#x2F;,        use: &#123;          loader: &#39;eslint-loader&#39;,          options: &#123;            enforce: &#39;pre&#39;  &#x2F;&#x2F; previous优先执行  post-普通loader之后执行          &#125;        &#125;      &#125;,      &#123;        test: &#x2F;\\.js$&#x2F;,      &#x2F;&#x2F; mormal 普通的loader        use: &#123;          loader: &#39;babel-loader&#39;,          options: &#123;            presets: [ &#x2F;&#x2F;预设              &#39;@babel&#x2F;preset-env&#39;             ]          &#125;        &#125;,        exclude: &#x2F;node_modules&#x2F;      &#125;    ]  &#125;&#125;\n\n全局变量引入jquery的引入\n1npm i jquery -S\n\n12345let webpack &#x3D; require(&#39;webpack&#39;)new webpack.ProvidePlugin(&#123;  $: &#39;jquery&#39;&#125;)\n\n其他情况\n暴露全局\nnpm i expose-loader -D 暴露全局的loader\n法1：可以在js中 import $ from &#39;expose-loader?$!jquery&#39;   // 全局暴露jquery为$符号\n可以调用window.$\n法2：也可在webpack.config.js 中配置 rules\n12345678910module.exports &#x3D; &#123;  module: &#123;    rules: [      &#123;        test: require.resolve(&#39;jquery&#39;),        use: &#39;expose-loader?$&#39;      &#125;    ]  &#125;&#125;\n以后在.js文件中引入\n1import $ from &#39;jquery&#39;\n\n法3. 如何在每个模块中注入：1234567891011let webpack &#x3D; require(&#39;webpack&#39;)module.exports &#x3D; &#123;  plugins: [    new webpack.ProvidePlugin(&#123;      $: &#39;jquery&#39;    &#125;)  ]&#125;之后代码内直接使用 $\n法4：在index.html中通过script标签引入jquery, 但是在js中，用import会重新打包jquery,如何避免\n从输出的bundle 中排除依赖\n12345module.exports &#x3D; &#123;  externals: &#123; &#x2F;&#x2F; 告知webpack是外部引入的，不需要打包    jquery: &#39;jQuery&#39;  &#125;&#125;\n\n此时在index.js上\n123import $ from &#39;jquery&#39;console.log($)\n\nwebpack图片打包js中创建\ncss中引入\n&lt;img src=&quot;&quot;&gt;\nyarn add file-loader -D\n适合一二情况\n12345678910module.export&#x3D;&#123;  module: &#123;    rules: [      &#123;        test: &#x2F;\\.(png|jpg|gif)$&#x2F;,        use: &#39;file-loader&#39;      &#125;    ]  &#125;&#125;\n\n默认会内部生成一张图片到build,生成图片的路径返回回来\n第一种情况: 图片地址要import引入，直接写图片的地址，会默认为字符串\n12345import logo from &#39;.&#x2F;logo.png&#39;let image &#x3D; new Image()image.src &#x3D; logodocument.body.appendChild(image)\n\n第二种情况: css-loader会将css里面的图片转为require的格式\n123div &#123;  background: url(&quot;.&#x2F;logo.png&quot;);&#125;\n\n第三种情况: 解析html中的image\nyarn add html-withimg-loader -D\n1234&#123;  test: &#x2F;\\.html$&#x2F;,  use: &#39;html-withimg-loader&#39;&#125;\n\n当图片小于多少，用base64yarn add url-loader -D\n如果过大，才用file-loader\n123456789101112&#123;  test: &#x2F;\\.(png|jpg|gif)$&#x2F;,  &#x2F;&#x2F; 当图片小于多少，用base64,否则用file-loader产生真实的图片  use: &#123;    loader: &#39;url-loader&#39;,    options: &#123;      limit: 200 * 1024,          &#x2F;&#x2F; 小于200k变成base64      &#x2F;&#x2F; outputPath: &#39;&#x2F;img&#x2F;&#39;,     &#x2F;&#x2F; 打包后输出地址      &#x2F;&#x2F; publicPath: &#39;&#39;           &#x2F;&#x2F; 给资源加上域名路径    &#125;  &#125;&#125;\n\n打包文件分类1.图片:\n1234567891011&#123;  test: &#x2F;\\.(png|jpg|gif)$&#x2F;,  &#x2F;&#x2F; 当图片小于多少，用base64,否则用file-loader产生真实的图片  use: &#123;    loader: &#39;url-loader&#39;,    options: &#123;      limit: 1,  &#x2F;&#x2F; 200k 200 * 1024      outputPath: &#39;img&#x2F;&#39;   &#x2F;&#x2F; 打包后输出地址 在dist&#x2F;img    &#125;  &#125;&#125;,\n\n2.css:\n12345plugins: [  new MiniCssExtractPlugin(&#123;    filename: &#39;css&#x2F;main.css&#39;  &#125;),]\n\n希望输出的时候，给这些css\\img加上前缀，传到服务器也能访问12345output: &#123;  filename: &#39;bundle.[hash:8].js&#39;,   &#x2F;&#x2F; hash: 8只显示8位  path: path.resolve(__dirname, &#39;dist&#39;),  publicPath: &#39;http:&#x2F;&#x2F;www.mayufo.cn&#39;  &#x2F;&#x2F; 给静态资源统一加&#125;,\n\n\n如果只希望处理图片123456789101112&#123;  test: &#x2F;\\.(png|jpg|gif)$&#x2F;,  &#x2F;&#x2F; 当图片小于多少，用base64,否则用file-loader产生真实的图片  use: &#123;    loader: &#39;url-loader&#39;,    options: &#123;      limit: 1,  &#x2F;&#x2F; 200k 200 * 1024      outputPath: &#39;&#x2F;img&#x2F;&#39;,   &#x2F;&#x2F; 打包后输出地址      publicPath: &#39;http:&#x2F;&#x2F;www.mayufo.cn&#39;    &#125;  &#125;&#125;\n\n打包多页应用123456789101112131415161718192021222324252627&#x2F;&#x2F; 多入口let path &#x3D; require(&#39;path&#39;)let HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)module.exports &#x3D; &#123;  mode: &#39;development&#39;,  entry: &#123;    home: &#39;.&#x2F;src&#x2F;index.js&#39;,    other: &#39;.&#x2F;src&#x2F;other.js&#39;  &#125;,  output: &#123;    filename: &quot;[name].js&quot;,    path: path.resolve(__dirname, &#39;dist2&#39;)  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;.&#x2F;index.html&#39;,      filename: &#39;home.html&#39;,      chunks: [&#39;home&#39;]    &#125;),    new HtmlWebpackPlugin(&#123;      template: &#39;.&#x2F;index.html&#39;,      filename: &#39;other.html&#39;,      chunks: [&#39;other&#39;, &#39;home&#39;]   &#x2F;&#x2F; other.html 里面有 other.js &amp; home.js    &#125;),  ]&#125;\n\n配置source-mapyarn add @babel/core  @babel/preset-env babel-loader  webpack-dev-server -D\n123module.exports &#x3D; &#123;  devtool: &#39;source-map&#39; &#x2F;&#x2F; 增加映射文件调试源代码&#125;\n源码映射 会标识错误的代码 打包后生成独立的文件 大而全 「source-map」\n不会陈胜单独的文件 但是可以显示行和列  「eval-source-map」\n不会产生列有行，产生单独的映射文件  「cheap-module-source-map」\n不会产生文件 集成在打包后的文件中 不会产生列有行 「cheap-module-eval-source-map」\nwatch 改完代表重新打包实体12345678module.exports &#x3D; &#123;  watch: true,  watchOptions: &#123;    poll: 1000,              &#x2F;&#x2F; 每秒监听1000次    aggregateTimeout: 300,   &#x2F;&#x2F; 防抖，当第一个文件更改，会在重新构建前增加延迟    ignored: &#x2F;node_modules&#x2F;  &#x2F;&#x2F; 对于某些系统，监听大量文件系统会导致大量的 CPU 或内存占用。这个选项可以排除一些巨大的文件夹，  &#125;,&#125;\n\n\nwebpack的其他三个小插件cleanWebpackPlugin\n每次打包之前删掉dist目录yarn add clean-webpack-plugin -D\nclean-webpack-plugin\n12345678910const CleanWebpackPlugin &#x3D; require(&#39;clean-webpack-plugin&#39;);module.exports &#x3D; &#123;  output: &#123;    path: path.resolve(process.cwd(), &#39;dist&#39;),  &#125;,  plugins: [    new CleanWebpackPlugin(&#39;.&#x2F;dist&#39;)  ]&#125;\n\ncopyWebpackPlugin\n一些静态资源也希望拷贝的dist中\nyarn add copy-webpack-plugin -D\n123456789const CopyWebpackPlugin &#x3D; require(&#39;copy-webpack-plugin&#39;)module.exports &#x3D; &#123;  plugins: [    new CopyWebpackPlugin([      &#123;from: &#39;doc&#39;, to: &#39;.&#x2F;dist&#39;&#125;    ])  ]&#125;\n\nbannerPlugin内置模块\n版权声明\n12345const webpack &#x3D; require(&#39;webpack&#39;);new webpack.BannerPlugin(&#39;hello world&#39;)&#x2F;&#x2F; ornew webpack.BannerPlugin(&#123; banner: &#39;hello world&#39;&#125;)\n\nwebpack 跨域设置一个服务,由于webpack-dev-server内含express\nexpress\nserver.js\n1234567891011&#x2F;&#x2F; expresslet express &#x3D; require(&#39;express&#39;)let app &#x3D; express();app.get(&#39;&#x2F;api&#x2F;user&#39;, (res) &#x3D;&gt; &#123;  res.json(&#123;name: &#39;mayufo&#39;&#125;)&#125;)app.listen(3000)   &#x2F;&#x2F; 服务端口在3000\n\n写完后记得node server.js\n访问 http://localhost:3000/api/user 可见内容\nindex.js\n1234567891011&#x2F;&#x2F; 发送一个请求let xhr &#x3D; new XMLHttpRequest();&#x2F;&#x2F; 默认访问 http:&#x2F;&#x2F;localhost:8080  webpack-dev-server 的服务 再转发给3000xhr.open(&#39;GET&#39;, &#39;&#x2F;api&#x2F;user&#39;, true);xhr.onload &#x3D; function () &#123;  console.log(xhr.response)&#125;xhr.send();\n\n\nwebpack.config.js\n1234567module.exports &#x3D; &#123;  devServer: &#123;    proxy: &#123;      &#39;&#x2F;api&#39;: &#39;http:&#x2F;&#x2F;localhost:3000&#39;    &#125;  &#125;,&#125;\n\n1.如果后端给的请求没有API 「跨域」123456789101112&#x2F;&#x2F; expresslet express &#x3D; require(&#39;express&#39;)let app &#x3D; express();app.get(&#39;&#x2F;user&#39;, (res) &#x3D;&gt; &#123;  res.json(&#123;name: &#39;mayufo&#39;&#125;)&#125;)app.listen(3000)   &#x2F;&#x2F; 服务端口在3000\n\n\n请求已api开头, 转发的时候再删掉api\n12345678devServer: &#123;  proxy: &#123;    &#39;&#x2F;api&#39;: &#123;      target: &#39;http:&#x2F;&#x2F;localhost:3000&#39;,      pathRewrite: &#123;&#39;^&#x2F;api&#39;: &#39;&#39;&#125;    &#125;  &#125;&#125;\n\n2.前端只想单纯mock数据 「跨域」12345678910111213141516devServer: &#123;  &#x2F;&#x2F; proxy: &#123;  &#x2F;&#x2F;     &#39;&#x2F;api&#39;: &#39;http:&#x2F;&#x2F;localhost:3000&#39; &#x2F;&#x2F; 配置一个代理  &#x2F;&#x2F; &#125;  &#x2F;&#x2F;   proxy: &#123;   &#x2F;&#x2F; 重写方式 把请求代理到express 上  &#x2F;&#x2F;       &#39;&#x2F;api&#39;: &#123;  &#x2F;&#x2F;           target: &#39;http:&#x2F;&#x2F;localhost:3000&#39;,  &#x2F;&#x2F;           pathRewrite: &#123;&#39;^&#x2F;api&#39;: &#39;&#39;&#125;  &#x2F;&#x2F;       &#125;  &#x2F;&#x2F;   &#125;  before: function (app) &#123;  &#x2F;&#x2F; 勾子    app.get(&#39;&#x2F;api&#x2F;user&#39;, (req, res) &#x3D;&gt; &#123;      res.json(&#123;name: &#39;tigerHee&#39;&#125;)    &#125;)  &#125;&#125;,\n\n3.有服务端，不用代理, 服务端启动webpack 「跨域」server.js中启动webpack\nyarn add webpack-dev-middleware -D\nserver.js\n123456789101112131415161718192021222324&#x2F;&#x2F; expresslet express &#x3D; require(&#39;express&#39;)let webpack &#x3D; require(&#39;webpack&#39;)let app &#x3D; express();&#x2F;&#x2F; 中间件let middle &#x3D; require(&#39;webpack-dev-middleware&#39;)let config &#x3D; require(&#39;.&#x2F;webpack.config&#39;)let compiler &#x3D; webpack(config)app.use(middle(compiler))app.get(&#39;&#x2F;user&#39;, (req, res) &#x3D;&gt; &#123;  res.json(&#123;name: &#39;mayufo&#39;&#125;)&#125;)app.listen(3000)\n\nwebpack解析resolve以bootstrap为例\n1npm install bootstrap  -D\n\nindex.js\n1import &#39;bootstrap&#x2F;dist&#x2F;css&#x2F;bootstrap.css&#39;\n\n报错\n12345678910ERROR in .&#x2F;node_modules&#x2F;bootstrap&#x2F;dist&#x2F;css&#x2F;bootstrap.css 7:0Module parse failed: Unexpected token (7:0)You may need an appropriate loader to handle this file type.|  * Licensed under MIT (https:&#x2F;&#x2F;github.com&#x2F;twbs&#x2F;bootstrap&#x2F;blob&#x2F;master&#x2F;LICENSE)|  *&#x2F;&gt; :root &#123;|   --blue: #007bff;|   --indigo: #6610f2; @ .&#x2F;src&#x2F;index.js 22:0-42 @ multi (webpack)-dev-server&#x2F;client?http:&#x2F;&#x2F;localhost:8081 .&#x2F;src&#x2F;index.js\n\n这是因为bootstrap 4.0的css引入了新的特性，CSS Variables\n安装npm install postcss-custom-properties --save-dev\n配置webpack.config.js\n1234567891011&#123;  test: &#x2F;\\.css$&#x2F;,  use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#123;    loader: &#39;postcss-loader&#39;,    options: &#123;      plugins: (loader) &#x3D;&gt; [        require(&quot;postcss-custom-properties&quot;)      ]    &#125;  &#125;]&#125;\n\n但是每次引入都很长，如何优雅引入1234567resolve: &#123;  &#x2F;&#x2F; 在当前目录查找  modules: [path.resolve(&#39;node_modules&#39;)],  alias: &#123;      &#39;bootstrapCss&#39;: &#39;bootstrap&#x2F;dist&#x2F;css&#x2F;bootstrap.css&#39;  &#125;&#125;,\n\n1import &#39;bootstrapCss&#39;  &#x2F;&#x2F; 在node_modules查找\n\n省略扩展名extensions:\n12345678910resolve: &#123;  &#x2F;&#x2F; 在当前目录查找  modules: [path.resolve(&#39;node_modules&#39;)],  &#x2F;&#x2F; alias: &#123;  &#x2F;&#x2F;   &#39;bootstrapCss&#39;: &#39;bootstrap&#x2F;dist&#x2F;css&#x2F;bootstrap.css&#39;  &#x2F;&#x2F; &#125;,  mainFields: [&#39;style&#39;, &#39;main&#39;],   &#x2F;&#x2F; 先用bootstrap中在package中的style,没有在用main  &#x2F;&#x2F; mainFiles: []  &#x2F;&#x2F; 入口文件的名字 默认index  extensions: [&#39;.js&#39;, &#39;.css&#39;, &#39;.json&#39;]  &#x2F;&#x2F; 当没有拓展命的时候，先默认js、次之css、再次之json&#125;,\n\n定义环境变量DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和生产模式的构建允许不同的行为非常有用。\n12345678let url &#x3D; &#39;&#39;if (DEV &#x3D;&#x3D;&#x3D; &#39;dev&#39;) &#123;  &#x2F;&#x2F; 开发环境  url &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#39;&#125; else &#123;  &#x2F;&#x2F; 生成环境  url &#x3D; &#39;http:&#x2F;&#x2F;www.mayufo.cn&#39;&#125;\n\nwebpack.config.js\n123456new webpack.DefinePlugin(&#123;  &#x2F;&#x2F; DEV: &#39;&quot;production&quot;&#39;,  DEV: JSON.stringify(&#39;production&#39;),  FLAG: &#39;true&#39;,   &#x2F;&#x2F; 布尔  EXPRESSION: &#39;1 + 1&#39;   &#x2F;&#x2F; 字符串 如果希望是字符串 JSON.stringify(&#39;1 + 1&#39;)&#125;)\n\n区分两个不同的环境分别配置不同的环境\nwebpack.base4.js   基础配置\nwebpack.dev4.js    开发环境\nwebpack.prod4.js   生产环境\nyarn add webpack-merge -D\nnpm run build -- -- config webpack.dev4.jsnpm run build -- -- config webpack.build.js\n官方文档\nwebpack.base4.js\n123456789101112131415161718192021222324252627282930313233343536373839404142434445let path &#x3D; require(&#39;path&#39;)let HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)let CleanWebpackPlugin &#x3D; require(&#39;clean-webpack-plugin&#39;)module.exports &#x3D; &#123;  entry: &#123;    home: &#39;.&#x2F;src&#x2F;index.js&#39;  &#125;,  output: &#123;    filename: &quot;[name].js&quot;,    path: path.resolve(process.cwd(), &#39;dist3&#39;)  &#125;,  module: &#123;    rules: [      &#123;        test: &#x2F;\\.js$&#x2F;,        use: &#123;          loader: &#39;babel-loader&#39;,          options: &#123;            presets: [              &#39;@babel&#x2F;preset-env&#39;            ]          &#125;        &#125;      &#125;,      &#123;        test: &#x2F;\\.css$&#x2F;,        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#123;          loader: &#39;postcss-loader&#39;,          options: &#123;            plugins: (loader) &#x3D;&gt; [              require(&quot;postcss-custom-properties&quot;)            ]          &#125;        &#125;]      &#125;    ]  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;.&#x2F;src&#x2F;index.html&#39;,      filename: &#39;index.html&#39;    &#125;)  ]&#125;\n\nwebpack.dev4.js\n12345678let merge &#x3D; require(&#39;webpack-merge&#39;)let base &#x3D; require(&#39;.&#x2F;webpack.base4.js&#39;)module.exports &#x3D; merge(base, &#123;  mode: &#39;development&#39;,  devServer: &#123;&#125;,  devtool: &#39;source-map&#39;&#125;)\n\nwebpack.prod4.js\n123456let merge &#x3D; require(&#39;webpack-merge&#39;)let base &#x3D; require(&#39;.&#x2F;webpack.base4.js&#39;)module.exports &#x3D; merge(base, &#123;  mode: &#39;production&#39;&#125;)\n\npackage.json\n1234&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;webpack  --config webpack.prod4.js&quot;,  &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev4.js&quot;&#125;,\n\n\nwebpack 优化yarn add webpack webpack-cli html-webpack-plugin @babel/core babel-loader @babel/preset-env @babel/preset-react -D\nwebpack.config.js\n12345678910111213141516171819202122232425262728293031323334let path &#x3D; require(&#39;path&#39;)let HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)module.exports &#x3D; &#123;  mode: &#39;development&#39;,  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,  output: &#123;    filename: &#39;main.js&#39;,    path: path.resolve(__dirname, &#39;dist&#39;)  &#125;,  module: &#123;    rules: [      &#123;        test: &#x2F;\\.js$&#x2F;,        use: &#123;          loader: &#39;babel-loader&#39;,          options: &#123;            presets: [              &#39;@babel&#x2F;preset-env&#39;,              &#39;@babel&#x2F;preset-react&#39;            ]          &#125;        &#125;      &#125;,    ]  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      template: &#39;.&#x2F;src&#x2F;index.html&#39;,      filename: &#39;index.html&#39;    &#125;),  ]&#125;\n优化：当某些包是独立的个体没有依赖以jquery为例，yarn add jquery -D,它是一个独立的包没有依赖，可以在webpack配置中，配置它不再查找依赖\n1234567891011121314151617module: &#123;    noParse: &#x2F;jquery&#x2F;, &#x2F;&#x2F; 不用解析某些包的依赖    rules: [      &#123;        test: &#x2F;\\.js$&#x2F;,        use: &#123;          loader: &#39;babel-loader&#39;,          options: &#123;            presets: [              &#39;@babel&#x2F;preset-env&#39;,              &#39;@babel&#x2F;preset-react&#39;            ]          &#125;        &#125;      &#125;,  ]&#125;\n运行npx webpack\n从2057ms  -&gt; 1946 ms\n优化：规则匹配设置范围123456789101112131415rules: [  &#123;    test: &#x2F;\\.js$&#x2F;,    exclude: &#39;&#x2F;node_modules&#x2F;&#39;,   &#x2F;&#x2F; 排除    include: path.resolve(&#39;src&#39;),  &#x2F;&#x2F; 在这个范围内    use: &#123;      loader: &#39;babel-loader&#39;,      options: &#123;        presets: [          &#39;@babel&#x2F;preset-env&#39;,          &#39;@babel&#x2F;preset-react&#39;        ]      &#125;    &#125;  &#125;\n\n尽量实用include,不使用exclude,使用绝对路径\n优化：忽略依赖中不必要的语言包yarn add moment webpack-dev-server -D\n忽略掉moment的其他语言包\n12345let webpack &#x3D; require(&#39;webpack&#39;)plugins: [    new webpack.IgnorePlugin(&#x2F;\\.\\&#x2F;locale&#x2F;, &#x2F;moment&#x2F;)]\n\nindex.js\n1234import moment from &#39;moment&#39;let r &#x3D; moment().endOf(&#39;day&#39;).fromNow()  &#x2F;&#x2F; 距离现在多少天console.log(r);\n\n\n从 1.2MB 到  800kb\n动态链接库yarn add react react-dom\n正常使用\nwebpack.config.js\n1234567891011121314&#123;  test: &#x2F;\\.js$&#x2F;,  exclude: &#39;&#x2F;node_modules&#x2F;&#39;,  include: path.resolve(&#39;src&#39;),  use: &#123;    loader: &#39;babel-loader&#39;,    options: &#123;      presets: [        &#39;@babel&#x2F;preset-env&#39;,        &#39;@babel&#x2F;preset-react&#39;      ]    &#125;  &#125;&#125;\n\nindex.js\n123456import React from &#39;react&#39;import &#123;render&#125; from &#39;react-dom&#39;render(&lt;h1&gt;111111&lt;&#x2F;h1&gt;, window.root)\n\nindex.html\n1&lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;\n\n独立的将react react-dom 打包好, 打包好再引用，从而减少webpack每次都要打包react\n创建webpack.config.react.js\n12345678910111213141516171819202122let path &#x3D; require(&#39;path&#39;)let webpack &#x3D; require(&#39;webpack&#39;)module.exports &#x3D; &#123;  mode: &#39;development&#39;,  entry: &#123;    &#x2F;&#x2F; test: &#39;.&#x2F;src&#x2F;test.js&#39;    react: [&#39;react&#39;, &#39;react-dom&#39;]  &#125;,  output: &#123;    filename: &#39;_dll_[name].js&#39;,  &#x2F;&#x2F; 产生的文件名    path: path.resolve(__dirname, &#39;dist&#39;),    library: &#39;_dll_[name]&#39;,     &#x2F;&#x2F; 给输出的结果加个名字    &#x2F;&#x2F; libraryTarget: &#39;var&#39;   &#x2F;&#x2F; 配置如何暴露 library    &#x2F;&#x2F; commonjs 结果放在export属性上， umd统一资源模块, 默认是var  &#125;,  plugins: [    new webpack.DllPlugin(&#123;      name: &#39;_dll_[name]&#39;,   &#x2F;&#x2F; name &#x3D;&#x3D;&#x3D; library      path: path.resolve(__dirname, &#39;dist&#39;, &#39;manifest.json&#39;)  &#x2F;&#x2F; manifest.json 定义了各个模块的路径    &#125;)  ]&#125;\n\nlibraryTarget\nmanifest.json就是一个任务清单or动态链接库，在这个清单里面查找react\nnpx webpack --config webpack.config.react.js\n在index.html增加引用\n1234&lt;body&gt;&lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;&#x2F;_dll_react.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;\n\n在webpack.config.js 中配置，现在动态链接库manifest.json中查找,如果没有再打包react\n12345plugins: [  new webpack.DllReferencePlugin(&#123;    manifest: path.resolve(__dirname, &#39;dist&#39;, &#39;manifest.json&#39;)  &#125;)]\n\nDLLPlugin 和 DLLReferencePlugin\nnpm run build\n打包后的bunle.js文件变小\nnpm run dev\n可以理解为先把react打包，后面每次都直接使用react打包后的结果\n多线程打包happypackyarn add happypack\nwebpack.config.js\n1234567891011121314151617181920212223242526let Happypack &#x3D; require(&#39;happypack&#39;)rules: [  &#123;    test: &#x2F;\\.js$&#x2F;,    exclude: &#39;&#x2F;node_modules&#x2F;&#39;,    include: path.resolve(&#39;src&#39;),    use: &#39;happypack&#x2F;loader?id&#x3D;js&#39;  &#125;,]plugins: [  new Happypack(&#123;    id: &#39;js&#39;,    use: [&#123;      loader: &#39;babel-loader&#39;,      options: &#123;        presets: [          &#39;@babel&#x2F;preset-env&#39;,          &#39;@babel&#x2F;preset-react&#39;        ]      &#125;    &#125;]  &#125;)]\n\njs启用多线程，由于启用多线程也会浪费时间，因此当项目比较大的时候启用效果更好\ncss启用多线程\n12345678910&#123;  test: &#x2F;\\.css$&#x2F;,  use: &#39;happypack&#x2F;loader?id&#x3D;css&#39;&#125;new Happypack(&#123;  id: &#39;css&#39;,  use: [&#39;style-loader&#39;, &#39;css-loader&#39;]&#125;),\n\nwebpack 自带的优化test.js\n1234567891011let sum &#x3D; (a, b) &#x3D;&gt; &#123;  return a + b + &#39;sum&#39;&#125;let minus &#x3D; (a, b) &#x3D;&gt; &#123;  return a - b + &#39;minus&#39;;&#125;export default &#123;  sum, minus&#125;\n\n使用import \nindex.js\n123import calc from &#39;.&#x2F;test&#39;console.log(calc.sum(1, 2));\n\n\nimport在生产环境下会自动去除没有用的代码minus，这叫tree-shaking，将没有用的代码自动删除掉\nindex.js\n123let calc &#x3D; require(&#39;.&#x2F;test&#39;)console.log(calc);   &#x2F;&#x2F; es 6导出，是一个default的对象console.log(calc.default.sum(1, 2));\n\nrequire引入es6 模块会把结果放在default上,打包build后并不会把多余minus代码删除掉，不支持tree-shaking\n作用域的提升\nindex.js\n123456let a &#x3D; 1let b &#x3D; 2let c &#x3D; 3let d &#x3D; a + b + cconsole.log(d, &#39;---------&#39;);\n打包出来的文件\n1console.log(r.default.sum(1,2));console.log(6,&quot;---------&quot;)\n\n在webpack中可以省略一些可以简化的代码\n抽取公共代码抽离自有模块\nwebpack.config.js\n12345678910111213module.exports &#x3D; &#123;  optimization: &#123;    splitChunks: &#123;             &#x2F;&#x2F; 分割代码块，针对多入口      cacheGroups: &#123;           &#x2F;&#x2F; 缓存组        common: &#123;              &#x2F;&#x2F; 公共模块          minSize: 0,          &#x2F;&#x2F; 大于多少抽离          minChunks: 2,        &#x2F;&#x2F; 使用多少次以上抽离抽离          chunks: &#39;initial&#39;    &#x2F;&#x2F; 从什么地方开始, 从入口开始        &#125;      &#125;    &#125;  &#125;,&#125;\nSplitChunksPlugin\n分别有a.js和b.js, index.js和other.js分别引入a和b两个js\nindex.js\n1234import &#39;.&#x2F;a&#39;import &#39;.&#x2F;b&#39;console.log(&#39;index.js&#39;);\n\nother.js\n1234import &#39;.&#x2F;a&#39;import &#39;.&#x2F;b&#39;console.log(&#39;other.js&#39;);\n\nwebpack.config.js\n12345678910111213module.exports &#x3D; &#123;  optimization: &#123;    splitChunks: &#123;             &#x2F;&#x2F; 分割代码块，针对多入口      cacheGroups: &#123;           &#x2F;&#x2F; 缓存组        common: &#123;              &#x2F;&#x2F; 公共模块          minSize: 0,          &#x2F;&#x2F; 大于多少抽离          minChunks: 2,        &#x2F;&#x2F; 使用多少次以上抽离抽离          chunks: &#39;initial&#39;    &#x2F;&#x2F; 从什么地方开始, 从入口开始        &#125;      &#125;    &#125;  &#125;,&#125;\n\n抽离第三方模块\n比如jquery\nindex.js 和 other.js分别引入\n123import $ from &#39;jquery&#39;console.log($);\n\n修改webpack.config.js配置：\n123456789101112131415161718optimization: &#123;  splitChunks: &#123;              &#x2F;&#x2F; 分割代码块，针对多入口    cacheGroups: &#123;            &#x2F;&#x2F; 缓存组      common: &#123;               &#x2F;&#x2F; 公共模块        minSize: 0,           &#x2F;&#x2F; 大于多少抽离        minChunks: 2,         &#x2F;&#x2F; 使用多少次以上抽离抽离        chunks: &#39;initial&#39;     &#x2F;&#x2F; 从什么地方开始,刚开始      &#125;,      vendor: &#123;        priority: 1,          &#x2F;&#x2F; 增加权重, (先抽离第三方)        test: &#x2F;node_modules&#x2F;, &#x2F;&#x2F; 把此目录下的抽离        minSize: 0,           &#x2F;&#x2F; 大于多少抽离        minChunks: 2,         &#x2F;&#x2F; 使用多少次以上抽离抽离        chunks: &#39;initial&#39;     &#x2F;&#x2F; 从什么地方开始,刚开始      &#125;    &#125;  &#125;,&#125;,\n\n懒加载(延迟加载)yarn add @babel/plugin-syntax-dynamic-import  -D\nsource.js\n1export default &#39;mayufo&#39;\n\nindex.js\n12345678910let button &#x3D; document.createElement(&#39;button&#39;)button.innerHTML &#x3D; &#39;hello&#39;button.addEventListener(&#39;click&#39;, function () &#123;  console.log(&#39;click&#39;)  &#x2F;&#x2F; es6草案中的语法，jsonp实现动态加载文件  import(&#39;.&#x2F;source.js&#39;).then(data &#x3D;&gt; &#123;    console.log(data.default)  &#125;)&#125;)document.body.appendChild(button)\n\nwebpack.config.js\n1234567891011121314151617&#123;  test: &#x2F;\\.js$&#x2F;,  exclude: &#39;&#x2F;node_modules&#x2F;&#39;,  include: path.resolve(&#39;src&#39;),  use: [&#123;    loader: &#39;babel-loader&#39;,    options: &#123;      presets: [        &#39;@babel&#x2F;preset-env&#39;,        &#39;@babel&#x2F;preset-react&#39;      ],      plugins: [        &#39;@babel&#x2F;plugin-syntax-dynamic-import&#39;      ]    &#125;  &#125;]&#125;\n\n热更新(当页面改变只更新改变的部分，不重新打包)webpack.config.js\n12345678plugins: [  new HtmlWebpackPlugin(&#123;    template: &#39;.&#x2F;src&#x2F;index.html&#39;,    filename: &#39;index.html&#39;  &#125;),  new webpack.NameModulesPlugin(),          &#x2F;&#x2F; 打印更新的模块路径  new webpack.HotModuleReplacementPlugin()  &#x2F;&#x2F; 热更新插件]\n\nindex.js\n123456789101112import str from &#39;.&#x2F;source&#39;console.log(str);if (module.hot) &#123;  module.hot.accept(&#39;.&#x2F;source&#39;, () &#x3D;&gt; &#123;    console.log(&#39;文件更新了&#39;);    require(&#39;.&#x2F;source&#39;)    console.log(str);  &#125;)&#125;\n\ntapable介绍 - SyncHooktapable\nwebpack本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是Tapable，webpack中最核心的负责编译的Compiler和负责创建bundles的Compilation都是Tapable的实例。\nSyncHook 不关心监听函数的返回值\nyarn add tabable\n1.use.js\n12345678910111213141516171819202122232425262728let &#123;SyncHook&#125; &#x3D; require(&#39;tapable&#39;)   &#x2F;&#x2F; 结构同步勾子class Lesson &#123;  constructor () &#123;    this.hooks &#x3D; &#123;      &#x2F;&#x2F; 订阅勾子      arch: new SyncHook([&#39;name&#39;]),    &#125;  &#125;  start () &#123;    this.hooks.arch.call(&#39;may&#39;)  &#125;  tap () &#123;   &#x2F;&#x2F;  注册监听函数    this.hooks.arch.tap(&#39;node&#39;, function (name) &#123;      console.log(&#39;node&#39;, name)    &#125;)    this.hooks.arch.tap(&#39;react&#39;, function (name) &#123;      console.log(&#39;react&#39;, name)    &#125;)  &#125;&#125;let l &#x3D; new Lesson()l.tap();  &#x2F;&#x2F;注册两个函数l.start() &#x2F;&#x2F; 启动勾子\n\n1.theory.js\n12345678910111213141516171819202122232425class SyncHook &#123;  &#x2F;&#x2F; 勾子是同步的  constructor(args) &#123;  &#x2F;&#x2F; args &#x3D;&gt; [&#39;name&#39;]    this.tasks &#x3D; []  &#125;  tap (name, task) &#123;    this.tasks.push(task)  &#125;  call (...args) &#123;    this.tasks.forEach((task) &#x3D;&gt; task(...args))  &#125;&#125;let hook &#x3D; new SyncHook([&#39;name&#39;])hook.tap(&#39;react&#39;, function (name) &#123;  console.log(&#39;react&#39;, name);&#125;)hook.tap(&#39;node&#39;, function (name) &#123;  console.log(&#39;node&#39;, name);&#125;)hook.call(&#39;jw&#39;)\n\n\ntapable介绍 - SyncBailHookSyncBailHook为勾子加了个保险，当return返回不是undefine就会停止\n2.use.js\n12345678910111213141516171819202122232425262728293031let &#123;SyncBailHook&#125; &#x3D; require(&#39;tapable&#39;)   &#x2F;&#x2F; 解构同步勾子class Lesson &#123;  constructor () &#123;    this.hooks &#x3D; &#123;      &#x2F;&#x2F; 订阅勾子      arch: new SyncBailHook([&#39;name&#39;]),    &#125;  &#125;  start () &#123;    &#x2F;&#x2F; 发布    this.hooks.arch.call(&#39;may&#39;)  &#125;  tap () &#123;   &#x2F;&#x2F;  注册监听函数,订阅    this.hooks.arch.tap(&#39;node&#39;, function (name) &#123;      console.log(&#39;node&#39;, name)      return &#39;停止学习&#39;  &#x2F;&#x2F; 会停止      &#x2F;&#x2F; return undefined    &#125;)    this.hooks.arch.tap(&#39;react&#39;, function (name) &#123;      console.log(&#39;react&#39;, name)    &#125;)  &#125;&#125;let l &#x3D; new Lesson()l.tap();  &#x2F;&#x2F;注册两个函数l.start() &#x2F;&#x2F; 启动勾子\n\n2.theory.js\n12345678910111213141516171819202122232425262728293031class SyncBailHook &#123;  &#x2F;&#x2F; 勾子是同步的    constructor(args) &#123;  &#x2F;&#x2F; args &#x3D;&gt; [&#39;name&#39;]        this.tasks &#x3D; []    &#125;    tap (name, task) &#123;        this.tasks.push(task)    &#125;    call (...args) &#123;        let ret;   &#x2F;&#x2F; 当前函数的返回值        let index &#x3D; 0; &#x2F;&#x2F; 当前要执行的第一个        do &#123;            ret &#x3D; this.tasks[index](...args)        &#125; while (ret &#x3D;&#x3D;&#x3D; undefined  &amp;&amp; index &lt; this.tasks.length)    &#125;&#125;let hook &#x3D; new SyncBailHook([&#39;name&#39;])hook.tap(&#39;react&#39;, function (name) &#123;    console.log(&#39;react&#39;, name);    return &#39;停止学习&#39;    &#x2F;&#x2F; return undefined&#125;)hook.tap(&#39;node&#39;, function (name) &#123;    console.log(&#39;node&#39;, name);&#125;)hook.call(&#39;jw&#39;)\n\ntapable介绍 - SyncWaterfallHookSyncWaterfallHook上一个监听函数的返回值可以传给下一个监听函数\n3.use.js\n1234567891011121314151617181920212223242526272829303132let &#123;SyncWaterfallHook&#125; &#x3D; require(&#39;tapable&#39;)   &#x2F;&#x2F; 解构同步勾子&#x2F;&#x2F; waterfall 瀑布class Lesson &#123;    constructor () &#123;        this.hooks &#x3D; &#123;            &#x2F;&#x2F; 订阅勾子            arch: new SyncWaterfallHook([&#39;name&#39;]),        &#125;    &#125;    start () &#123;        &#x2F;&#x2F; 发布        this.hooks.arch.call(&#39;may&#39;)    &#125;    tap () &#123;   &#x2F;&#x2F;  注册监听函数,订阅        this.hooks.arch.tap(&#39;node&#39;, function (name) &#123;            console.log(&#39;node&#39;, name)            return &#39;学的不错&#39;        &#125;)        this.hooks.arch.tap(&#39;react&#39;, function (name) &#123;            console.log(&#39;react&#39;, name)        &#125;)    &#125;&#125;let l &#x3D; new Lesson()l.tap();  &#x2F;&#x2F;注册两个函数l.start() &#x2F;&#x2F; 启动勾子\n\n3.theory.js\n1234567891011121314151617181920212223242526272829303132333435363738class SyncWaterfallHook &#123;  &#x2F;&#x2F; 勾子是同步的 - 瀑布    constructor(args) &#123;  &#x2F;&#x2F; args &#x3D;&gt; [&#39;name&#39;]        this.tasks &#x3D; []    &#125;    tap (name, task) &#123;        this.tasks.push(task)    &#125;    call (...args) &#123;        let [first, ...others] &#x3D; this.tasks;        let ret &#x3D; first(...args)        others.reduce((a, b) &#x3D;&gt; &#123;            return b(a);        &#125;, ret);    &#125;&#125;let hook &#x3D; new SyncWaterfallHook([&#39;name&#39;])hook.tap(&#39;react&#39;, function (name) &#123;    console.log(&#39;react&#39;, name);    return &#39;react Ok&#39;    &#x2F;&#x2F; return undefined&#125;)hook.tap(&#39;node&#39;, function (name) &#123;    console.log(&#39;node&#39;, name);    return &#39;node Ok&#39;&#125;)hook.tap(&#39;webpack&#39;, function (data) &#123;    console.log(&#39;webpack&#39;, data);&#125;)hook.call(&#39;jw&#39;)\n\ntapable介绍 - SyncLoopHookSyncLoopHook当监听函数被触发的时候，如果该监听函数返回true时则这个监听函数会反复执行，如果返回 undefined 则表示退出循环\n4.use.js\n123456789101112131415161718192021222324252627282930313233let &#123;SyncLoopHook&#125; &#x3D; require(&#39;tapable&#39;)   &#x2F;&#x2F; 解构同步勾子&#x2F;&#x2F; 不返回undefined 会多次执行class Lesson &#123;    constructor () &#123;        this.index &#x3D; 0        this.hooks &#x3D; &#123;            &#x2F;&#x2F; 订阅勾子            arch: new SyncLoopHook([&#39;name&#39;]),        &#125;    &#125;    start () &#123;        &#x2F;&#x2F; 发布        this.hooks.arch.call(&#39;may&#39;)    &#125;    tap () &#123;   &#x2F;&#x2F;  注册监听函数,订阅        this.hooks.arch.tap(&#39;node&#39;,  (name) &#x3D;&gt; &#123;            console.log(&#39;node&#39;, name)            return ++this.index &#x3D;&#x3D;&#x3D; 3 ? undefined : &#39;继续学&#39;        &#125;)        this.hooks.arch.tap(&#39;react&#39;,  (name) &#x3D;&gt; &#123;            console.log(&#39;react&#39;, name)        &#125;)    &#125;&#125;let l &#x3D; new Lesson()l.tap();  &#x2F;&#x2F;注册两个函数l.start() &#x2F;&#x2F; 启动勾子\n\n4.theory.js\n123456789101112131415161718192021222324252627282930313233343536class SyncLoopHook &#123;  &#x2F;&#x2F; 勾子是同步的 - 瀑布    constructor(args) &#123;  &#x2F;&#x2F; args &#x3D;&gt; [&#39;name&#39;]        this.tasks &#x3D; []    &#125;    tap (name, task) &#123;        this.tasks.push(task)    &#125;    call (...args) &#123;        this.tasks.forEach(task &#x3D;&gt; &#123;            let ret            do &#123;                ret &#x3D; task(...args);            &#125; while(ret !&#x3D;&#x3D; undefined)        &#125;)    &#125;&#125;let hook &#x3D; new SyncLoopHook([&#39;name&#39;])let total &#x3D; 0hook.tap(&#39;react&#39;, function (name) &#123;    console.log(&#39;react&#39;, name);    return ++total &#x3D;&#x3D;&#x3D; 3 ? undefined: &#39;继续学&#39;&#125;)hook.tap(&#39;node&#39;, function (name) &#123;    console.log(&#39;node&#39;, name);&#125;)hook.tap(&#39;webpack&#39;, function (data) &#123;    console.log(&#39;webpack&#39;, data);&#125;)hook.call(&#39;jw&#39;)\n\n\nAsyncParallelHook 与 AsyncParallelBailHook异步的勾子分两种串行和并行\n并行等待所有并发的异步事件执行后执行回调\n注册的三种方法\n异步的注册方法tap\n异步的注册方法tapAsync， 还有个回调参数\ntopPromise,注册promise\n调用的三种\ncall (同步)\ncallAsync （异步）\npromise （异步）\n这里介绍的是异步并行的\nAsyncParallelHook不关心监听函数的返回值。\n5.use.js\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465let &#123;AsyncParallelHook&#125; &#x3D; require(&#39;tapable&#39;)   &#x2F;&#x2F; 解构同步勾子&#x2F;&#x2F; 不返回undefined 会多次执行class Lesson &#123;    constructor() &#123;        this.index &#x3D; 0        this.hooks &#x3D; &#123;            &#x2F;&#x2F; 订阅勾子            arch: new AsyncParallelHook([&#39;name&#39;]),        &#125;    &#125;    start() &#123;        &#x2F;&#x2F; 发布callAsync        &#x2F;&#x2F; this.hooks.arch.callAsync(&#39;may&#39;, function () &#123;        &#x2F;&#x2F;     console.log(&#39;end&#39;);        &#x2F;&#x2F; &#125;)        &#x2F;&#x2F; 另一种发布promise        this.hooks.arch.promise(&#39;may&#39;).then(function () &#123;                console.log(&#39;end&#39;);            &#125;        )    &#125;    tap() &#123;   &#x2F;&#x2F;  注册监听函数,订阅        &#x2F;&#x2F; 注册tapAsync        &#x2F;&#x2F; this.hooks.arch.tapAsync(&#39;node&#39;,  (name, callback) &#x3D;&gt; &#123;        &#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;        &#x2F;&#x2F;         console.log(&#39;node&#39;, name)        &#x2F;&#x2F;         callback()        &#x2F;&#x2F;     &#125;, 1000)        &#x2F;&#x2F; &#125;)        &#x2F;&#x2F; this.hooks.arch.tapAsync(&#39;react&#39;,  (name, callback) &#x3D;&gt; &#123;        &#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;        &#x2F;&#x2F;         console.log(&#39;react&#39;, name)        &#x2F;&#x2F;         callback()        &#x2F;&#x2F;     &#125;, 1000)        &#x2F;&#x2F; &#125;)        &#x2F;&#x2F; 另一种订阅 tapPromise        this.hooks.arch.tapPromise(&#39;node&#39;, (name) &#x3D;&gt; &#123;            return new Promise((resolve, reject) &#x3D;&gt; &#123;                setTimeout(() &#x3D;&gt; &#123;                    console.log(&#39;node&#39;, name)                    resolve()                &#125;, 1000)            &#125;)        &#125;)        this.hooks.arch.tapPromise(&#39;react&#39;, (name) &#x3D;&gt; &#123;            return new Promise((resolve, reject) &#x3D;&gt; &#123;                setTimeout(() &#x3D;&gt; &#123;                    console.log(&#39;react&#39;, name)                    resolve()                &#125;, 1000)            &#125;)        &#125;)    &#125;&#125;let l &#x3D; new Lesson()l.tap();  &#x2F;&#x2F;注册两个函数l.start() &#x2F;&#x2F; 启动勾子\n\n\n5.theory.js\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class AsyncParallelHook &#123;  &#x2F;&#x2F; 勾子是同步的 - 瀑布    constructor(args) &#123;  &#x2F;&#x2F; args &#x3D;&gt; [&#39;name&#39;]        this.tasks &#x3D; []    &#125;    tapAsync(name, task) &#123;        this.tasks.push(task)    &#125;    tapPromise(name, task) &#123;        this.tasks.push(task)    &#125;    callAsync(...args) &#123;        let finalCallback &#x3D; args.pop()   &#x2F;&#x2F; 拿出最终的函数        let index &#x3D; 0        let done &#x3D; () &#x3D;&gt; &#123;   &#x2F;&#x2F; 类似promise.all的实现            index++;            if (index &#x3D;&#x3D;&#x3D; this.tasks.length) &#123;                finalCallback();            &#125;        &#125;        this.tasks.forEach(task &#x3D;&gt; &#123;            task(...args, done) &#x2F;&#x2F; 这里的args 已经把最后一个参数删掉        &#125;)    &#125;    promise(...args) &#123;        let tasks &#x3D; this.tasks.map(task &#x3D;&gt; task(...args))        return Promise.all(tasks)    &#125;&#125;let hook &#x3D; new AsyncParallelHook([&#39;name&#39;])&#x2F;&#x2F; hook.tapAsync(&#39;react&#39;, function (name, callback) &#123;&#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;&#x2F;&#x2F;         console.log(&#39;react&#39;, name);&#x2F;&#x2F;         callback()&#x2F;&#x2F;     &#125;, 1000)&#x2F;&#x2F; &#125;)&#x2F;&#x2F;&#x2F;&#x2F; hook.tapAsync(&#39;node&#39;, function (name, callback) &#123;&#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;&#x2F;&#x2F;         console.log(&#39;node&#39;, name);&#x2F;&#x2F;         callback()&#x2F;&#x2F;     &#125;, 1000)&#x2F;&#x2F; &#125;)&#x2F;&#x2F; hook.tapAsync(&#39;webpack&#39;, function (name, callback) &#123;&#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;&#x2F;&#x2F;         console.log(&#39;webpack&#39;, name);&#x2F;&#x2F;         callback()&#x2F;&#x2F;     &#125;, 1000)&#x2F;&#x2F; &#125;)hook.tapPromise(&#39;react&#39;, function (name, callback) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;            console.log(&#39;react&#39;, name);            resolve()        &#125;, 1000)    &#125;)&#125;)hook.tapPromise(&#39;node&#39;, function (name, callback) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;            console.log(&#39;node&#39;, name);            resolve()        &#125;, 1000)    &#125;)&#125;)&#x2F;&#x2F;&#x2F;&#x2F; hook.callAsync(&#39;jw&#39;, function () &#123;&#x2F;&#x2F;     console.log(&#39;end&#39;);&#x2F;&#x2F; &#125;)hook.promise(&#39;jw&#39;).then(function () &#123;    console.log(&#39;end&#39;);&#125;)\n\n\nAsyncParallelBailHook只要监听函数的返回值不为 null，就会忽略后面的监听函数执行，直接跳跃到callAsync等触发函数绑定的回调函数，然后执行这个被绑定的回调函数。\n使用和原理与SyncBailHook相似\n异步串行 —— AsyncSeriesHook串行one by one\n6.use.js\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let &#123;AsyncSeriesHook&#125; &#x3D; require(&#39;tapable&#39;)   &#x2F;&#x2F; 解构同步勾子class Lesson &#123;    constructor() &#123;        this.index &#x3D; 0        this.hooks &#x3D; &#123;            &#x2F;&#x2F; 订阅勾子            arch: new AsyncSeriesHook([&#39;name&#39;]),        &#125;    &#125;    start() &#123;        &#x2F;&#x2F; 发布        &#x2F;&#x2F; this.hooks.arch.callAsync(&#39;may&#39;, function () &#123;        &#x2F;&#x2F;     console.log(&#39;end&#39;);        &#x2F;&#x2F; &#125;)        &#x2F;&#x2F; 另一种发布        this.hooks.arch.promise(&#39;may&#39;).then(function () &#123;                console.log(&#39;end&#39;);            &#125;        )    &#125;    tap() &#123;   &#x2F;&#x2F;  注册监听函数,订阅        &#x2F;&#x2F; this.hooks.arch.tapAsync(&#39;node&#39;,  (name, callback) &#x3D;&gt; &#123;        &#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;        &#x2F;&#x2F;         console.log(&#39;node&#39;, name)        &#x2F;&#x2F;         callback()        &#x2F;&#x2F;     &#125;, 1000)        &#x2F;&#x2F; &#125;)        &#x2F;&#x2F; this.hooks.arch.tapAsync(&#39;react&#39;,  (name, callback) &#x3D;&gt; &#123;        &#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;        &#x2F;&#x2F;         console.log(&#39;react&#39;, name)        &#x2F;&#x2F;         callback()        &#x2F;&#x2F;     &#125;, 1000)        &#x2F;&#x2F; &#125;)        &#x2F;&#x2F; 另一种订阅        this.hooks.arch.tapPromise(&#39;node&#39;, (name) &#x3D;&gt; &#123;            return new Promise((resolve, reject) &#x3D;&gt; &#123;                setTimeout(() &#x3D;&gt; &#123;                    console.log(&#39;node&#39;, name)                    resolve()                &#125;, 1000)            &#125;)        &#125;)        this.hooks.arch.tapPromise(&#39;react&#39;, (name) &#x3D;&gt; &#123;            return new Promise((resolve, reject) &#x3D;&gt; &#123;                setTimeout(() &#x3D;&gt; &#123;                    console.log(&#39;react&#39;, name)                    resolve()                &#125;, 1000)            &#125;)        &#125;)    &#125;&#125;let l &#x3D; new Lesson()l.tap();  &#x2F;&#x2F;注册两个函数l.start(); &#x2F;&#x2F; 启动勾子\n\n6.theory.js\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class AsyncSeriesHook &#123;  &#x2F;&#x2F;    constructor(args) &#123;  &#x2F;&#x2F; args &#x3D;&gt; [&#39;name&#39;]        this.tasks &#x3D; []    &#125;    tapAsync(name, task) &#123;        this.tasks.push(task)    &#125;    tapPromise(name, task) &#123;        this.tasks.push(task)    &#125;    callAsync(...args) &#123;        let finalCallback &#x3D; args.pop()        let index &#x3D; 0;        let next &#x3D; () &#x3D;&gt; &#123;            if (this.tasks.length &#x3D;&#x3D;&#x3D; index) return finalCallback();            let task &#x3D; this.tasks[index++];            task(...args, next);        &#125;        next();    &#125;    promise(...args) &#123;        &#x2F;&#x2F; 将promise串联起来        let [first, ...other] &#x3D; this.tasks        return other.reduce((p, n) &#x3D;&gt; &#123;             return p.then(() &#x3D;&gt; n (...args))        &#125;, first(...args))    &#125;&#125;let hook &#x3D; new AsyncSeriesHook([&#39;name&#39;])&#x2F;&#x2F; hook.tapAsync(&#39;react&#39;, function (name, callback) &#123;&#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;&#x2F;&#x2F;         console.log(&#39;react&#39;, name);&#x2F;&#x2F;         callback()&#x2F;&#x2F;     &#125;, 1000)&#x2F;&#x2F; &#125;)&#x2F;&#x2F;&#x2F;&#x2F; hook.tapAsync(&#39;node&#39;, function (name, callback) &#123;&#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;&#x2F;&#x2F;         console.log(&#39;node&#39;, name);&#x2F;&#x2F;         callback()&#x2F;&#x2F;     &#125;, 1000)&#x2F;&#x2F; &#125;)&#x2F;&#x2F;&#x2F;&#x2F; hook.tapAsync(&#39;webpack&#39;, function (name, callback) &#123;&#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;&#x2F;&#x2F;         console.log(&#39;webpack&#39;, name);&#x2F;&#x2F;         callback()&#x2F;&#x2F;     &#125;, 1000)&#x2F;&#x2F; &#125;)hook.tapPromise(&#39;react&#39;, function (name, callback) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;            console.log(&#39;react&#39;, name);            resolve()        &#125;, 1000)    &#125;)&#125;)hook.tapPromise(&#39;node&#39;, function (name, callback) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;            console.log(&#39;node&#39;, name);            resolve()        &#125;, 1000)    &#125;)&#125;)&#x2F;&#x2F; hook.callAsync(&#39;jw&#39;, function () &#123;&#x2F;&#x2F;     console.log(&#39;end&#39;);&#x2F;&#x2F; &#125;)hook.promise(&#39;jw&#39;).then(function () &#123;    console.log(&#39;end&#39;);&#125;)\n\n异步串行 —— AsyncSeriesWaterfallHook上一个监听函数的中的callback(err, data)的第二个参数,可以作为下一个监听函数的参数\n7.use.js\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465let &#123;AsyncSeriesWaterfallHook&#125; &#x3D; require(&#39;tapable&#39;)   &#x2F;&#x2F; 解构同步勾子class Lesson &#123;    constructor() &#123;        this.index &#x3D; 0        this.hooks &#x3D; &#123;            &#x2F;&#x2F; 订阅勾子            arch: new AsyncSeriesWaterfallHook([&#39;name&#39;]),        &#125;    &#125;    start() &#123;        &#x2F;&#x2F; 发布        this.hooks.arch.callAsync(&#39;may&#39;, function () &#123;            console.log(&#39;end&#39;);        &#125;)        &#x2F;&#x2F; 另一种发布        &#x2F;&#x2F; this.hooks.arch.promise(&#39;may&#39;).then(function () &#123;        &#x2F;&#x2F;         console.log(&#39;end&#39;);        &#x2F;&#x2F;     &#125;        &#x2F;&#x2F; )    &#125;    tap() &#123;   &#x2F;&#x2F;  注册监听函数,订阅        this.hooks.arch.tapAsync(&#39;node&#39;,  (name, callback) &#x3D;&gt; &#123;            setTimeout(() &#x3D;&gt; &#123;                console.log(&#39;node&#39;, name)                &#x2F;&#x2F; callback(null, &#39;result&#39;)                callback(&#39;error&#39;, &#39;result&#39;)   &#x2F;&#x2F; 如果放error, 会跳过直接后面的勾子，直接走到最终的            &#125;, 1000)        &#125;)        this.hooks.arch.tapAsync(&#39;react&#39;,  (name, callback) &#x3D;&gt; &#123;            setTimeout(() &#x3D;&gt; &#123;                console.log(&#39;react&#39;, name)                callback()            &#125;, 1000)        &#125;)        &#x2F;&#x2F; 另一种订阅        &#x2F;&#x2F; this.hooks.arch.tapPromise(&#39;node&#39;, (name) &#x3D;&gt; &#123;        &#x2F;&#x2F;     return new Promise((resolve, reject) &#x3D;&gt; &#123;        &#x2F;&#x2F;         setTimeout(() &#x3D;&gt; &#123;        &#x2F;&#x2F;             console.log(&#39;node&#39;, name)        &#x2F;&#x2F;             resolve()        &#x2F;&#x2F;         &#125;, 1000)        &#x2F;&#x2F;     &#125;)        &#x2F;&#x2F; &#125;)        &#x2F;&#x2F; this.hooks.arch.tapPromise(&#39;react&#39;, (name) &#x3D;&gt; &#123;        &#x2F;&#x2F;     return new Promise((resolve, reject) &#x3D;&gt; &#123;        &#x2F;&#x2F;         setTimeout(() &#x3D;&gt; &#123;        &#x2F;&#x2F;             console.log(&#39;react&#39;, name)        &#x2F;&#x2F;             resolve()        &#x2F;&#x2F;         &#125;, 1000)        &#x2F;&#x2F;     &#125;)        &#x2F;&#x2F; &#125;)    &#125;&#125;let l &#x3D; new Lesson()l.tap();  &#x2F;&#x2F;注册两个函数l.start(); &#x2F;&#x2F; 启动勾子\n\n7.theory.js\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class AsyncSeriesWaterfallHook &#123;  &#x2F;&#x2F;    constructor(args) &#123;  &#x2F;&#x2F; args &#x3D;&gt; [&#39;name&#39;]        this.tasks &#x3D; []    &#125;    tapAsync(name, task) &#123;        this.tasks.push(task)    &#125;    tapPromise(name, task) &#123;        this.tasks.push(task)    &#125;    callAsync(...args) &#123;        let finalCallback &#x3D; args.pop()        let index &#x3D; 0;        let next &#x3D; (err, data) &#x3D;&gt; &#123;            let task &#x3D; this.tasks[index]            if(!task) return finalCallback();            if (index &#x3D;&#x3D;&#x3D; 0) &#123;                &#x2F;&#x2F; 执行的第一个                task(...args, next)            &#125; else &#123;                task(data, next)            &#125;            index ++        &#125;        next();    &#125;    promise(...args) &#123;        &#x2F;&#x2F; 将promise串联起来        let [first, ...other] &#x3D; this.tasks        return other.reduce((p, n) &#x3D;&gt; &#123;             return p.then((data) &#x3D;&gt; n(data))        &#125;, first(...args))    &#125;&#125;let hook &#x3D; new AsyncSeriesWaterfallHook([&#39;name&#39;])&#x2F;&#x2F; hook.tapAsync(&#39;react&#39;, function (name, callback) &#123;&#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;&#x2F;&#x2F;         console.log(&#39;react&#39;, name);&#x2F;&#x2F;         callback(null, &#39;结果1&#39;)&#x2F;&#x2F;     &#125;, 1000)&#x2F;&#x2F; &#125;)&#x2F;&#x2F;&#x2F;&#x2F; hook.tapAsync(&#39;node&#39;, function (name, callback) &#123;&#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;&#x2F;&#x2F;         console.log(&#39;node&#39;, name);&#x2F;&#x2F;         callback(null, &#39;结果2&#39;)&#x2F;&#x2F;     &#125;, 1000)&#x2F;&#x2F; &#125;)&#x2F;&#x2F;&#x2F;&#x2F; hook.tapAsync(&#39;webpack&#39;, function (name, callback) &#123;&#x2F;&#x2F;     setTimeout(() &#x3D;&gt; &#123;&#x2F;&#x2F;         console.log(&#39;webpack&#39;, name);&#x2F;&#x2F;         callback()&#x2F;&#x2F;     &#125;, 1000)&#x2F;&#x2F; &#125;)&#x2F;&#x2F;hook.tapPromise(&#39;react&#39;, function (name, callback) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;            console.log(&#39;react&#39;, name);            resolve(&#39;result&#39;)        &#125;, 1000)    &#125;)&#125;)hook.tapPromise(&#39;node&#39;, function (name, callback) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;            console.log(&#39;node&#39;, name);            resolve()        &#125;, 1000)    &#125;)&#125;)&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; hook.callAsync(&#39;jw&#39;, function () &#123;&#x2F;&#x2F;     console.log(&#39;end&#39;);&#x2F;&#x2F; &#125;)hook.promise(&#39;jw&#39;).then(function () &#123;    console.log(&#39;end&#39;);&#125;)\n\n\n手写webpack对应的may-pack项目\nyarn add webpack webpack-cli -D\nwebpack.config.js\n12345678910let path &#x3D; require(&#39;path&#39;)module.exports &#x3D; &#123;    mode: &#39;development&#39;,    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,    output: &#123;        filename: &#39;bundle.js&#39;,        path: path.resolve(__dirname, &#39;dist&#39;)    &#125;&#125;\n\nnpx webpack\n生成文件bundle.js\n12345678910111213141516171819202122232425262728293031323334353637383940(function (modules) &#123;    var installedModules &#x3D; &#123;&#125;;    function __webpack_require__(moduleId) &#123;        if (installedModules[moduleId]) &#123;            return installedModules[moduleId].exports;        &#125;        var module &#x3D; installedModules[moduleId] &#x3D; &#123;            i: moduleId,            l: false,            exports: &#123;&#125;        &#125;;        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);        module.l &#x3D; true;        return module.exports;    &#125;    &#x2F;&#x2F; Load entry module and return exports    return __webpack_require__(__webpack_require__.s &#x3D; &quot;.&#x2F;src&#x2F;index.js&quot;);&#125;)(&#123;    &quot;.&#x2F;src&#x2F;a.js&quot;:        (function (module, exports, __webpack_require__) &#123;            eval(&quot;let b &#x3D; __webpack_require__(&#x2F;*! .&#x2F;base&#x2F;b *&#x2F; \\&quot;.&#x2F;src&#x2F;base&#x2F;b.js\\&quot;)\\n\\nmodule.exports &#x3D; &#39;a&#39;+ b\\n\\n\\n\\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;&#x2F;.&#x2F;src&#x2F;a.js?&quot;);        &#125;),    &quot;.&#x2F;src&#x2F;base&#x2F;b.js&quot;:        (function (module, exports) &#123;            eval(&quot;module.exports &#x3D; &#39;b&#39;\\n\\n\\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;&#x2F;.&#x2F;src&#x2F;base&#x2F;b.js?&quot;);        &#125;),    &quot;.&#x2F;src&#x2F;index.js&quot;:        (function (module, exports, __webpack_require__) &#123;            eval(&quot; let str &#x3D; __webpack_require__(&#x2F;*! .&#x2F;a.js *&#x2F; \\&quot;.&#x2F;src&#x2F;a.js\\&quot;)\\n\\n console.log(str);\\n\\n\\n&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;&#x2F;.&#x2F;src&#x2F;index.js?&quot;);        &#125;)&#125;);\n\n新建项目用于自己的webpack,这里叫may-pack\nyarn init\n如果在node里想执行命令，创建bin文件,再创建may-pack.js\n配置package.json\n123456789&#123;  &quot;name&quot;: &quot;may-pack&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;license&quot;: &quot;MIT&quot;,  &quot;bin&quot;: &#123;    &quot;may-pack&quot;: &quot;.&#x2F;bin&#x2F;may-pack.js&quot;  &#125;&#125;\n\nmay-pack.js\n12345#!  &#x2F;usr&#x2F;bin&#x2F;env node &#x2F;&#x2F; node环境console.log(&#39;start&#39;);\n运行npm link将npm 模块链接到对应的运行项目中去，方便地对模块进行调试和测试\n在想运行may-pack的项目中运行，npm link may-pack 得到 start\nwebpack分析及处理may-pack.js\n123456789101112131415161718#!  &#x2F;usr&#x2F;bin&#x2F;env node&#x2F;&#x2F; node环境console.log(&#39;start&#39;);let path &#x3D; require(&#39;path&#39;)&#x2F;&#x2F; 拿到配置文件webpack.config.jslet config &#x3D; require(path.resolve(&#39;webpack.config.js&#39;));let Compiler &#x3D; require(&#39;..&#x2F;lib&#x2F;Compiler.js&#39;);let compiler &#x3D; new Compiler(config);&#x2F;&#x2F; 标识运行编译compiler.run()\n\n创建lib文件Compiler.js\n1234567891011121314151617181920212223242526272829303132333435let path &#x3D; require(&#39;path&#39;)let fs &#x3D; require(&#39;fs&#39;)class Compiler &#123;    constructor(config) &#123;        &#x2F;&#x2F; entry  output        this.config &#x3D; config        &#x2F;&#x2F; 需要保存入口文件的路径        this.entryId &#x3D; &#39;&#39;;   &#x2F;&#x2F; &#39;.&#x2F;src&#x2F;index.js&#39;        &#x2F;&#x2F; 需要保存所有的模块依赖        this.modules &#x3D; &#123;&#125;;        this.entry &#x3D; config.entry  &#x2F;&#x2F; 入口文件        &#x2F;&#x2F; 工作目录        this.root &#x3D; process.cwd(); &#x2F;&#x2F; 当前运行npx的路径    &#125;        &#x2F;&#x2F; 构建模块    buildModule(modulePath, isEntry) &#123;           &#125;    &#x2F;&#x2F; 发射文件    emitFile() &#123;        &#x2F;&#x2F; 用数据 渲染想要的    &#125;    run() &#123;        &#x2F;&#x2F; 执行 创建模块的依赖关系        this.buildModule(path.resolve(this.root, this.entry), true)  &#x2F;&#x2F; path.resolve(this.root, this.entry) 得到入口文件的绝对路径        &#x2F;&#x2F; 发射打包后的文件        this.emitFile()    &#125;&#125;module.exports &#x3D; Compiler\n主要两个任务\n拿到入口Id\n解析模块，也就是实现buildModule方法\n创建依赖关系may-pack中Compiler.js\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566let path &#x3D; require(&#39;path&#39;)let fs &#x3D; require(&#39;fs&#39;)&#x2F;&#x2F; babylon  主要把源码转成ast Babylon 是 Babel 中使用的 JavaScript 解析器。&#x2F;&#x2F; @babel&#x2F;traverse 对ast解析遍历语法树 负责替换，删除和添加节点&#x2F;&#x2F; @babel&#x2F;types 用于AST节点的Lodash-esque实用程序库&#x2F;&#x2F; @babel&#x2F;generator 结果生成let babylon &#x3D; require(&#39;babylon&#39;)let traverse &#x3D; require(&#39;@babel&#x2F;traverse&#39;).default;let type &#x3D; require(&#39;@babel&#x2F;types&#39;);let generator &#x3D; require(&#39;@babel&#x2F;generator&#39;).defaultclass Compiler &#123;    constructor(config) &#123;        &#x2F;&#x2F; entry  output        this.config &#x3D; config        &#x2F;&#x2F; 需要保存入口文件的路径        this.entryId &#x3D; &#39;&#39;;   &#x2F;&#x2F; &#39;.&#x2F;src&#x2F;index.js&#39;        &#x2F;&#x2F; 需要保存所有的模块依赖        this.modules &#x3D; &#123;&#125;;        this.entry &#x3D; config.entry  &#x2F;&#x2F; 入口文件        &#x2F;&#x2F; 工作目录        this.root &#x3D; process.cwd(); &#x2F;&#x2F; 当前运行npx的路径    &#125;    &#x2F;&#x2F; 拿到模块内容    getSource (modulePath) &#123;        let content &#x3D; fs.readFileSync(modulePath, &#39;utf8&#39;)        return content    &#125;    parse (source, parentPath) &#123;        console.log(source, parentPath)    &#125;    &#x2F;&#x2F; 构建模块    buildModule(modulePath, isEntry) &#123;        &#x2F;&#x2F; 拿到模块内容        let source &#x3D; this.getSource(modulePath)  &#x2F;&#x2F; 得到入口文件的内容        &#x2F;&#x2F; 模块id modulePath(需要相对路径) &#x3D; modulePath(模块路径) - this.root(项目工作路径)   src&#x2F;index.js        let moduleName &#x3D; &#39;.&#x2F;&#39; + path.relative(this.root, modulePath)        console.log(source, moduleName);  &#x2F;&#x2F; 拿到代码 和相对路径 .&#x2F;src&#x2F;index.js        if (isEntry) &#123;            this.entryId &#x3D; moduleName        &#125;        let &#123;sourceCode, dependencies&#125; &#x3D; this.parse(source, path.dirname(moduleName))   &#x2F;&#x2F; .&#x2F;src        &#x2F;&#x2F; 把相对路径和模块中的内容对应起来        this.modules[moduleName] &#x3D; sourceCode    &#125;    &#x2F;&#x2F; 发射文件    emitFile() &#123;        &#x2F;&#x2F; 用数据 渲染想要的    &#125;    run() &#123;        &#x2F;&#x2F; 执行 创建模块的依赖关系        this.buildModule(path.resolve(this.root, this.entry), true)  &#x2F;&#x2F; path.resolve(this.root, this.entry) 得到入口文件的绝对路径        console.log(this.modules, this.entryId);        &#x2F;&#x2F; 发射打包后的文件        this.emitFile()    &#125;&#125;module.exports &#x3D; Compiler\n\nast递归解析parse方法主要靠解析语法树来进行转义babylon  主要把源码转成ast Babylon 是 Babel 中使用的 JavaScript 解析器。@babel/traverse 对ast解析遍历语法树 负责替换，删除和添加节点@babel/types 用于AST节点的Lodash-esque实用程序库@babel/generator 结果生成\nyarn add babylon @babel/traverse @babel/types @babel/generator\nmay-pack中Compiler.js\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788let path &#x3D; require(&#39;path&#39;)let fs &#x3D; require(&#39;fs&#39;)&#x2F;&#x2F; babylon  主要把源码转成ast Babylon 是 Babel 中使用的 JavaScript 解析器。&#x2F;&#x2F; @babel&#x2F;traverse 对ast解析遍历语法树 负责替换，删除和添加节点&#x2F;&#x2F; @babel&#x2F;types 用于AST节点的Lodash-esque实用程序库&#x2F;&#x2F; @babel&#x2F;generator 结果生成let babylon &#x3D; require(&#39;babylon&#39;)let traverse &#x3D; require(&#39;@babel&#x2F;traverse&#39;).default;let type &#x3D; require(&#39;@babel&#x2F;types&#39;);let generator &#x3D; require(&#39;@babel&#x2F;generator&#39;).defaultclass Compiler &#123;    constructor(config) &#123;        &#x2F;&#x2F; entry  output        this.config &#x3D; config        &#x2F;&#x2F; 需要保存入口文件的路径        this.entryId &#x3D; &#39;&#39;;   &#x2F;&#x2F; &#39;.&#x2F;src&#x2F;index.js&#39;        &#x2F;&#x2F; 需要保存所有的模块依赖        this.modules &#x3D; &#123;&#125;;        this.entry &#x3D; config.entry  &#x2F;&#x2F; 入口文件        &#x2F;&#x2F; 工作目录        this.root &#x3D; process.cwd(); &#x2F;&#x2F; 当前运行npx的路径    &#125;    &#x2F;&#x2F; 拿到模块内容    getSource (modulePath) &#123;        let content &#x3D; fs.readFileSync(modulePath, &#39;utf8&#39;)        return content    &#125;    parse (source, parentPath) &#123;        &#x2F;&#x2F; AST解析语法树        let ast &#x3D; babylon.parse(source)        let dependencies &#x3D; []; &#x2F;&#x2F; 依赖的数组        &#x2F;&#x2F; https:&#x2F;&#x2F;astexplorer.net&#x2F;        traverse(ast, &#123;            &#x2F;&#x2F; 调用表达式            CallExpression(p) &#123;                let node &#x3D; p.node; &#x2F;&#x2F;对应的节点                if(node.callee.name &#x3D;&#x3D;&#x3D; &#39;require&#39;) &#123;                   node.callee.name &#x3D; &#39;__webpack_require__&#39;                    let moduledName &#x3D; node.arguments[0].value   &#x2F;&#x2F; 取到模块的引用名字                    moduledName &#x3D; moduledName + (path.extname(moduledName) ? &#39;&#39;: &#39;.js&#39;);  &#x2F;&#x2F; .&#x2F;a.js                    moduledName &#x3D; &#39;.&#x2F;&#39; + path.join(parentPath, moduledName)  &#x2F;&#x2F; &#39;.&#x2F;src&#x2F;a.js&#39;                    dependencies.push(moduledName)                    node.arguments &#x3D; [type.stringLiteral(moduledName)] &#x2F;&#x2F; 改掉源码                &#125;            &#125;        &#125;)        let sourceCode &#x3D; generator(ast).code        return &#123; sourceCode, dependencies &#125;    &#125;    &#x2F;&#x2F; 构建模块    buildModule(modulePath, isEntry) &#123;        &#x2F;&#x2F; 拿到模块内容        let source &#x3D; this.getSource(modulePath)  &#x2F;&#x2F; 得到入口文件的内容        &#x2F;&#x2F; 模块id modulePath(需要相对路径) &#x3D; modulePath(模块路径) - this.root(项目工作路径)   src&#x2F;index.js        let moduleName &#x3D; &#39;.&#x2F;&#39; + path.relative(this.root, modulePath)        &#x2F;&#x2F; console.log(source, moduleName);  &#x2F;&#x2F; 拿到代码 和相对路径 .&#x2F;src&#x2F;index.js        if (isEntry) &#123;            this.entryId &#x3D; moduleName        &#125;        &#x2F;&#x2F; 解析把source源码进行改造， 返回一个依赖列表        let &#123;sourceCode, dependencies&#125; &#x3D; this.parse(source, path.dirname(moduleName))   &#x2F;&#x2F; .&#x2F;src        &#x2F;&#x2F; 把相对路径和模块中的内容对应起来        this.modules[moduleName] &#x3D; sourceCode        dependencies.forEach(dep &#x3D;&gt; &#123;  &#x2F;&#x2F; 附模块的加载 递归加载            this.buildModule(path.join(this.root, dep), false)        &#125;)    &#125;    &#x2F;&#x2F; 发射文件    emitFile() &#123;        &#x2F;&#x2F; 用数据 渲染想要的    &#125;    run() &#123;        &#x2F;&#x2F; 执行 创建模块的依赖关系        this.buildModule(path.resolve(this.root, this.entry), true)  &#x2F;&#x2F; path.resolve(this.root, this.entry) 得到入口文件的绝对路径        console.log(this.modules, this.entryId);        &#x2F;&#x2F; 发射打包后的文件        this.emitFile()    &#125;&#125;module.exports &#x3D; Compiler\n\n生成打包工具使用ejs模板\nmay-pack中main.ejs\n1234567891011121314151617181920212223242526272829303132(function (modules) &#123;var installedModules &#x3D; &#123;&#125;;function __webpack_require__(moduleId) &#123;if (installedModules[moduleId]) &#123;return installedModules[moduleId].exports;&#125;var module &#x3D; installedModules[moduleId] &#x3D; &#123;i: moduleId,l: false,exports: &#123;&#125;&#125;;modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);module.l &#x3D; true;return module.exports;&#125;&#x2F;&#x2F; Load entry module and return exportsreturn __webpack_require__(__webpack_require__.s &#x3D; &quot;&lt;%-entryId %&gt;&quot;);&#125;)(&#123;&lt;% for(let key in modules)&#123; %&gt;    &quot;&lt;%- key %&gt;&quot;:    (function (module, exports,__webpack_require__) &#123;eval(&#96;&lt;%-modules[key] %&gt;&#96;);&#125;),&lt;% &#125; %&gt;&#125;);\n\nejs入门\nyarn add ejs\nmay-pack中Compiler.js\n1let ejs &#x3D; require(&#39;ejs&#39;)\n\n123456789101112&#x2F;&#x2F; 发射文件    emitFile() &#123;        &#x2F;&#x2F; 用数据 渲染想要的        &#x2F;&#x2F; 输出到那个目录下        let main &#x3D; path.join(this.config.output.path, this.config.output.filename)        let templateStr &#x3D; this.getSource(path.join(__dirname, &#39;main.ejs&#39;))        let code &#x3D; ejs.render(templateStr, &#123; entryId: this.entryId, modules: this.modules&#125;)        this.assets &#x3D; &#123;&#125;        &#x2F;&#x2F; 路径对应的代码        this.assets[main] &#x3D; code        fs.writeFileSync(main, this.assets[main])    &#125;\n\n在webpack-training项目中运行npx may-pack, 得到bundle.js,运行得到结果\n增加loader创建loader文件夹，创建less-loader1.js和style-loader1.js\nyarn add less\nless使用\nless-loader1.js\n12345678910111213&#x2F;&#x2F; 将less转为csslet less &#x3D; require(&#39;less&#39;)function loader(source) &#123;    let css &#x3D; &#39;&#39;    less.render(source, function (err, output) &#123;        css &#x3D; output.css    &#125;)    css &#x3D; css.replace(&#x2F;\\n&#x2F;g, &#39;\\\\n&#39;);    return css&#125;module.exports &#x3D; loader\n\nstyle-loader1.js\n1234567891011121314&#x2F;&#x2F; 将css插入到html头部function loader(source) &#123;    console.log(111);    let style &#x3D; &#96;    let style &#x3D; document.createElement(&#39;style&#39;)    style.innerHTML &#x3D; $&#123;JSON.stringify(source)&#125;    document.head.appendChild(style)   &#96;    return style&#125;module.exports &#x3D; loader&#x2F;&#x2F; JSON.stringify(source) 可以将代码转为一行\n\nwebpack.config.js\n123456789101112131415161718192021let path &#x3D; require(&#39;path&#39;)module.exports &#x3D; &#123;    mode: &#39;development&#39;,    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,    output: &#123;        filename: &#39;bundle.js&#39;,        path: path.resolve(__dirname, &#39;dist&#39;)    &#125;,    module: &#123;        rules: [            &#123;                test: &#x2F;\\.less$&#x2F;,                use: [                    path.resolve(__dirname, &#39;loader&#39;, &#39;style-loader1&#39;),                    path.resolve(__dirname, &#39;loader&#39;, &#39;less-loader1&#39;)                ]            &#125;        ]    &#125;&#125;\n\n创建index.less\n123body &#123;  background: red&#125;\n\nindex.js\n12345let str &#x3D; require(&#39;.&#x2F;a.js&#39;)require(&#39;.&#x2F;index.less&#39;)console.log(str);\n\nmay-pack中Compiler.js\n12345678910111213141516171819202122232425262728&#x2F;&#x2F; 拿到模块内容    getSource (modulePath) &#123;        &#x2F;&#x2F; 匹配各种文件的规则        let rules&#x3D; this.config.module.rules;   &#x2F;&#x2F; webpack.config.js 中rules的数组        let content &#x3D; fs.readFileSync(modulePath, &#39;utf8&#39;)        for (let i &#x3D; 0; i &lt; rules.length; i++) &#123;            let rule &#x3D; rules[i]            let &#123;test, use&#125; &#x3D; rule            let len &#x3D; use.length - 1            if (test.test(modulePath)) &#123;                &#x2F;&#x2F; console.log(use[len]);                function normalLoader () &#123;                    &#x2F;&#x2F; console.log(use[len--]);                    let loader &#x3D; require(use[len--])                    content &#x3D; loader(content)                    &#x2F;&#x2F; 递归调用loader 实现转化                    if (len &gt;&#x3D; 0) &#123;                        normalLoader()                    &#125;                &#125;                normalLoader()            &#125;        &#125;        return content    &#125;\n\n运行npx may-pack\n增加pluginsyarn add tapable\nmay-pack中Compiler.js\n1234567891011121314151617181920212223242526272829constructor(config) &#123;        &#x2F;&#x2F; entry  output        this.config &#x3D; config        &#x2F;&#x2F; 需要保存入口文件的路径        this.entryId &#x3D; &#39;&#39;;   &#x2F;&#x2F; &#39;.&#x2F;src&#x2F;index.js&#39;        &#x2F;&#x2F; 需要保存所有的模块依赖        this.modules &#x3D; &#123;&#125;;        this.entry &#x3D; config.entry  &#x2F;&#x2F; 入口文件        &#x2F;&#x2F; 工作目录        this.root &#x3D; process.cwd(); &#x2F;&#x2F; 当前运行npx的路径        this.hooks &#x3D; &#123;            entryOption: new SyncHook(),  &#x2F;&#x2F; 入口选项            compile: new SyncHook(),      &#x2F;&#x2F; 编译            afterCompile: new SyncHook(),  &#x2F;&#x2F; 编译完成            afterPlugins: new SyncHook(),   &#x2F;&#x2F; 编译完插件            run: new SyncHook(),         &#x2F;&#x2F; 运行            emit: new SyncHook(),        &#x2F;&#x2F; 发射            done: new SyncHook()         &#x2F;&#x2F; 完成        &#125;        &#x2F;&#x2F; 如果传递了plugins参数        let plugins &#x3D; this.config.plugins        if (Array.isArray(plugins)) &#123;            plugins.forEach(plugin &#x3D;&gt; &#123;                plugin.apply(this); &#x2F;&#x2F; 这里只是appLy方法不是改变this指向            &#125;)        &#125;        this.hooks.afterPlugins.call()    &#125;\n\n在webpack.config.js中写插件方法\n12345678910111213141516171819202122232425262728293031323334353637383940414243class P &#123;    apply(compiler) &#123;   &#x2F;&#x2F; 这里只是appLy方法不是改变this指向        &#x2F;&#x2F; 绑定        compiler.hooks.emit.tap(&#39;emit&#39;, function () &#123;            console.log(&#39;emit&#39;);        &#125;)    &#125;&#125;class P1 &#123;    apply(compiler) &#123;   &#x2F;&#x2F; 这里只是appLy方法不是改变this指向        &#x2F;&#x2F; 绑定        compiler.hooks.afterPlugins.tap(&#39;emit&#39;, function () &#123;            console.log(&#39;afterPlugins&#39;);        &#125;)    &#125;&#125;module.exports &#x3D; &#123;    mode: &#39;development&#39;,    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,    output: &#123;        filename: &#39;bundle.js&#39;,        path: path.resolve(__dirname, &#39;dist&#39;)    &#125;,    module: &#123;        rules: [            &#123;                test: &#x2F;\\.less$&#x2F;,                use: [                    path.resolve(__dirname, &#39;loader&#39;, &#39;style-loader&#39;),                    path.resolve(__dirname, &#39;loader&#39;, &#39;less-loader&#39;)                ]            &#125;        ]    &#125;,    plugins: [        new P(),        new P1()    ]&#125;\n\n然后在各个地方调用\nmay-pack中may-pack.js\n12345.....&#x2F;&#x2F; 调用compiler.hooks.entryOption.call()&#x2F;&#x2F; 标识运行编译compiler.run()\n\nmay-pack中Compiler.js\n12345678910111213run() &#123;        this.hooks.run.call()        this.hooks.compile.call()        &#x2F;&#x2F; 执行 创建模块的依赖关系        this.buildModule(path.resolve(this.root, this.entry), true)  &#x2F;&#x2F; path.resolve(this.root, this.entry) 得到入口文件的绝对路径        &#x2F;&#x2F; console.log(this.modules, this.entryId);        this.hooks.afterCompile.call()        &#x2F;&#x2F; 发射打包后的文件        this.emitFile()        this.hooks.emit.call()        this.hooks.done.call()    &#125;\n\n运行npx may-pack\nloader手写loader\nwebapck.config.js\n123456789101112131415161718let path &#x3D; require(&#39;path&#39;)module.exports &#x3D; &#123;    mode: &#39;development&#39;,    entry: &#39;.&#x2F;src&#x2F;index&#39;,    output: &#123;        filename: &#39;build.js&#39;,        path: path.resolve(__dirname, &#39;dist&#39;)    &#125;,    module: &#123;        rules: [            &#123;                test: &#x2F;\\.js&#x2F;,                use: &#39;loader1&#39; &#x2F;&#x2F; 如何找到这个loader1            &#125;        ]    &#125;,&#125;\n\n创建loader文件loader1.js\n123456console.log(22);function loader(source) &#123;  &#x2F;&#x2F; loader的参数就是源代码    return source&#125;module.exports &#x3D; loader\n\n\nwebpack.config.js\n12345678910111213141516171819202122232425262728293031323334let path &#x3D; require(&#39;path&#39;)module.exports &#x3D; &#123;    mode: &#39;development&#39;,    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,    output: &#123;        filename: &#39;build.js&#39;,        path: path.resolve(__dirname, &#39;dist&#39;)    &#125;,    resolveLoader: &#123;      &#x2F;&#x2F; 别名      &#x2F;&#x2F; alias: &#123;      &#x2F;&#x2F;     loader1: path.resolve(__dirname, &#39;loader&#39;, &#39;loader1&#39;)      &#x2F;&#x2F; &#125;        modules: [&#39;node_modules&#39;, path.resolve(__dirname, &#39;loader&#39;)]  &#x2F;&#x2F; 先找node_modules, 再去loader中去找    &#125;,    module: &#123;        rules: [            &#123;                test: &#x2F;\\.js$&#x2F;,                &#x2F;&#x2F; use: [path.resolve(__dirname, &#39;loader&#39;, &#39;loader1&#39;)]                use: &#39;loader1&#39; &#x2F;&#x2F; 如何找到这个loader1            &#125;,            &#x2F;&#x2F; &#123;            &#x2F;&#x2F;     test: &#x2F;\\.less$&#x2F;,            &#x2F;&#x2F;     use: [            &#x2F;&#x2F;         path.resolve(__dirname, &#39;loader&#39;, &#39;style-loader&#39;),            &#x2F;&#x2F;         path.resolve(__dirname, &#39;loader&#39;, &#39;less-loader&#39;)            &#x2F;&#x2F;     ]            &#x2F;&#x2F; &#125;        ]    &#125;,&#125;\n如何找到这个loader1\n通过配别名alias\n通过modules\nnpx webpack\n配置多个loader数组方式\n先分别在loader文件下创建，loader2.js和loader3.js\n123456function loader(source) &#123;  &#x2F;&#x2F; loader的参数就是源代码    console.log(&#39;loader2&#39;);  &#x2F;&#x2F; loader3.js 类似    return source&#125;module.exports &#x3D; loader\n\nwebpack.config.js\n123456rules: [    &#123;        test: &#x2F;\\.js$&#x2F;,        use: [&#39;loader3&#39;, &#39;loader2&#39;, &#39;loader1&#39;]    &#125;,]\n\n运行npx webpack,分别打出\n123loader1loader2loader3\n\n对象方式\n1234567891011121314rules: [    &#123;        test: &#x2F;\\.js$&#x2F;,        use: [&#39;loader3&#39;]    &#125;,    &#123;        test: &#x2F;\\.js$&#x2F;,        use: [&#39;loader2&#39;]    &#125;,    &#123;        test: &#x2F;\\.js$&#x2F;,        use: [&#39;loader1&#39;]    &#125;]\n\n运行npx webpack,分别打出\n123loader1loader2loader3\n\n\n\nloader的顺序: 从右到左, 从下到上\n\n也可以通过配置不同的参数改变loader的执行顺序，pre 前面的， post在后面的， normal正常\n1234567891011121314&#123;    test: &#x2F;\\.js$&#x2F;,    use: [&#39;loader1&#39;],    enforce: &quot;pre&quot;&#125;,&#123;    test: &#x2F;\\.js$&#x2F;,    use: [&#39;loader2&#39;]&#125;,&#123;    test: &#x2F;\\.js$&#x2F;,    use: [&#39;loader3&#39;],    enforce: &quot;post&quot;&#125;,\n\nloader 带参数执行的顺序: pre  -&gt; normal -&gt; inline -&gt; post\ninline为行内loader\n在loader文件中新建inlin-loader\n123456function loader(source) &#123;  &#x2F;&#x2F; loader的参数就是源代码    console.log(&#39;inline&#39;);    return source&#125;module.exports &#x3D; loader\n\nsrc/a.js\n1module.exports &#x3D; &#39;may&#39;\n\nsrc/index\n12console.log(&#39;hello&#39;)let srt &#x3D; require(&#39;-!inline-loader!.&#x2F;a&#39;)\n\n-!禁用pre-loader和 normal-loader来处理了\n12345loader1loader2loader3inlineloader3\n\n\n\n!禁用normal-loader\n123456loader1loader2loader3loader1inlineloader3\n\n\n\n!! 禁用pre-loader、normal-loader、post-loader,只能行内处理\n1234loader1loader2loader3inline\n\nloader 默认由两部分组成pitch和normal\nuser: [loader3, loader2, loader1]\n无返回值: 先执行pitch方法,从左到右，再获取资源\n12345678    pitch loader - 无返回值    pitch   loader3 → loader2 → loader1                                      ↘                                      资源                                    ↙normal   loader3 ← loader2 ← loader1\n\n有返回值: 直接跳过后续所有的loader包括自己的,跳到之前的loader, 可用于阻断\nloader\n123456789user: [loader3, loader2, loader1]    pitch loader - 有返回值    pitch   loader3 → loader2  loader1                       ↙                              有返回值               资源               ↙                      normal  loader3  loader2  loader1\n\nloadeer2.js\n12345678910function loader(source) &#123;  &#x2F;&#x2F; loader的参数就是源代码    console.log(&#39;loader2&#39;);    return source&#125;loader.pitch &#x3D; function () &#123;    return &#39;111&#39;&#125;module.exports &#x3D; loader\n\n结果\n1loader3\n\nbabel-loader实现yarn add @babel/core @babel/preset-env\nwebpack.config.js\n1234567891011&#123;    test: &#39;\\.js$&#x2F;&#39;,    use: &#123;        loader: &#39;babel-loader2&#39;,        options: &#123;            presets: [                &#39;@babel&#x2F;preset-env&#39;            ]        &#125;    &#125;&#125;\n\n在loader文件创建babel-loader2.js(如果你已经装过babel-loader)\n拿到babel的参数\nyarn add loader-utils\n1234567891011121314151617181920212223&#x2F;&#x2F; 需要在webpack.config.js拿到babel的预设, 通过预设转换模块, 先引入babellet babel &#x3D; require(&#39;@babel&#x2F;core&#39;)&#x2F;&#x2F; 拿到babel的参数 需要工具 loaderUtilslet loaderUtils &#x3D;require(&#39;loader-utils&#39;)function loader(source) &#123;  &#x2F;&#x2F; loader的参数就是源代码  这里的this就是loader的上下文    let options &#x3D; loaderUtils.getOptions(this)    console.log(this.resourcePath, 444);   &#x2F;&#x2F; [.&#x2F;src&#x2F;index.js]    let callback &#x3D; this.async(); &#x2F;&#x2F; babel的转换是异步的,同步的返回是不行的， 不能用return  同步就是直接掉用 异步会在async中    babel.transform(source, &#123;        ...options,        sourceMap: true,         &#x2F;&#x2F; 是否设置sourceMap 还需要再webpack.config.js 中配置  devtool: &#39;source-map&#39;        filename: this.resourcePath.split(&#39;&#x2F;&#39;).pop()   &#x2F;&#x2F;  给生成的&#96;source-map&#96;指定名字    &#125;, function (err, result) &#123;        callback(err, result.code, result.map)   &#x2F;&#x2F; 异步 参数分别是「错误 转化后的代码 和 sourceMap」    &#125;)    console.log(options);    &#x2F;&#x2F; return source  失效&#125;module.exports &#x3D; loader\n\n\nindex.js\n12345678910111213class May &#123;    constructor () &#123;        this.name &#x3D; &#39;may&#39;    &#125;    getName () &#123;        return this.name    &#125;&#125;let may &#x3D; new May()console.log(may.getName());\n\nnpx webpack\nbanner-loader实现(自创)给所有匹配的js加一个注释\nwebpack.config.js\n12345678910&#123;    &#x2F;&#x2F; 给所有匹配的&#96;js&#96;加一个注释    test: &#x2F;\\.js$&#x2F;,    use: &#123;        loader: &#39;banner-loader&#39;,        options: &#123;           text: &#39;may&#39;,           filename: path.resolve(__dirname, &#39;banner.js&#39;)        &#125;    &#125;&#125;\n\nbanner.js\n1二次星球中毒\n\n\n在loader文件创建banner-loader.js\nyarn add schema-utils 校验自己写的loader格式是否正确\nschema-utils\nbanner-loader.js\n1234567891011121314151617181920212223242526272829303132333435&#x2F;&#x2F; 拿到loader的配置let loaderUtils &#x3D; require(&#39;loader-utils&#39;)&#x2F;&#x2F; 校验loaderlet validateOptions &#x3D; require(&#39;schema-utils&#39;)&#x2F;&#x2F; 读取文件let fs &#x3D; require(&#39;fs&#39;)  &#x2F;&#x2F; 异步function loader(source) &#123;  &#x2F;&#x2F; loader的参数就是源代码    let options &#x3D; loaderUtils.getOptions(this)    let callback &#x3D; this.async()  &#x2F;&#x2F; 读取文件是异步    let schema &#x3D; &#123;        type: &#39;object&#39;,        properties: &#123;            text: &#123;                type: &#39;string&#39;            &#125;,            filename: &#123;                type: &#39;string&#39;            &#125;        &#125;    &#125;    validateOptions(schema, options, &#39;banner-loader&#39;)  &#x2F;&#x2F; 自己的校验格式， 自己的写的配置， 对应的loader名字    if (options.filename) &#123;        this.cacheable(false)  &#x2F;&#x2F; 不要缓存  如果有大量计算 推荐缓存        &#x2F;&#x2F; this.cacheable &amp;&amp; this.cacheable()        this.addDependency(options.filename) &#x2F;&#x2F; 自动增加依赖        fs.readFile(options.filename, &#39;utf8&#39;, function (err, data) &#123;            callback(err, &#96;&#x2F;**$&#123;data&#125;**&#x2F;$&#123;source&#125;&#96;)        &#125;)    &#125; else &#123;        callback(null, &#96;&#x2F;**$&#123;options.text&#125;**&#x2F;$&#123;source&#125;&#96;)    &#125;    return source&#125;module.exports &#x3D; loader\n\n优化:\n修改banner.js的内容后, webpack进行监控，打包webapck.config.js配置watch: true\nloader缓存\n实现file-loader和url-loaderyarn add mime\n其主要用途是设置某种扩展名的文件的响应程序类型\nmime\n创建file-loader.js1\n123456789101112&#x2F;&#x2F; 拿到babel的参数 需要工具 loaderUtilslet loaderUtils &#x3D; require(&#39;loader-utils&#39;)function loader(source) &#123;  &#x2F;&#x2F; loader的参数就是源代码    &#x2F;&#x2F; file-loader需要返回路径    let filename &#x3D; loaderUtils.interpolateName(this, &#39;[hash].[ext]&#39;, &#123;content: source &#125;)    this.emitFile(filename, source) &#x2F;&#x2F; 发射文件    console.log(&#39;loader1&#39;);    return &#96;module.exports&#x3D;&quot;$&#123;filename&#125;&quot;&#96;&#125;loader.raw &#x3D; true &#x2F;&#x2F; 二进制module.exports &#x3D; loader\n\n创建url-loader1.js\n123456789101112131415&#x2F;&#x2F; 拿到babel的参数 需要工具 loaderUtilslet loaderUtils &#x3D; require(&#39;loader-utils&#39;)let mime &#x3D; require(&#39;mime&#39;)  &#x2F;&#x2F; 途是设置某种扩展名的文件的响应程序类型function loader(source) &#123;  &#x2F;&#x2F; loader的参数就是源代码    let &#123;limit&#125; &#x3D; loaderUtils.getOptions(this)    console.log(this.resourcePath);    if (limit &amp;&amp; limit &gt; source.length) &#123;        return &#96;module.exports&#x3D;&quot;data:$&#123;mime.getType(this.resourcePath)&#125;;base64,$&#123;source.toString(&#39;base64&#39;)&#125;&quot;&#96;    &#125; else &#123;        return require(&#39;.&#x2F;file-loader1&#39;).call(this, source)    &#125;&#125;loader.raw &#x3D; true &#x2F;&#x2F; 二进制module.exports &#x3D; loader\n\nwebpack.config.js\n123456789101112&#123;    test: &#x2F;\\.png$&#x2F;,    &#x2F;&#x2F; 目的是根据图片生成md5 发射到dist目录下，file-loader 返回当前图片路径    &#x2F;&#x2F; use: &#39;file-loader&#39;    &#x2F;&#x2F; 处理路径    use: &#123;        loader: &#39;url-loader1&#39;,        options: &#123;            limit: 200 * 1024        &#125;    &#125;&#125;\n\nindex.js引入图片\n12345import p from &#39;.&#x2F;photo.png&#39;let img &#x3D; document.createElement(&#39;img&#39;)img.src &#x3D; pdocument.body.appendChild(img);\n\n\nless-loader和css-loader先安装less\n分别创建style-loader2 css-loader2 less-loader2\nstyle-loader1 与 less-loader1 同之前的\ncss-loader主要用来处理css中的图片链接，需要把url转换成require\nwebpack.config.js\n12345678910111213141516&#123;    test: &#x2F;\\.png$&#x2F;,    &#x2F;&#x2F; 目的是根据图片生成md5 发射到dist目录下，file-loader 返回当前图片路径    &#x2F;&#x2F; use: &#39;file-loader&#39;    &#x2F;&#x2F; 处理路径    use: &#123;        loader: &#39;url-loader1&#39;,        options: &#123;            limit: 200 * 1024        &#125;    &#125;&#125;,&#123;    test: &#x2F;\\.less$&#x2F;,    use: [&#39;style-loader2&#39;, &#39;css-loader2&#39;, &#39;less-loader2&#39;]&#125;\n\n创建index.less\n12345@base: #f938ab;body &#123;  background: @base;  background: url(&quot;.&#x2F;photo.png&quot;);&#125;\n\nless-loader2.js\n123456789101112131415&#x2F;&#x2F; 将less转为csslet less &#x3D; require(&#39;less&#39;)function loader(source) &#123;    let css &#x3D; &#39;&#39;    &#x2F;&#x2F; console.log(source, 2222);    less.render(source, function (err, output) &#123;        &#x2F;&#x2F; console.log(output);        css &#x3D; output.css    &#125;)    &#x2F;&#x2F; css &#x3D; css.replace(&#x2F;\\n&#x2F;g, &#39;\\\\n&#39;);    return css&#125;module.exports &#x3D; loader\n\n\ncss-loader2.js\n1234567891011121314151617181920212223242526272829&#x2F;&#x2F; css-loader 用来解析@import这种语法,包括css中引入的图片function loader(source) &#123;    let reg &#x3D; &#x2F;url\\((.+?)\\)&#x2F;g   &#x2F;&#x2F; 匹配括号    let pos &#x3D; 0;    let current;    let arr &#x3D; [&#39;let list &#x3D; []&#39;]    while (current &#x3D; reg.exec(source)) &#123;        let [matchUrl, g] &#x3D; current   &#x2F;&#x2F; matchUrl -&gt; &#39;url(&quot;.&#x2F;photo.png&quot;)&#39;, g  -&gt; &#39;&quot;.&#x2F;photo.png&quot;&#39;        &#x2F;&#x2F; console.log(matchUrl, g, 88);        let lastIndex &#x3D; reg.lastIndex - matchUrl.length    &#x2F;&#x2F; 拿到css从开通到地址链接之前的index        arr.push(&#96;list.push($&#123;JSON.stringify(source.slice(pos, lastIndex))&#125;)&#96;)  &#x2F;&#x2F; 拼入开始和地址之前的代码        pos &#x3D; reg.lastIndex        arr.push(&#96;list.push(&#39;url(&#39;+ require($&#123;g&#125;) +&#39;)&#39;)&#96;)    &#x2F;&#x2F; 拼入图片地址    &#125;    arr.push(&#96;list.push($&#123;JSON.stringify(source.slice(pos))&#125;)&#96;)  &#x2F;&#x2F; 拼入地址到结尾的代码    arr.push(&#96;module.exports &#x3D; list.join(&#39;&#39;)&#96;)    console.log(arr.join(&#39;\\r\\n&#39;));    &#x2F;&#x2F; let list &#x3D; []    &#x2F;&#x2F; list.push(&quot;body &#123;\\\\n  background: #f938ab;\\\\n  background: &quot;)    &#x2F;&#x2F; list.push(&#39;url(&#39;+ require(&quot;.&#x2F;photo.png&quot;) +&#39;)&#39;)    &#x2F;&#x2F; list.push(&quot;;\\\\n&#125;\\\\n&quot;)    &#x2F;&#x2F; module.exports &#x3D; list.join(&#39;&#39;)    return arr.join(&#39;\\r\\n&#39;)&#125;module.exports &#x3D; loader\n\nstyle-loader2.js\n123456789101112131415161718192021222324252627282930let loaderUtils &#x3D; require(&#39;loader-utils&#39;)&#x2F;&#x2F; 将css插入到html头部function loader(source) &#123;    let str &#x3D; &#96;    let style &#x3D; document.createElement(&#39;style&#39;)    style.innerHTML &#x3D; $&#123;JSON.stringify(source)&#125;    document.head.appendChild(style)   &#96;    return str&#125;&#x2F;&#x2F; style-loader写了pitch,有返回后面的跳过，自己的写不会走loader.pitch &#x3D; function (remainingRequest) &#123;  &#x2F;&#x2F; 剩余的请求    console.log(loaderUtils.stringifyRequest(this, &#39;!!&#39; + remainingRequest, 99999999))    &#x2F;&#x2F; 让style-loader 处理 less-loader 和css-loader拼接的结果    &#x2F;&#x2F; 得到 &#x2F;Users&#x2F;liuhuimin&#x2F;work&#x2F;webpack&#x2F;loader&#x2F;css-loader2.js!&#x2F;Users&#x2F;liuhuimin&#x2F;work&#x2F;webpack&#x2F;loader&#x2F;less-loader2.js!&#x2F;Users&#x2F;liuhuimin&#x2F;work&#x2F;webpack&#x2F;src&#x2F;index.less    &#x2F;&#x2F; 剩余的请求 less-loader!css-loader!.&#x2F;index.less    &#x2F;&#x2F; console.log(remainingRequest, 1223);    &#x2F;&#x2F; require返回的就是css-loader处理好的结果require(&#39;!!css-loader!less-loader!.&#x2F;index.less&#39;)    let str &#x3D; &#96;    let style &#x3D; document.createElement(&#39;style&#39;)    style.innerHTML &#x3D; require($&#123;loaderUtils.stringifyRequest(this, &#39;!!&#39; + remainingRequest)&#125;)    document.head.appendChild(style)   &#96;    &#x2F;&#x2F; stringifyRequest 绝对路径转相对路径    return str&#125;module.exports &#x3D; loader\n\n\n123456789user: [&#39;style-loader2&#39;, &#39;css-loader2&#39;, &#39;less-loader2&#39;]    pitch loader - 有返回值    pitch   style-loader2 → css-loader2  less-loader2                       ↙                              有返回值               资源               ↙                      normal  style-loader2  css-loader2  less-loader2\n\n在style-loader2中 引用了less-loader css-loader 和less文件\nwebpack 中的插件yarn add webpack webpack-cil -D\nwebpack.config.js\n12345678910111213141516let path &#x3D; require(&#39;path&#39;)let DonePlugin &#x3D; require(&#39;.&#x2F;plugins&#x2F;DonePlugins&#39;)let AsyncPlugins &#x3D; require(&#39;.&#x2F;plugins&#x2F;AsyncPlugins&#39;)module.exports &#x3D; &#123;    mode: &#39;development&#39;,    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,    output: &#123;        filename: &#39;build.js&#39;,        path: path.resolve(__dirname, &#39;dist&#39;)    &#125;,    plugins: [        new DonePlugin(),    &#x2F;&#x2F; 同步        new AsyncPlugins()   &#x2F;&#x2F; 异步    ]&#125;\n\nnode_modules/webpack/lib中查看Compiler.js\n同步plugins/DonePlugins\n打包完成\n1234567891011class DonePlugins &#123;    apply (compiler) &#123;        console.log(1);        compiler.hooks.done.tap(&#39;DonePlugin&#39;, (stats) &#x3D;&gt; &#123;            console.log(&#39;编译完成&#39;);        &#125;)    &#125;&#125;module.exports &#x3D; DonePlugins\n\n\n异步plugins/AsyncPlugins\n12345678910111213141516171819202122class AsyncPlugins &#123;    apply (compiler) &#123;        console.log(2);        compiler.hooks.emit.tapAsync(&#39;AsyncPlugin&#39;, (complete, callback) &#x3D;&gt; &#123;            setTimeout(() &#x3D;&gt; &#123;                console.log(&#39;文件发射出来&#39;);                callback()            &#125;, 1000)        &#125;)        compiler.hooks.emit.tapPromise(&#39;AsyncPlugin&#39;, (complete, callback) &#x3D;&gt; &#123;            return new Promise((resolve, reject) &#x3D;&gt; &#123;                setTimeout(() &#x3D;&gt; &#123;                    console.log(&#39;文件发射出来 222&#39;);                    resolve()                &#125;, 1000)            &#125;)        &#125;)    &#125;&#125;module.exports &#x3D; AsyncPlugins\n\n文件列表插件希望生成一个文件描述打包出来的文件\n在plugins中新建FileListPlugin\n1234567891011121314151617181920212223242526272829class FileListPlugin &#123;    constructor (&#123;filename&#125;) &#123;        this.filename &#x3D; filename    &#125;    apply (compiler) &#123;        &#x2F;&#x2F; 文件已经准备好了 要进行发射        &#x2F;&#x2F; emit        compiler.hooks.emit.tap(&#39;FileListPlugin&#39;, (compilation) &#x3D;&gt; &#123;            let assets &#x3D; compilation.assets;            console.log(assets, 55);            let content &#x3D; &#96;## 文件名  资源大小\\r\\n&#96;            &#x2F;&#x2F; [ [bundls.js, &#123;&#125;], [index.html, &#123;&#125;]]            Object.entries(assets).forEach(([filename, stateObj]) &#x3D;&gt; &#123;                content +&#x3D; &#96;- $&#123;filename&#125;    $&#123;stateObj.size()&#125;\\r\\n&#96;            &#125;)            &#x2F;&#x2F; 资源对象            assets[this.filename] &#x3D; &#123;                source () &#123;                    return content;                &#125;,                size () &#123;                    return content.length                &#125;            &#125;        &#125;)    &#125;&#125;module.exports &#x3D; FileListPlugin\n\n12345678910111213141516171819202122232425let path &#x3D; require(&#39;path&#39;)let DonePlugin &#x3D; require(&#39;.&#x2F;plugins&#x2F;DonePlugins&#39;)let AsyncPlugins &#x3D; require(&#39;.&#x2F;plugins&#x2F;AsyncPlugins&#39;)let HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)let FileListPlugin &#x3D; require(&#39;.&#x2F;plugins&#x2F;FileListPlugin&#39;)module.exports &#x3D; &#123;    mode: &#39;development&#39;,    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,    output: &#123;        filename: &#39;build.js&#39;,        path: path.resolve(__dirname, &#39;dist&#39;)    &#125;,    plugins: [        new DonePlugin(),        new AsyncPlugins(),        new HtmlWebpackPlugin(&#123;            template: &#39;.&#x2F;src&#x2F;index.html&#39;,            filename: &#39;index.html&#39;        &#125;),        new FileListPlugin(&#123;            filename: &#39;list.md&#39;        &#125;)    ]&#125;\n\n生成list.md\n内联的webpack插件新建index.css引入index.js\nyarn add css-loader mini-css-extract-plugin -D\n希望打包后css、js内联在index.html文件中\n创建plugins中InlineSourcePlugins.js\nyarn add --dev html-webpack-plugin@next\nHTML Webpack Plugin\nwebpack.config.js\n12345678910111213141516171819202122232425262728293031323334353637383940414243let path &#x3D; require(&#39;path&#39;)let DonePlugin &#x3D; require(&#39;.&#x2F;plugins&#x2F;DonePlugins&#39;)let AsyncPlugins &#x3D; require(&#39;.&#x2F;plugins&#x2F;AsyncPlugins&#39;)let HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)let FileListPlugin &#x3D; require(&#39;.&#x2F;plugins&#x2F;FileListPlugin&#39;)let InlineSourcePlugins &#x3D; require(&#39;.&#x2F;plugins&#x2F;InlineSourcePlugins&#39;)let MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;)module.exports &#x3D; &#123;    mode: &#39;production&#39;,    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,    output: &#123;        filename: &#39;bundle.js&#39;,        path: path.resolve(__dirname, &#39;dist&#39;)    &#125;,    module: &#123;        rules: [            &#123;                test: &#x2F;\\.css$&#x2F;,                use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;]            &#125;        ]    &#125;,    plugins: [        &#x2F;&#x2F; new DonePlugin(),        &#x2F;&#x2F; new AsyncPlugins(),        new HtmlWebpackPlugin(&#123;            template: &#39;.&#x2F;src&#x2F;index.html&#39;,            filename: &#39;index.html&#39;        &#125;),        new MiniCssExtractPlugin(&#123;            filename: &#39;index.css&#39;        &#125;),        new InlineSourcePlugins(&#123;            match: &#x2F;\\.(js|css)&#x2F;        &#125;),        &#x2F;&#x2F; new FileListPlugin(&#123;        &#x2F;&#x2F;     filename: &#39;list.md&#39;        &#x2F;&#x2F; &#125;)    ]&#125;\n\nInlineSourcePlugins.js\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)&#x2F;&#x2F; 把外链的标签编程内联的标签class InlineSourcePlugins &#123;    constructor(&#123;match&#125;) &#123;        this.reg &#x3D; match  &#x2F;&#x2F; 正则    &#125;    &#x2F;&#x2F; 处理某一个标签    processTag(tag, compilation) &#123;        let newTag &#x3D; &#123;&#125;        let url &#x3D; &#39;&#39;        if (tag.tagName &#x3D;&#x3D;&#x3D; &#39;link&#39; &amp;&amp; this.reg.test(tag.attributes.href)) &#123;            newTag &#x3D; &#123;                tagName: &#39;style&#39;,                attributes: &#123;type: &#39;text&#x2F;css&#39;&#125;            &#125;            url &#x3D; tag.attributes.href        &#125; else if (tag.tagName &#x3D;&#x3D;&#x3D; &#39;script&#39; &amp;&amp; this.reg.test(tag.attributes.src)) &#123;            newTag &#x3D; &#123;                tagName: &#39;script&#39;,                attributes: &#123;type: &#39;application&#x2F;javascript&#39;&#125;            &#125;            url &#x3D; tag.attributes.src        &#125;        if (url) &#123;            newTag.innerHTML &#x3D; compilation.assets[url].source(); &#x2F;&#x2F; 文件内容放到innerHTML属性中            delete compilation.assets[url]   &#x2F;&#x2F; 删除原有的资源            return newTag            &#x2F;&#x2F; console.log(compilation.assets[url].source());        &#125;        return tag    &#125;    &#x2F;&#x2F; 处理引入标签的数据    processTags(data, compilation) &#123;        let headTags &#x3D; []        let bodyTags &#x3D; []        data.headTags.forEach(headTag &#x3D;&gt; &#123;            headTags.push(this.processTag(headTag, compilation))        &#125;)        data.bodyTags.forEach(bodyTag &#x3D;&gt; &#123;            bodyTags.push(this.processTag(bodyTag, compilation))        &#125;)        console.log(&#123;...data, headTags, bodyTags&#125;)        return &#123;...data, headTags, bodyTags&#125;    &#125;    apply(compiler) &#123;        &#x2F;&#x2F; 通过webpackPlugin来实现  npm搜索  html-webpack-plugin        compiler.hooks.compilation.tap(&#39;InlineSourcePlugins&#39;, (compilation) &#x3D;&gt; &#123;            HtmlWebpackPlugin.getHooks(compilation).alterAssetTagGroups.tapAsync(                &#39;alertPlugin&#39;,                (data, callback) &#x3D;&gt; &#123;                    &#x2F;&#x2F; console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;);                    &#x2F;&#x2F; console.log(data) &#x2F;&#x2F; 插入html标签的数据                    &#x2F;&#x2F; console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;);                    data &#x3D; this.processTags(data, compilation)   &#x2F;&#x2F; compilation.assets 资源的链接                    callback(null, data)                &#125;)        &#125;)    &#125;&#125;module.exports &#x3D; InlineSourcePlugins\n\n\n打包后自动发布打包好的文件自动上传致七牛\n需要这几个参数\n1234bucket: &#39;&#39;  &#x2F;&#x2F; 七牛的存储空间domain: &#39;&#39;,accessKey: &#39;&#39;, &#x2F;&#x2F; 七牛云的两对密匙secretKey: &#39;&#39; &#x2F;&#x2F; 七牛云的两对密匙\n\n注册七牛，并在对象存储里面,新建存储空间列表test,bucket: &#39;test&#39;\n内容管理外链接默认域名 domain: &#39;xxxxxxxx&#39;\n右上角个人面板里面个人中心,密钥管理分别对应accessKey和secretKey\n进入开发者中心 -&gt; SDK&amp;工具 -&gt; 官方SDK -&gt; Node服务端文档 —&gt; 文件上传\nnode文件上传\nnpm install qiniu\ncompiler-hooks\nwebpack.config.js\n123456789101112131415plugins: [        new HtmlWebpackPlugin(&#123;            template: &#39;.&#x2F;src&#x2F;index.html&#39;,            filename: &#39;index.html&#39;        &#125;),        new MiniCssExtractPlugin(&#123;            filename: &#39;index.css&#39;        &#125;),        new UploadPlugin(&#123;            bucket: &#39;test&#39;,  &#x2F;&#x2F; 七牛的存储空间            domain: &#39;poyrjyh1b.bkt.clouddn.com&#39;,            accessKey: &#39;xxxxxx&#39;, &#x2F;&#x2F; 七牛云的两对密匙            secretKey: &#39;yyyyyy&#39; &#x2F;&#x2F; 七牛云的两对密匙        &#125;)    ]\n\nUploadPlugin.js\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let qiniu &#x3D; require(&#39;qiniu&#39;)let path &#x3D; require(&#39;path&#39;)class UploadPlugin &#123;    constructor (options &#x3D; &#123;&#125;) &#123;        &#x2F;&#x2F; 参考 https:&#x2F;&#x2F;developer.qiniu.com&#x2F;kodo&#x2F;sdk&#x2F;1289&#x2F;nodejs        let &#123; bucket &#x3D; &#39;&#39;, domain &#x3D; &#39;&#39;, accessKey &#x3D; &#39;&#39;, secretKey &#x3D; &#39;&#39;&#125; &#x3D; options        let mac &#x3D; new qiniu.auth.digest.Mac(accessKey, secretKey)        let putPolicy &#x3D; new qiniu.rs.PutPolicy(&#123;            scope: bucket        &#125;);        this.uploadToken &#x3D; putPolicy.uploadToken(mac)        let config &#x3D; new qiniu.conf.Config();        this.formUploader &#x3D; new qiniu.form_up.FormUploader(config)        this.putExtra &#x3D; new qiniu.form_up.PutExtra()    &#125;    apply (compiler) &#123;        compiler.hooks.afterEmit.tapPromise(&#39;UploadPlugin&#39;, (complication) &#x3D;&gt; &#123;            let assets &#x3D; complication.assets            let promise &#x3D; []            Object.keys(assets).forEach(filename &#x3D;&gt; &#123;                promise.push(this.upload(filename))            &#125;)            return Promise.all(promise)        &#125;)    &#125;    upload (filename) &#123;        return new Promise((resolve, reject) &#x3D;&gt; &#123;            let localFile &#x3D; path.resolve(__dirname, &#39;..&#x2F;dist&#39;, filename)            this.formUploader.putFile(this.uploadToken, filename, localFile, this.putExtra, function(respErr,                                                                                 respBody, respInfo) &#123;                if (respErr) &#123;                    reject(respErr)                &#125;                if (respInfo.statusCode &#x3D;&#x3D; 200) &#123;                    resolve(respBody)                &#125; else &#123;                    console.log(respInfo.statusCode)                    console.log(respBody)                &#125;            &#125;);        &#125;)    &#125;&#125;module.exports &#x3D; UploadPlugin\n","plink":"https://www.hansomezao.com/2019/12/10/note/webpack4/"},{"title":"02.react-advance","date":"2019-12-10T05:39:02.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"author":"zao","updated":"2019-12-10T05:39:02.000Z","content":"react 进阶懒加载React.lazy函数能让你像渲染常规组件一样处理动态引入（的组件）。Suspense加载指示器为组件做优雅降级。fallback属性接受任何在组件加载过程中你想展示的 React 元素。\n1234567891011const OtherComponent &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;OtherComponent&#39;));function MyComponent() &#123;  return (    &lt;div&gt;      &lt;Suspense fallback&#x3D;&#123;&lt;div&gt;Loading...&lt;&#x2F;div&gt;&#125;&gt;        &lt;OtherComponent &#x2F;&gt;      &lt;&#x2F;Suspense&gt;    &lt;&#x2F;div&gt;  );&#125;\n\nContextContext提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法，设计目的是为了共享那些对于一个组件树而言是“全局”的数据。\n1234567891011121314151617181920212223242526272829303132333435&#x2F;&#x2F; Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。&#x2F;&#x2F; 为当前的 theme 创建一个 context（“light”为默认值）。const ThemeContext &#x3D; React.createContext(&#39;light&#39;);class App extends React.Component &#123;  render() &#123;    &#x2F;&#x2F; 使用一个 Provider 来将当前的 theme 传递给以下的组件树。    &#x2F;&#x2F; 无论多深，任何组件都能读取这个值。    &#x2F;&#x2F; 在这个例子中，我们将 “dark” 作为当前的值传递下去。    return (      &lt;ThemeContext.Provider value&#x3D;&quot;dark&quot;&gt;        &lt;Toolbar &#x2F;&gt;      &lt;&#x2F;ThemeContext.Provider&gt;    );  &#125;&#125;&#x2F;&#x2F; 中间的组件再也不必指明往下传递 theme 了。function Toolbar(props) &#123;  return (    &lt;div&gt;      &lt;ThemedButton &#x2F;&gt;    &lt;&#x2F;div&gt;  );&#125;class ThemedButton extends React.Component &#123;  &#x2F;&#x2F; 指定 contextType 读取当前的 theme context。  &#x2F;&#x2F; React 会往上找到最近的 theme Provider，然后使用它的值。  &#x2F;&#x2F; 在这个例子中，当前的 theme 值为 “dark”。  static contextType &#x3D; ThemeContext;  render() &#123;    return &lt;Button theme&#x3D;&#123;this.context&#125; &#x2F;&gt;;  &#125;&#125;\n请谨慎使用，因为这会使得组件的复用性变差。\nAPI:React.createContext：创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。\nContext.Provider：每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。\nClass.contextType：挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。\nContext.Consumer：这里，React 组件也可以订阅到 context 变更。这能让你在函数式组件中完成订阅 context。\nRefsRefs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。不能在函数组件上使用 ref 属性，因为他们没有实例，可以在函数组件内部使用 ref 属性。\n适合使用 refs 的情况：\n管理焦点，文本选择或媒体播放。\n触发强制动画。\n集成第三方 DOM 库。\n使用方法：\n创建 Refs\nRefs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。123456789class MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    this.myRef &#x3D; React.createRef();  &#125;  render() &#123;    return &lt;div ref&#x3D;&#123;this.myRef&#125; &#x2F;&gt;;  &#125;&#125;\n\n\n访问 Refs\n在 ref 的 current 属性中被访问1const node &#x3D; this.myRef.current;\n\n\n\nRefs 转发Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。子组件使用React.forwardRef接收ref。可用于Hoc处理ref。\n123456789const FancyButton &#x3D; React.forwardRef((props, ref) &#x3D;&gt; (  &lt;button ref&#x3D;&#123;ref&#125; className&#x3D;&quot;FancyButton&quot;&gt;    &#123;props.children&#125;  &lt;&#x2F;button&gt;));&#x2F;&#x2F; 你可以直接获取 DOM button 的 ref：const ref &#x3D; React.createRef();&lt;FancyButton ref&#x3D;&#123;ref&#125;&gt;Click me!&lt;&#x2F;FancyButton&gt;;\n上例中，FancyButton 使用 React.forwardRef 来获取传递给它的 ref，然后转发到它渲染的 DOM button。这样，使用 FancyButton 的组件可以获取底层 DOM 节点 button 的 ref ，并在必要时访问，就像其直接使用 DOM button 一样。\nFragmentsFragments 允许你将子列表分组，而无需向 DOM 添加额外节点。key 是唯一可以传递给 Fragment 的属性\n123456789render() &#123;  return (    &lt;React.Fragment&gt;      &lt;ChildA &#x2F;&gt;      &lt;ChildB &#x2F;&gt;      &lt;ChildC &#x2F;&gt;    &lt;&#x2F;React.Fragment&gt;  );&#125;\n&lt;React.Fragment&gt;&lt;/React.Fragment&gt;可简写为&lt;&gt;&lt;/&gt;\n高阶组件（HOC）HOC是参数为组件，返回值为新组件的函数。\nHOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。\n示例：\n12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F; 此函数接收一个组件...function withSubscription(WrappedComponent, selectData) &#123;  &#x2F;&#x2F; ...并返回另一个组件...  return class extends React.Component &#123;    constructor(props) &#123;      super(props);      this.handleChange &#x3D; this.handleChange.bind(this);      this.state &#x3D; &#123;        data: selectData(DataSource, props)      &#125;;    &#125;    componentDidMount() &#123;      &#x2F;&#x2F; ...负责订阅相关的操作...      DataSource.addChangeListener(this.handleChange);    &#125;    componentWillUnmount() &#123;      DataSource.removeChangeListener(this.handleChange);    &#125;    handleChange() &#123;      this.setState(&#123;        data: selectData(DataSource, this.props)      &#125;);    &#125;    render() &#123;      &#x2F;&#x2F; ... 并使用新数据渲染被包装的组件!      &#x2F;&#x2F; 请注意，我们可能还会传递其他属性      return &lt;WrappedComponent data&#x3D;&#123;this.state.data&#125; &#123;...this.props&#125; &#x2F;&gt;;    &#125;  &#125;;&#125;\n上例中class组件为HOC的容器组件，容器组件担任分离将高层和低层关注的责任，由容器管理订阅和状态，并将 prop 传递给处理渲染 UI。HOC 使用容器作为其实现的一部分，你可以将 HOC 视为参数化容器组件。\n注意事项：\n不要在 render 方法中使用 HOC。\n在render中使用会导致diff 算法在对比组件变化时每次检测都不一样，每次渲染都会进行卸载，和重新挂载的操作，这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。\n\n务必复制静态方法到容器组件上。\n可以使用hoist-non-react-statics自动拷贝所有非 React 静态方法\n  123456import hoistNonReactStatic from &#39;hoist-non-react-statics&#39;;function enhance(WrappedComponent) &#123;  class Enhance extends React.Component &#123;&#x2F;*...*&#x2F;&#125;  hoistNonReactStatic(Enhance, WrappedComponent);  return Enhance;&#125;\n\nRefs 不会被传递。\n可用过Refs 转发解决\n\n常见的HOC:redux的 connect\nReact.PureComponent大部分情况下，你可以使用 React.PureComponent 来代替手写 shouldComponentUpdate。只有当检测数据是数组或对象时，由于浅拷贝的问题会导致比较出现偏差不能使用，此时使用深拷贝仍可继续使用。\n如以下代码：\n1234567891011121314151617181920212223242526class CounterButton extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state &#x3D; &#123;count: 1&#125;;  &#125;  shouldComponentUpdate(nextProps, nextState) &#123;    if (this.props.color !&#x3D;&#x3D; nextProps.color) &#123;      return true;    &#125;    if (this.state.count !&#x3D;&#x3D; nextState.count) &#123;      return true;    &#125;    return false;  &#125;  render() &#123;    return (      &lt;button        color&#x3D;&#123;this.props.color&#125;        onClick&#x3D;&#123;() &#x3D;&gt; this.setState(state &#x3D;&gt; (&#123;count: state.count + 1&#125;))&#125;&gt;        Count: &#123;this.state.count&#125;      &lt;&#x2F;button&gt;    );  &#125;&#125;\n可替换为：\n12345678910111213141516class CounterButton extends React.PureComponent &#123;  constructor(props) &#123;    super(props);    this.state &#x3D; &#123;count: 1&#125;;  &#125;  render() &#123;    return (      &lt;button        color&#x3D;&#123;this.props.color&#125;        onClick&#x3D;&#123;() &#x3D;&gt; this.setState(state &#x3D;&gt; (&#123;count: state.count + 1&#125;))&#125;&gt;        Count: &#123;this.state.count&#125;      &lt;&#x2F;button&gt;    );  &#125;&#125;\n\nPortalsPortal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。\n一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：\n12345678render() &#123;  &#x2F;&#x2F; React 并*没有*创建一个新的 div。它只是把子元素渲染到 &#96;domNode&#96; 中。  &#x2F;&#x2F; &#96;domNode&#96; 是一个可以在任何位置的有效 DOM 节点。  return ReactDOM.createPortal(    this.props.children,    domNode  );&#125;\n\nReact.StrictModeStrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。严格模式检查仅在开发模式下运行；它们不会影响生产构建。\n作用：识别不安全的生命周期\n关于使用过时字符串 ref API 的警告\n关于使用废弃的 findDOMNode 方法的警告\n检测意外的副作用\n检测过时的 context API\nReact.memoReact.memo 为高阶组件。它与 React.PureComponent 非常相似，但它适用于函数组件，但不适用于 class 组件。\n如果你的函数组件在给定相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。\n默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。\n123const MyComponent &#x3D; React.memo(function MyComponent(props) &#123;  &#x2F;* 使用 props 渲染 *&#x2F;&#125;);","plink":"https://www.hansomezao.com/2019/12/10/note/02.react-advance/"},{"title":"04.redux","date":"2019-12-10T05:39:02.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"author":"zao","updated":"2019-12-10T05:39:02.000Z","content":"redux\n基础\n\n1.数据流:  严格的单向数据流是 Redux 架构的设计核心。  Redux 应用中数据的生命周期遵循下面 4 个步骤：\n调用 store.dispatch(action)。Action 就是一个描述“发生了什么”的普通对象。\n\nRedux store 调用传入的 reducer 函数。Store 会把两个参数传入 reducer： 当前的 state 树和 action。\n\n根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。根 reducer 的结构完全由你决定。Redux 原生提供combineReducers()辅助函数，来把根 reducer 拆分成多个函数，用于分别处理 state 树的一个分支。\n\nRedux store 保存了根 reducer 返回的完整 state 树。这个新的树就是应用的下一个 state！所有订阅 store.subscribe(listener) 的监听器都将被调用；监听器里可以调用 store.getState() 获得当前 state。\n\n\n2.Action:  Action是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。  一般来说你会通过 store.dispatch() 将 action 传到 store。  可以把 action 理解成新闻的摘要。如 “玛丽喜欢42号文章。” 或者 “任务列表里添加了’学习 Redux 文档’”。  你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。\n\n3.Reducer:  Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，  Reducers 就是一个纯函数，接收旧的 state 和 action，返回新的 state。(previousState, action) =&gt; newState  永远不要在 reducer 里做这些操作：\n修改传入参数；\n执行有副作用的操作，如 API 请求和路由跳转；\n调用非纯函数，如 Date.now() 或 Math.random()。\n\n4.Store:  Store 就是用来维持应用所有的 state 树 的一个对象。 改变 store 内 state 的惟一途径是对它 dispatch 一个 action。  Store 不是类。它只是有几个方法的对象。 要创建它，只需要把根部的 reducing 函数 传递给 createStore。  Store 就是把Action和Reducer联系到一起的对象。\nStore的方法:getState()作用：返回应用当前的 state 树。它与 store 的最后一个 reducer 返回值相同。\n返回值：(any): 应用当前的 state 树。\n\ndispatch(action)作用：分发 action。这是触发 state 变化的惟一途径。会使用当前 getState() 的结果和传入的 action 以同步方式的调用 store 的 reduce 函数。返回值会被作为下一个 state。从现在开始，这就成为了 getState() 的返回值，同时变化监听器(change listener)会被触发。\n参数：action (Object)\n返回值：(Object): 要 dispatch 的 action。\n注意：使用 createStore 创建的 “纯正” store 只支持普通对象类型的 action，而且会立即传到 reducer 来执行。但是，如果你用 applyMiddleware 来套住 createStore 时，middleware 可以修改 action 的执行，并支持执行 dispatch intent（意图）。Intent 一般是异步操作如 Promise、Observable 或者 Thunk。\n\nsubscribe(listener)作用：添加一个变化监听器。每当 dispatch action 的时候就会执行，state 树中的一部分可能已经变化。你可以在回调函数里调用 getState() 来拿到当前 state。如果需要解绑这个变化监听器，执行 subscribe 返回的函数即可。\n参数：listener (Function): 每当 dispatch action 的时候都会执行的回调。state 树中的一部分可能已经变化。你可以在回调函数里调用 getState() 来拿到当前 state。store 的 reducer 应该是纯函数，因此你可能需要对 state 树中的引用做深度比较来确定它的值是否有变化。\n返回值：(Function): 一个可以解绑变化监听器的函数。\n\nsubscribe(listener)作用：替换 store 当前用来计算 state 的 reducer。这是一个高级 API。只有在你需要实现代码分隔，而且需要立即加载一些 reducer 的时候才可能会用到它。在实现 Redux 热加载机制的时候也可能会用到。\n参数：reducer (Function) store 会使用的下一个 reducer。\nAPI\n\n\ncreateStore(reducer, [preloadedState], enhancer)\n\n作用：创建一个 Redux store 来以存放应用中所有的 state。应用中应有且仅有一个 store。\n\n参数：reducer (Function): \n接收两个参数，分别是当前的 state 树和要处理的 action，返回新的state 树。\n\n[preloadedState] (any):\n 初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 水合（hydrate）后传给它，或者从之前保存的用户会话中恢复一个传给它。如果你使用 combineReducers 创建 reducer，它必须是一个普通对象，与传入的 keys 保持同样的结构。否则，你可以自由传入任何 reducer 可理解的内容。\n\nenhancer (Function):\nStore enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。\n\n\n返回值：(Store): 保存了应用所有 state 的对象。改变 state 的惟一方法是 dispatch action。你也可以 subscribe 监听 state 的变化，然后更新 UI。\n\n\ncombineReducers()作用：combineReducers() 所做的只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer 根据它们的 key 来筛选出 state 中的一部分数据并处理，然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象。没有任何魔法。正如其他 reducers，如果 combineReducers() 中包含的所有 reducers 都没有更改 state，那么也就不会创建一个新的对象。\n\n\napplyMiddleware(…middlewares)作用：使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息。Middleware 最常见的使用场景是无需引用大量代码或依赖类似 Rx 的第三方库实现异步 actions。这种方式可以让你像 dispatch 一般的 actions 那样 dispatch 异步 actions。\n\n\nbindActionCreators(actionCreators, dispatch)作用：把一个 value 为不同 action creator 的对象，转成拥有同名 key 的对象。同时使用 dispatch 对每个 action creator 进行包装，以便可以直接调用它们。一般情况下你可以直接在 Store 实例上调用 dispatch。如果你在 React 中使用 Redux，react-redux 会提供 dispatch 函数让你直接调用它 。惟一会使用到 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 dispatch 或 Redux store 传给它。为方便起见，你也可以传入一个函数作为第一个参数，它会返回一个函数。另一替代 bindActionCreators 的做法是直接把 dispatch 函数当作 prop 传递给子组件，但这时你的子组件需要引入 action creator 并且感知它们\n\n\ncompose(…functions)作用：从右到左来组合多个函数。这是函数式编程中的方法，为了方便，被放到了 Redux 里。当需要把多个 store 增强器 依次执行的时候，需要用到它。\n\n\nreact-redux\nRedux 官方提供的 React 绑定库,具有高效且灵活的特性。此库并不是 Redux 内置，需要单独安装。\nreact-redux API:&lt;Provider store&gt;作用：&lt;Provider store&gt; 使组件层级中的 connect() 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 &lt;Provider&gt; 中才能使用 connect() 方法。\n属性：store (Redux Store): 应用程序中唯一的 Redux store 对象\nchildren (ReactElement) 组件层级的根组件。\n\n\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])作用：连接 React 组件与 Redux store。连接操作不会改变原来的组件类。反而返回一个新的已与 Redux store 连接的组件类。\n\n参数：[mapStateToProps(state, [ownProps]): stateProps] (Function)：\n如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。\n\n[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function)：\n如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()。如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。\n\n[mergeProps(stateProps, dispatchProps, ownProps): props] (Function)：\n如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。你也许可以用这个回调函数，根据组件的 props 来筛选部分的 state 数据，或者把 props 中的某个特定变量与 action creator 绑定在一起。如果你省略这个参数，默认情况下返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。\n\n[options] (Object)：\n 如果指定这个参数，可以定制 connector 的行为。\n [pure = true] (Boolean):如果为 true，connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。默认值为 true。\n [withRef = false] (Boolean): 如果为 true，connector 会保存一个对被被包含的组件实例的引用，该引用通过 getWrappedInstance() 方法获得。默认值为 false。\n\n\n\n\n\n异步Ation  redux-saga\n\n\n示例项目:💯tiger-react-cli\n\n","plink":"https://www.hansomezao.com/2019/12/10/note/04.redux/"},{"title":"03.Hook","date":"2019-12-10T05:39:02.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"author":"zao","updated":"2019-12-10T05:39:02.000Z","content":"HookHook 是 React 16.8.0 的新增特性。\nHook 使你在非 class 的情况下可以使用更多的 React 特性。Hook 不能在 class 组件中使用。\n使用规则：只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。\n只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。\nState Hook\nuseState\n使用useState可以不通过class组件而在函数组件内使用state，可通过多次调用声明多个state\n参数：\nuseState() 方法里面唯一的参数就是初始 state。\n\n返回值：\n当前 state 以及更新 state 的函数。\n\n函数式更新：\n如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 setState。该函数将接收先前的 state，并返回一个更新后的值。\n1234567891011function Counter(&#123;initialCount&#125;) &#123;  const [count, setCount] &#x3D; useState(initialCount);  return (    &lt;&gt;      Count: &#123;count&#125;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(initialCount)&#125;&gt;Reset&lt;&#x2F;button&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(prevCount &#x3D;&gt; prevCount + 1)&#125;&gt;+&lt;&#x2F;button&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(prevCount &#x3D;&gt; prevCount - 1)&#125;&gt;-&lt;&#x2F;button&gt;    &lt;&#x2F;&gt;  );&#125;\n\nEffect HookEffect Hook 可以让你在函数组件中执行副作用操作（在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。）\n\nuseEffect\n可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。\nuseEffect 会在每次渲染后（第一次渲染之后和每次更新之后）都执行，如果你的 effect 返回一个函数，React 将会在组件卸载的时候执行清除操作时调用它。\nuseEffect在组件内可多次调用，Hook 允许我们按照代码的用途分离他们，React 将按照 effect 声明的顺序依次调用组件中的每一个 effect。\n使用位置：\n组件内部调用 useEffect。 将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count state 变量（或其他 props）。\n性能优化：\nuseEffect 的第二个可选参数可以实现如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用。请确保数组中包含了所有外部作用域中会随时间变化并且在 effect 中使用的变量\n123456789101112&#x2F;&#x2F; 仅在 count 更改时更新useEffect(() &#x3D;&gt; &#123;  document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;&#125;, [count]); &#x2F;&#x2F; 仅在组件初次渲染和组件销毁时执行useEffect(() &#x3D;&gt; &#123;  console.log(&#39;1&#39;)  return () &#x3D;&gt; &#123;    console.log(&#39;2&#39;)  &#125;&#125;, [])\n\n示例代码详解 useState 与 useEffect ：12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F; 引入 React 中的 useState Hook。它让我们在函数组件中存储内部 state&#x2F;&#x2F; 引入 useEffectimport React, &#123; useState, useEffect &#125; from &#39;react&#39;;function Example(props) &#123;  &#x2F;&#x2F; 声明了一个叫 count 的 state 变量，然后把它设为 0  const [count, setCount] &#x3D; useState(0);  &#x2F;&#x2F; 声明第2个state  const [isOnline, setIsOnline] &#x3D; useState(null);  &#x2F;&#x2F; 无需清除的 effect  useEffect(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 将 document 的 title 设置为包含了点击次数的消息。    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;  &#125;);    &#x2F;&#x2F; 需要清除的 effect  useEffect(() &#x3D;&gt; &#123;    function handleFn(val) &#123;      setIsOnline(val);    &#125;    &#x2F;&#x2F; 注册监听    XXAPI.subscribe(handleFn);    &#x2F;&#x2F; 清除监听    return () &#x3D;&gt; &#123;      XXAPI.unsubscribe(handleFn);    &#125;;  &#125;);  return (    &lt;div&gt;      &#x2F;&#x2F; 读取 State: 我们可以直接用 count      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;      &#x2F;&#x2F; 更新 State: 可以通过调用 setCount 来更新当前的 count      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;  );&#125;\n\nuseLayoutEffect其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。尽可能使用标准的 useEffect 以避免阻塞视觉更新。\n与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），这时需要用到useLayoutEffect\nuseRefuseRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。\n12345678910111213function TextInputWithFocusButton() &#123;  const inputEl &#x3D; useRef(null);  const onButtonClick &#x3D; () &#x3D;&gt; &#123;    &#x2F;&#x2F; &#96;current&#96; 指向已挂载到 DOM 上的文本输入元素    inputEl.current.focus();  &#125;;  return (    &lt;&gt;      &lt;input ref&#x3D;&#123;inputEl&#125; type&#x3D;&quot;text&quot; &#x2F;&gt;      &lt;button onClick&#x3D;&#123;onButtonClick&#125;&gt;Focus the input&lt;&#x2F;button&gt;    &lt;&#x2F;&gt;  );&#125;\nuseRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。\n自定义Hook自定义Hook 是一个函数，其名称以 use 开头(必须以 use 开头)，函数内部可以调用其他的 Hook。自定义Hook用于提取多组件之间的共享逻辑，可用于替代 render props 和 HOC。\n在需要共享逻辑的组件内调用很简单，只需要引入定义好的自定义Hook，并传入自己想要的参数拿到你想要的返回值作用于当前组件。\n如下例：提取自定义Hook：\n123456789101112131415161718import React, &#123; useState, useEffect &#125; from &#39;react&#39;;function useFriendStatus(friendID) &#123;  const [isOnline, setIsOnline] &#x3D; useState(null);  useEffect(() &#x3D;&gt; &#123;    function handleStatusChange(status) &#123;      setIsOnline(status.isOnline);    &#125;    XXXAPI.subscribeToFriendStatus(friendID, handleStatusChange);    return () &#x3D;&gt; &#123;      XXXAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);    &#125;;  &#125;);  return isOnline;&#125;\n\n使用自定义Hook：\n123456789function FriendListItem(props) &#123;  const isOnline &#x3D; useFriendStatus(props.friend.id);  return (    &lt;li style&#x3D;&#123;&#123; color: isOnline ? &#39;green&#39; : &#39;black&#39; &#125;&#125;&gt;      &#123;props.friend.name&#125;    &lt;&#x2F;li&gt;  );&#125;\n\n\n其它Hook\nuseReducer\nuseReducer是useState的替代方案，它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。\n在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。\n使用示例：\n1234567891011121314151617181920212223const initialState &#x3D; &#123;count: 0&#125;;function reducer(state, action) &#123;  switch (action.type) &#123;    case &#39;increment&#39;:      return &#123;count: state.count + 1&#125;;    case &#39;decrement&#39;:      return &#123;count: state.count - 1&#125;;    default:      throw new Error();  &#125;&#125;function Counter() &#123;  const [state, dispatch] &#x3D; useReducer(reducer, initialState);  return (    &lt;&gt;      Count: &#123;state.count&#125;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;    &lt;&#x2F;&gt;  );&#125;\n通过阅读React源码 ReactFiberHooks.js 发现 useState 就是对 useReducer 的封装：\n12345678910111213141516171819202122232425&#x2F;&#x2F; useStateexport function useState&lt;S&gt;(  initialState: (() &#x3D;&gt; S) | S,): [S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt;] &#123;  return useReducer(    basicStateReducer,    &#x2F;&#x2F; useReducer has a special case to support lazy useState initializers    (initialState: any),  );&#125;&#x2F;&#x2F; useReducerexport function useReducer&lt;S, A&gt;(  reducer: (S, A) &#x3D;&gt; S,  initialState: S,  initialAction: A | void | null,): [S, Dispatch&lt;A&gt;] &#123;  &#x2F;&#x2F; ...  &#x2F;&#x2F; ...  &#x2F;&#x2F; ...&#125;&#96;&#96;&#96; &gt; ##### useMemo 与 useCallback可用于给子组件传递参数及回调函数时的优化项\nimport React, {useState, useMemo, useCallback} from ‘react’\nfunction fnComponent() {  const [count, setCount] = useState(0)  const [name, setName] = useState(‘name’)\n  // 不会在每次fnComponent有更新都重新渲染Child  const config = useMemo(()=&gt;{    text: count is ${count}  }, [count])  const handleButtonClk = useCallback(()=&gt;{ setCount(c=&gt;c+1) }, [])\n  return (          {name}      {count}      &lt;input value={name} onChange={(e)=&gt;{setName(e.target.value)}} /&gt;            )}\nfunction Child({config, handleButtonClk}) {  console.log(‘child render’)  return (          {config.text}      )}```\n","plink":"https://www.hansomezao.com/2019/12/10/note/03.Hook/"},{"title":"01.react-basic","date":"2019-12-10T05:39:02.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"author":"zao","updated":"2019-12-10T05:39:02.000Z","content":"react 基础JSXJSX是一个 JavaScript 的语法扩展,可以很好地描述 UI 应该呈现出它应有交互的本质形式。\nReact DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。\nJSX 里的 class 变成了 className\n深入了解：JSX 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。\n如下JSX代码：\n123&lt;MyButton color&#x3D;&quot;blue&quot; shadowSize&#x3D;&#123;2&#125;&gt;  Click Me&lt;&#x2F;MyButton&gt;\n会编译为：\n12345React.createElement(  MyButton,  &#123;color: &#39;blue&#39;, shadowSize: 2&#125;,  &#39;Click Me&#39;)\n\n元素元素是构成 React 应用的最小砖块。\nReact 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。\n组件是由元素构成的。\nfalse, null, undefined, true 是合法的子元素。但它们并不会被渲染。\n以下的 JSX 表达式渲染结果相同：\n1234567891011&lt;div &#x2F;&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt;&#123;false&#125;&lt;&#x2F;div&gt;&lt;div&gt;&#123;null&#125;&lt;&#x2F;div&gt;&lt;div&gt;&#123;undefined&#125;&lt;&#x2F;div&gt;&lt;div&gt;&#123;true&#125;&lt;&#x2F;div&gt;\n\n组件组件名称必须以大写字母开头(React 会将以小写字母开头的组件视为原生 DOM 标签)\n函数组件（以前称之为无状态组件，但Hook出来之后叫为函数组件）：\n123function Welcome(props) &#123;  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;&#125;\n\nclass组件\n12345class Welcome extends React.Component &#123;  render() &#123;    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;  &#125;&#125;\n\n\nprops当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 “props”。组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props\n12345678910111213141516&#x2F;&#x2F; 这段代码会在页面上渲染 “Hello, Sara”function Welcome(props) &#123;  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;&#125;const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;;ReactDOM.render(  element,  document.getElementById(&#39;root&#39;));&#x2F;&#x2F;上段代码渲染时发生了什么：  1. 我们调用 ReactDOM.render() 函数，并传入 &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt; 作为参数。  2. React 调用 Welcome 组件，并将 &#123;name: &#39;Sara&#39;&#125; 作为 props 传入。  3. Welcome 组件将 &lt;h1&gt;Hello, Sara&lt;&#x2F;h1&gt; 元素作为返回值。  4. React DOM 将 DOM 高效地更新为 &lt;h1&gt;Hello, Sara&lt;&#x2F;h1&gt;。\n有多种方式可以在 JSX 中指定 props。\nJavaScript 表达式作为 Props\n字符串字面量\nprops 默认值为true\nState使用this.setState()设置state的值\nthis.setState()可能是异步的\n调用this.setState()的时候，React 会把你提供的对象合并到当前的 state。\n数据流react是单向数据流，任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。\n生命周期在 V16 版本中引入了 Fiber 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 2 个 API 来解决问题。（Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 state，那么调用栈可能会很长，调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。Fiber 就是为了解决该问题而生。）\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class ExampleComponent extends React.Component &#123;  &#x2F;&#x2F; 用于初始化 state  constructor(props) &#123;    super(props)    this.state &#x3D; &#123; hasError: false &#125;;  &#125;  &#x2F;&#x2F; 用于替换 &#96;componentWillReceiveProps&#96; ，该函数会在初始化和 &#96;update&#96; 时被调用  &#x2F;&#x2F; 因为该函数是静态函数，所以取不到 &#96;this&#96;, 如果需要对比 &#96;prevProps&#96; 需要单独在 &#96;state&#96; 中维护  &#x2F;&#x2F; 它应返回一个对象来更新 state  static getDerivedStateFromProps(nextProps, prevState) &#123;&#125;  &#x2F;&#x2F; 判断是否需要更新组件，多用于组件性能优化  shouldComponentUpdate(nextProps, nextState) &#123;&#125;  &#x2F;&#x2F; 组件挂载后调用  &#x2F;&#x2F; 可以在该函数中进行请求或者订阅  componentDidMount() &#123;&#125;  &#x2F;&#x2F; 用于替换 componentWillUpdate ，该函数会在 update 后 DOM 更新前被调用  &#x2F;&#x2F; 用于读取最新的 DOM 数据。  getSnapshotBeforeUpdate() &#123;&#125;  &#x2F;&#x2F; 组件即将销毁  &#x2F;&#x2F; 可以在此处移除订阅，定时器等等  componentWillUnmount() &#123;&#125;  &#x2F;&#x2F; 组件销毁后调用  componentDidUnMount() &#123;&#125;  &#x2F;&#x2F; 组件更新后调用  componentDidUpdate() &#123;&#125;  &#x2F;&#x2F; 错误边界 - 渲染备用 UI  &#x2F;&#x2F; 更新 state 使下一次渲染能够显示降级后的 UI  &#x2F;&#x2F; 注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误  static getDerivedStateFromError(error) &#123;    return &#123; hasError: true &#125;;  &#125;  &#x2F;&#x2F; 错误边界 - 打印错误信息  &#x2F;&#x2F; 你同样可以将错误日志上报给服务器  &#x2F;&#x2F; 注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误  componentDidCatch(error, info) &#123;    console.log(error, info);  &#125;  &#x2F;&#x2F; 渲染组件函数  render() &#123;&#125;  &#x2F;&#x2F; 以下函数不建议使用  UNSAFE_componentWillMount() &#123;&#125;  UNSAFE_componentWillUpdate(nextProps, nextState) &#123;&#125;  &#x2F;&#x2F; 接收到新的props时调用  UNSAFE_componentWillReceiveProps(nextProps) &#123;&#125;&#125;\n对于异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。\nReconciliation 阶段：componentWillMount\ncomponentWillReceiveProps\nshouldComponentUpdate\ncomponentWillUpdate\n\nCommit 阶段：componentDidMount\ncomponentDidUpdate\ncomponentWillUnmount\n\n因为 reconciliation 阶段是可以被打断的，所以 reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。所以对于 reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用。\nV16.4以后生命周期图解（不包含官方不建议使用的）\n事件处理React 事件的命名采用小驼峰式（camelCase），而不是纯小写。\n使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。\n为JSX内时间绑定this的几种方式：\nconstructor内处理：123constructor() &#123;  this.handleClick &#x3D; this.handleClick.bind(this);&#125;\nJSX内使用bind:1&lt;button onClick&#x3D;&#123;this.handleClick.bind(this, id)&#125;&gt;Delete Row&lt;&#x2F;button&gt;\n箭头函数：1&lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.handleClick(id)&#125;&gt;Delete Row&lt;&#x2F;button&gt;\n\n\nkeykey 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。key 只是在兄弟节点之间必须唯一\n受控组件使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做受控组件。\n非受控组件表单数据将交由 DOM 节点来处理。使用非受控组件时如果想赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 defaultValue 属性，而不是 value。\n&lt;input type=&quot;file&quot; /&gt; 始终是一个非受控组件\n进阶redux-adcanve\n","plink":"https://www.hansomezao.com/2019/12/10/note/01.react-basic/"},{"title":"05.redux-saga","date":"2019-12-10T05:39:02.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"author":"zao","updated":"2019-12-10T05:39:02.000Z","content":"redux-saga介绍：  在 redux-saga 的世界里，所有的任务都通用 yield Effects 来完成（Effect 可以看作是 redux-saga 的任务单元）\n\n名词释义：Effect：一个 effect 就是一个 Plain Object JavaScript 对象，包含一些将被 saga middleware 执行的指令。使用 redux-saga 提供的工厂函数来创建 effect。一个 Saga 所做的实际上是组合那些所有的 Effect，共同实现所需的控制流。 最简单的例子是直接把 yield 一个接一个地放置来对序列化 yield Effect。你也可以使用熟悉的控制流操作符（if, while, for） 来实现更复杂的控制流。\n\n核心API:Saga 辅助函数:takeEvery允许多个实例同时启动\n\ntakeLatest在任何时刻 takeLatest 只允许执行一个任务，并且这个任务是最后被启动的那个，如果之前已经有一个任务在执行，那之前的这个任务会自动被取消\n\n\nEffect Creatorstake(pattern)take函数可以理解为监听未来的action，它创建了一个命令对象，告诉middleware等待一个特定的action， Generator会暂停，直到一个与pattern匹配的action被发起，才会继续执行下面的语句，也就是说，take是一个阻塞的 effect。take 让我们通过全面控制 action 观察进程来构建复杂的控制流成为可能。\n\nput(action)put函数是用来发送action的 effect，你可以简单的把它理解成为redux框架中的dispatch函数，当put一个action后，reducer中就会计算新的state并返回，注意： put 也是阻塞 effect\n\ncall(fn, …args)call函数你可以把它简单的理解为就是可以调用其他函数的函数，它命令 middleware 来调用fn 函数， args为函数的参数，注意： fn 函数可以是一个 Generator 函数，也可以是一个返回 Promise 的普通函数，call 函数也是阻塞 effect\n\nselect(selector, …args)select 函数是用来指示 middleware调用提供的选择器获取Store上的state数据，你也可以简单的把它理解为redux框架中获取store上的 state数据一样的功能 ：store.getState()\n\nfork(fn, …args)fork 函数和 call 函数很像，都是用来调用其他函数的，但是fork函数是非阻塞函数，也就是说，程序执行完 yield fork(fn， args) 这一行代码后，会立即接着执行下一行代码语句，而不会等待fn函数返回结果后，在执行下面的语句\n\ncancel(task)一旦任务被 fork，可以使用 yield cancel(task) 来中止任务执行，使用 yield cancelled() 来检查 Generator 是否已经被取消。取消正在运行的任务。取消接口请求（race也可以实现类似取消功能）\n\n\ncreateSagaMiddleware()createSagaMiddleware 函数是用来创建一个 Redux 中间件，将 Sagas 与 Redux Store 链接起来。sagas 中的每个函数都必须返回一个 Generator 对象，middleware 会迭代这个 Generator 并执行所有 yield 后的 Effect（Effect 可以看作是 redux-saga 的任务单元）\n\nmiddleware.run(sagas, …args)动态执行sagas，用于applyMiddleware阶段之后执行sagas\n\n\n错误处理：我们可以使用熟悉的 try/catch 语法在 Saga 中捕获错误。\n\n示例项目:💯tiger-react-cli\n","plink":"https://www.hansomezao.com/2019/12/10/note/05.redux-saga/"},{"title":"js常用小技巧","date":"2019-12-10T05:39:02.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"author":"zao","updated":"2019-12-10T05:39:02.000Z","content":"小数取整：\n11.234 | 0\n\n1~~1.234\n\n11.234 &gt;&gt; 0\n\n妙用隐式转换：\n\n字符串转number:\n\n1+'123'\n\n\nnew Date转时间戳：\n\n1+new Date()\n\n\n数组/多维数组转为逗号分隔字符串(可用于多维数组转一维)：\n\n1\"\"+[1, 2 , 3, 3, [2, 3, 4]]\n\n解构：\n\n交换a,b的值：\n\n1234var a=1;var b=2;[a, b] = [b, a];console.log(a, b);\n\n扩展运算符：\n\n取数组最大值/最小值：\n\n12Math.max(...[1,2,3])Math.min(...[1,2,3])\n\n\n生成时间：\n\n1new Date(...[2018,6,4])\n\n\n字符串转数组：\n\n12345method 1: [...'string']method 2: Array.from('string')\n\n\n合并对象：\n\n123456let obj1 = &#123;a:1, b:2&#125;;let obj2 = &#123;b:3, c:4&#125;;&#123;...obj1, ...obj2&#125;  等同于Object.assign(obj1, obj2)\n\n常用方法：\n\n数字前补0：\n\n123function preFixNum(num, length) &#123;  return (Array(length).join('0') + num).slice(-length);&#125;\n\n\n数组元素为对象的去重：\n\n1[...new Set(arr.map(v =&gt; JSON.stringify(v)))].map(v =&gt; JSON.parse(v))\n\n\n数组求和：\n\n1234567var arr = [1,2,3,4,5];method 1: var sum = eval(arr.join('+'));method 2: var sum = arr.reduce((prev,cur) =&gt; prev + cur);\n\n\n金钱格式化(千分)：\n\n12345678910let money = 11111;method 1: money.toLocaleString('en-US');method 2: Intl.NumberFormat().format(money);method 3: String(money).replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, ',');\n\n\n短路逻辑代替if：\n\n1isTrue &amp;&amp; console.log(1);\n\n\nRGB to Hex：\n\n123function RGBtoHEX(rgb)&#123;  return ((1&lt;&lt;24) + (rgb.r&lt;&lt;16) + (rgb.g&lt;&lt;8) + rgb.b).toString(16).substr(1);&#125;\n\n\n延时函数:\n\n1const delay &#x3D; ms &#x3D;&gt; new Promise(resolve &#x3D;&gt; setTimeout(resolve, ms))\n\n\n生成指定长度数组：\n\n1Array.from(new Array(10).keys());\n正则进阶：\n\n捕获括号：\n\n12匹配 'tigerHee' 并且记住匹配项/(tigerHee)/\n\n\n非捕获括号：\n\n12匹配 'tigerHee' 但是不记住匹配项/(?:tigerHee)/\n\n\n先行断言：\n\n12匹配'tiger'仅仅当'tiger'后面跟着'Hee'/tiger(?=Hee)/\n\n\n后行断言：\n\n12匹配'Hee'仅仅当'Hee'前面是'tiger'/(?&lt;=tiger)Hee/\n\n\n正向否定查找：\n\n12匹配'tiger'仅仅当'tiger'后面不跟着'java'/tiger(?!java)/\n\n\n\n","plink":"https://www.hansomezao.com/2019/12/10/note/js常用小技巧/"},{"title":"http常见消息头","date":"2019-12-06T10:30:37.000Z","date_formatted":{"ll":"2019年12月6日","L":"2019/12/06","MM-DD":"12-06"},"author":"zao","updated":"2019-12-06T10:30:37.000Z","content":"HTTP消息头（HTTP headers）－常用的HTTP请求头与响应头HTTP消息头是指，在超文本传输协议（ Hypertext Transfer Protocol ，HTTP）的请求和响应消息中，协议头部分的那些组件。HTTP消息头用来准确描述正在获取的资源、服务器或者客户端的行为，定义了HTTP事务中的具体操作参数。\n关于HTTP消息头\n常用的HTTP请求头\n常用的HTTP响应头\n1. 关于HTTP消息头HTTP消息头是在，客户端请求（Request）或服务器响应（Response）时传递的，位请求或响应的第一行，HTTP消息体（请求或响应的内容）是其后传输。HTTP消息头，以明文的字符串格式传送，是以冒号分隔的键/值对，如：Accept-Charset: utf-8，每一个消息头最后以回车符(CR)和换行符(LF)结尾。HTTP消息头结束后，会用一个空白的字段来标识，这样就会出现两个连续的CR-LF。\nHTTP消息头由IANA（The Internet Assigned Numbers Authority，互联网数字分配机构）来整理和维护。其标准最早来源于RFC 4229。IANA将其整理到了消息头文档，文档中还包括了一些新提出的信息头。\nHTTP消息头支持自定义， 自定义的专用消息头一般会添加&#39;X-&#39;前缀。\n2. 常用的HTTP请求头\n协议头说明示例状态\n\nAccept可接受的响应内容类型（Content-Types）。Accept: text/plain固定\n\nAccept-Charset可接受的字符集Accept-Charset: utf-8固定\n\nAccept-Encoding可接受的响应内容的编码方式。Accept-Encoding: gzip, deflate固定\n\nAccept-Language可接受的响应内容语言列表。Accept-Language: en-US固定\n\nAccept-Datetime可接受的按照时间来表示的响应内容版本Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT临时\n\nAuthorization用于表示HTTP协议中需要认证资源的认证信息Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==固定\n\nCache-Control用来指定当前的请求/回复中的，是否使用缓存机制。Cache-Control: no-cache固定\n\nConnection客户端（浏览器）想要优先使用的连接类型Connection: keep-alive``Connection: Upgrade固定\n\nCookie由之前服务器通过Set-Cookie（见下文）设置的一个HTTP协议CookieCookie: $Version=1; Skin=new;固定：标准\n\nContent-Length以8进制表示的请求体的长度Content-Length: 348固定\n\nContent-MD5请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==废弃\n\nContent-Type请求体的MIME类型 （用于POST和PUT请求中）Content-Type: application/x-www-form-urlencoded固定\n\nDate发送该消息的日期和时间（以RFC 7231中定义的”HTTP日期”格式来发送）Date: Dec, 26 Dec 2015 17:30:00 GMT固定\n\nExpect表示客户端要求服务器做出特定的行为Expect: 100-continue固定\n\nFrom发起此请求的用户的邮件地址From: user@itbilu.com固定\n\nHost表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。Host: www.itbilu.com:80``Host: www.itbilu.com固定\n\nIf-Match仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。If-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”固定\n\nIf-Modified-Since允许在对应的资源未被修改的情况下返回304未修改If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT固定\n\nIf-None-Match允许在对应的内容未被修改的情况下返回304未修改（ 304 Not Modified ），参考 超文本传输协议 的实体标记If-None-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”固定\n\nIf-Range如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体If-Range: “9jd00cdj34pss9ejqiw39d82f20d0ikd”固定\n\nIf-Unmodified-Since仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT固定\n\nMax-Forwards限制该消息可被代理及网关转发的次数。Max-Forwards: 10固定\n\nOrigin发起一个针对跨域资源共享的请求（该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源）。Origin: http://www.itbilu.com固定: 标准\n\nPragma与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。Pragma: no-cache固定\n\nProxy-Authorization用于向代理进行认证的认证信息。Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2==固定\n\nRange表示请求某个实体的一部分，字节偏移以0开始。Range: bytes=500-999固定\n\nReferer表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。Referer其实是Referrer这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用Referer了。Referer: http://itbilu.com/nodejs固定\n\nTE浏览器预期接受的传输时的编码方式：可使用回应协议头Transfer-Encoding中的值（还可以使用”trailers”表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。TE: trailers,deflate固定\n\nUser-Agent浏览器的身份标识字符串User-Agent: Mozilla/……固定\n\nUpgrade要求服务器升级到一个高版本协议。Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11固定\n\nVia告诉服务器，这个请求是由哪些代理发出的。Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)固定\n\nWarning一个一般性的警告，表示在实体内容体中可能存在错误。Warning: 199 Miscellaneous warning固定\n3. 常用的HTTP响应头\n响应头说明示例状态\n\nAccess-Control-Allow-Origin指定哪些网站可以跨域源资源共享Access-Control-Allow-Origin: *临时\n\nAccept-Patch指定服务器所支持的文档补丁格式Accept-Patch: text/example;charset=utf-8固定\n\nAccept-Ranges服务器所支持的内容范围Accept-Ranges: bytes固定\n\nAge响应对象在代理缓存中存在的时间，以秒为单位Age: 12固定\n\nAllow对于特定资源的有效动作;Allow: GET, HEAD固定\n\nCache-Control通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒Cache-Control: max-age=3600固定\n\nConnection针对该连接所预期的选项Connection: close固定\n\nContent-Disposition对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。Content-Disposition: attachment; filename=”fname.ext”固定\n\nContent-Encoding响应资源所使用的编码类型。Content-Encoding: gzip固定\n\nContent-Language响就内容所使用的语言Content-Language: zh-cn固定\n\nContent-Length响应消息体的长度，用8进制字节表示Content-Length: 348固定\n\nContent-Location所返回的数据的一个候选位置Content-Location: /index.htm固定\n\nContent-MD5响应内容的二进制 MD5 散列值，以 Base64 方式编码Content-MD5: IDK0iSsgSW50ZWd0DiJUi==已淘汰\n\nContent-Range如果是响应部分消息，表示属于完整消息的哪个部分Content-Range: bytes 21010-47021/47022固定\n\nContent-Type当前内容的MIME类型Content-Type: text/html; charset=utf-8固定\n\nDate此条消息被发送时的日期和时间(以RFC 7231中定义的”HTTP日期”格式来表示)Date: Tue, 15 Nov 1994 08:12:31 GMT固定\n\nETag对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列ETag: “737060cd8c284d8af7ad3082f209582d”固定\n\nExpires指定一个日期/时间，超过该时间则认为此回应已经过期Expires: Thu, 01 Dec 1994 16:00:00 GMT固定: 标准\n\nLast-Modified所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT固定\n\nLink用来表示与另一个资源之间的类型关系，此类型关系是在RFC 5988中定义Link:; rel=”alternate”固定\n\nLocation用于在进行重定向，或在创建了某个新资源时使用。Location: http://www.itbilu.com/nodejs固定\n\nP3PP3P策略相关设置P3P: CP=”This is not a P3P policy!固定\n\nPragma与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果Pragma: no-cache固定\n\nProxy-Authenticate要求在访问代理时提供身份认证信息。Proxy-Authenticate: Basic固定\n\nPublic-Key-Pins用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值Public-Key-Pins: max-age=2592000; pin-sha256=”……”;固定\n\nRefresh用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。Refresh: 5; url=http://itbilu.com\n\nRetry-After如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT固定\n\nServer服务器的名称Server: nginx/1.6.3固定\n\nSet-Cookie设置HTTP cookieSet-Cookie: UserID=itbilu; Max-Age=3600; Version=1固定: 标准\n\nStatus通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。Status: 200 OK\n\nTrailerTrailer用户说明传输中分块编码的编码信息Trailer: Max-Forwards固定\n\nTransfer-Encoding用表示实体传输给用户的编码形式。包括：chunked、compress、 deflate、gzip、identity。Transfer-Encoding: chunked固定\n\nUpgrade要求客户端升级到另一个高版本协议。Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11固定\n\nVary告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。Vary: *固定\n\nVia告知代理服务器的客户端，当前响应是通过什么途径发送的。Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)固定\n\nWarning一般性警告，告知在实体内容体中可能存在错误。Warning: 199 Miscellaneous warning固定\n\nWWW-Authenticate表示在请求获取这个实体时应当使用的认证模式。WWW-Authenticate: Basic固定\n","plink":"https://www.hansomezao.com/2019/12/06/note/http常见消息头/"},{"title":"08.React源码学习-commit","date":"2019-12-02T02:25:29.000Z","date_formatted":{"ll":"2019年12月2日","L":"2019/12/02","MM-DD":"12-02"},"author":"zao","updated":"2019-12-02T02:25:29.000Z","content":"commit首先要标记优先级，因为有一部分优先级的任务已经被提交了，所以需要清楚一些相关的优先级。被提交的任务应该是：\n子树中优先级最高的任务\n或者外部指定的优先级（flushSync或者retry）\n如果 RootFiber 本身也有副作用（一般只有第一次），那么他本身也要加到 effect 链上，放在最后。接下去是三个提交操作，分别是:\n提交Snapshot\n提交HostComponent的 side effect`\n提交所有组件的生命周期\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187function commitRoot(root: FiberRoot, finishedWork: Fiber): void &#123;  isWorking &#x3D; true  isCommitting &#x3D; true  startCommitTimer()  invariant(    root.current !&#x3D;&#x3D; finishedWork,    &#39;Cannot commit the same tree as before. This is probably a bug &#39; +      &#39;related to the return field. This error is likely caused by a bug &#39; +      &#39;in React. Please file an issue.&#39;,  )  const committedExpirationTime &#x3D; root.pendingCommitExpirationTime  invariant(    committedExpirationTime !&#x3D;&#x3D; NoWork,    &#39;Cannot commit an incomplete root. This error is likely caused by a &#39; +      &#39;bug in React. Please file an issue.&#39;,  )  root.pendingCommitExpirationTime &#x3D; NoWork  const updateExpirationTimeBeforeCommit &#x3D; finishedWork.expirationTime  const childExpirationTimeBeforeCommit &#x3D; finishedWork.childExpirationTime  const earliestRemainingTimeBeforeCommit &#x3D;    updateExpirationTimeBeforeCommit &#x3D;&#x3D;&#x3D; NoWork ||    (childExpirationTimeBeforeCommit !&#x3D;&#x3D; NoWork &amp;&amp;      childExpirationTimeBeforeCommit &lt; updateExpirationTimeBeforeCommit)      ? childExpirationTimeBeforeCommit      : updateExpirationTimeBeforeCommit  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit)  let prevInteractions: Set&lt;Interaction&gt; &#x3D; (null: any)  &#x2F;&#x2F; Reset this to null before calling lifecycles  ReactCurrentOwner.current &#x3D; null  let firstEffect  if (finishedWork.effectTag &gt; PerformedWork) &#123;    &#x2F;&#x2F; A fiber&#39;s effect list consists only of its children, not itself. So if    &#x2F;&#x2F; the root has an effect, we need to add it to the end of the list. The    &#x2F;&#x2F; resulting list is the set that would belong to the root&#39;s parent, if    &#x2F;&#x2F; it had one; that is, all the effects in the tree including the root.    if (finishedWork.lastEffect !&#x3D;&#x3D; null) &#123;      finishedWork.lastEffect.nextEffect &#x3D; finishedWork      firstEffect &#x3D; finishedWork.firstEffect    &#125; else &#123;      firstEffect &#x3D; finishedWork    &#125;  &#125; else &#123;    &#x2F;&#x2F; There is no effect on the root.    firstEffect &#x3D; finishedWork.firstEffect  &#125;  prepareForCommit(root.containerInfo)  &#x2F;&#x2F; Invoke instances of getSnapshotBeforeUpdate before mutation.  nextEffect &#x3D; firstEffect  startCommitSnapshotEffectsTimer()  while (nextEffect !&#x3D;&#x3D; null) &#123;    let didError &#x3D; false    let error    if (__DEV__) &#123;      invokeGuardedCallback(null, commitBeforeMutationLifecycles, null)      if (hasCaughtError()) &#123;        didError &#x3D; true        error &#x3D; clearCaughtError()      &#125;    &#125; else &#123;      try &#123;        commitBeforeMutationLifecycles()      &#125; catch (e) &#123;        didError &#x3D; true        error &#x3D; e      &#125;    &#125;    if (didError) &#123;      invariant(        nextEffect !&#x3D;&#x3D; null,        &#39;Should have next effect. This error is likely caused by a bug &#39; +          &#39;in React. Please file an issue.&#39;,      )      captureCommitPhaseError(nextEffect, error)      &#x2F;&#x2F; Clean-up      if (nextEffect !&#x3D;&#x3D; null) &#123;        nextEffect &#x3D; nextEffect.nextEffect      &#125;    &#125;  &#125;  stopCommitSnapshotEffectsTimer()  nextEffect &#x3D; firstEffect  startCommitHostEffectsTimer()  while (nextEffect !&#x3D;&#x3D; null) &#123;    let didError &#x3D; false    let error    if (__DEV__) &#123;      invokeGuardedCallback(null, commitAllHostEffects, null)      if (hasCaughtError()) &#123;        didError &#x3D; true        error &#x3D; clearCaughtError()      &#125;    &#125; else &#123;      try &#123;        commitAllHostEffects()      &#125; catch (e) &#123;        didError &#x3D; true        error &#x3D; e      &#125;    &#125;    if (didError) &#123;      invariant(        nextEffect !&#x3D;&#x3D; null,        &#39;Should have next effect. This error is likely caused by a bug &#39; +          &#39;in React. Please file an issue.&#39;,      )      captureCommitPhaseError(nextEffect, error)      &#x2F;&#x2F; Clean-up      if (nextEffect !&#x3D;&#x3D; null) &#123;        nextEffect &#x3D; nextEffect.nextEffect      &#125;    &#125;  &#125;  stopCommitHostEffectsTimer()  resetAfterCommit(root.containerInfo)  root.current &#x3D; finishedWork  nextEffect &#x3D; firstEffect  startCommitLifeCyclesTimer()  while (nextEffect !&#x3D;&#x3D; null) &#123;    let didError &#x3D; false    let error    if (__DEV__) &#123;      invokeGuardedCallback(        null,        commitAllLifeCycles,        null,        root,        committedExpirationTime,      )      if (hasCaughtError()) &#123;        didError &#x3D; true        error &#x3D; clearCaughtError()      &#125;    &#125; else &#123;      try &#123;        commitAllLifeCycles(root, committedExpirationTime)      &#125; catch (e) &#123;        didError &#x3D; true        error &#x3D; e      &#125;    &#125;    if (didError) &#123;      invariant(        nextEffect !&#x3D;&#x3D; null,        &#39;Should have next effect. This error is likely caused by a bug &#39; +          &#39;in React. Please file an issue.&#39;,      )      captureCommitPhaseError(nextEffect, error)      if (nextEffect !&#x3D;&#x3D; null) &#123;        nextEffect &#x3D; nextEffect.nextEffect      &#125;    &#125;  &#125;  isCommitting &#x3D; false  isWorking &#x3D; false  stopCommitLifeCyclesTimer()  stopCommitTimer()  onCommitRoot(finishedWork.stateNode)  const updateExpirationTimeAfterCommit &#x3D; finishedWork.expirationTime  const childExpirationTimeAfterCommit &#x3D; finishedWork.childExpirationTime  const earliestRemainingTimeAfterCommit &#x3D;    updateExpirationTimeAfterCommit &#x3D;&#x3D;&#x3D; NoWork ||    (childExpirationTimeAfterCommit !&#x3D;&#x3D; NoWork &amp;&amp;      childExpirationTimeAfterCommit &lt; updateExpirationTimeAfterCommit)      ? childExpirationTimeAfterCommit      : updateExpirationTimeAfterCommit  if (earliestRemainingTimeAfterCommit &#x3D;&#x3D;&#x3D; NoWork) &#123;    &#x2F;&#x2F; If there&#39;s no remaining work, we can clear the set of already failed    &#x2F;&#x2F; error boundaries.    legacyErrorBoundariesThatAlreadyFailed &#x3D; null  &#125;  onCommit(root, earliestRemainingTimeAfterCommit)  &#x2F;&#x2F; profiler 相关&#125;","plink":"https://www.hansomezao.com/2019/12/02/note/08-React源码学习-commit/"},{"title":"07.React源码学习-beginWork","date":"2019-12-01T07:25:29.000Z","date_formatted":{"ll":"2019年12月1日","L":"2019/12/01","MM-DD":"12-01"},"author":"zao","updated":"2019-12-01T07:25:29.000Z","content":"beginWork执行对整棵树的每一个节点进行更新的操作（performUnitOfWork内调用beginWork）\n源码在 react-reconciler 下的 ReactFiberBeginWork.js 内：\nbeginWork()方法里通过 switch (workInProgress.tag)对不同的组件做不同的更新处理：\n下面看看不同组件的更新：\n出现频率很高的一个判断 current === null 用于判断组件是否是第一次渲染。\n1.FunctionComponent1234567891011121314151617181920212223242526272829function updateFunctionComponent(  current,  workInProgress,  Component,  nextProps: any,  renderExpirationTime,) &#123;  &#x2F;&#x2F; 此处去掉__DEV__代码  const unmaskedContext &#x3D; getUnmaskedContext(workInProgress, Component, true);  const context &#x3D; getMaskedContext(workInProgress, unmaskedContext);  let nextChildren;  prepareToReadContext(workInProgress, renderExpirationTime);  prepareToUseHooks(current, workInProgress, renderExpirationTime);  if (__DEV__) &#123;    &#x2F;&#x2F; 此处去掉__DEV__代码  &#125; else &#123;    nextChildren &#x3D; Component(nextProps, context);  &#125;  nextChildren &#x3D; finishHooks(Component, nextProps, nextChildren, context);  &#x2F;&#x2F; React DevTools reads this flag.  workInProgress.effectTag |&#x3D; PerformedWork;  reconcileChildren(    current,    workInProgress,    nextChildren,    renderExpirationTime,  );  return workInProgress.child;&#125;\n调用Component时传入了两个值nextProps和context, 那么函数组件可以直接通过第二个参数拿到context，官方文档没有说明过这点。\n2.ClassComponent12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function updateClassComponent(  current: Fiber | null,  workInProgress: Fiber,  Component: any,  nextProps,  renderExpirationTime: ExpirationTime,) &#123;  if (__DEV__) &#123;    &#x2F;&#x2F; 去掉__DEV__代码  &#125;  &#x2F;&#x2F; Push context providers early to prevent context stack mismatches.  &#x2F;&#x2F; During mounting we don&#39;t know the child context yet as the instance doesn&#39;t exist.  &#x2F;&#x2F; We will invalidate the child context in finishClassComponent() right after rendering.  let hasContext;  if (isLegacyContextProvider(Component)) &#123;    hasContext &#x3D; true;    pushLegacyContextProvider(workInProgress);  &#125; else &#123;    hasContext &#x3D; false;  &#125;  prepareToReadContext(workInProgress, renderExpirationTime);  const instance &#x3D; workInProgress.stateNode;  let shouldUpdate;  if (instance &#x3D;&#x3D;&#x3D; null) &#123;    if (current !&#x3D;&#x3D; null) &#123;      &#x2F;&#x2F; An class component without an instance only mounts if it suspended      &#x2F;&#x2F; inside a non- concurrent tree, in an inconsistent state. We want to      &#x2F;&#x2F; tree it like a new mount, even though an empty version of it already      &#x2F;&#x2F; committed. Disconnect the alternate pointers.      current.alternate &#x3D; null;      workInProgress.alternate &#x3D; null;      &#x2F;&#x2F; Since this is conceptually a new fiber, schedule a Placement effect      workInProgress.effectTag |&#x3D; Placement;    &#125;    &#x2F;&#x2F; In the initial pass we might need to construct the instance.    constructClassInstance(      workInProgress,      Component,      nextProps,      renderExpirationTime,    );    mountClassInstance(      workInProgress,      Component,      nextProps,      renderExpirationTime,    );    shouldUpdate &#x3D; true;  &#125; else if (current &#x3D;&#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; In a resume, we&#39;ll already have an instance we can reuse.    shouldUpdate &#x3D; resumeMountClassInstance(      workInProgress,      Component,      nextProps,      renderExpirationTime,    );  &#125; else &#123;    shouldUpdate &#x3D; updateClassInstance(      current,      workInProgress,      Component,      nextProps,      renderExpirationTime,    );  &#125;  const nextUnitOfWork &#x3D; finishClassComponent(    current,    workInProgress,    Component,    shouldUpdate,    hasContext,    renderExpirationTime,  );  if (__DEV__) &#123;    &#x2F;&#x2F; 去掉__DEV__代码  &#125;  return nextUnitOfWork;&#125;\n\n开始是对context的操作，因为ClassComponent可以成为context provider。\ncurrent === null只会出现在第一次渲染的时候，因为会先创建workInProcess，在渲染结束之后才会把workInProcess拷贝成current，代表着第一次渲染结束。而后面也会出现根据current === null来判断是否需要调用componentDidMount的代码\n在这里如果current === null就行要进行实例的构建工作，如果不是，直接updateClassInstance\n如果是还要判断实例是否已经创建workInProgress.stateNode === null，如果是的话要创建这个实例，通过constructClassInstance(代码在同级的ReactFiberClassComponent.js内，这个方法调用adoptClassInstance给 ClassComponent 的实例挂载一个updater对象，里面包含我们常用的方法：forceUpdate, replaceState, setState)，并且挂载实例mountClassInstance（初始化 props、state 等实例属性，如果有updateQueue就更新之，一般来说第一次渲染是没有的。）\n如果已经有current则调用updateClassInstance\n最后调用finishClassComponent\n3.IndeterminateComponentFunctionalComponent在含有render方法时会被当做ClassComponent来处理\n12345678910export default ()&#x3D;&gt;&#123;  return &#123;    componentDidMount() &#123;      console.log(&#39;Indeterminate&#39;)    &#125;,    render() &#123;      return &lt;div&gt;Indeterminate&lt;&#x2F;div&gt;    &#125;,  &#125;&#125;\n4.HostComponent原生的html标签（completeWork阶段就是从HostComponent开始逆着Fiber输往回return Fiber,并在HostComponent上进行虚拟DOM的diff判断比较props）\nreconcileChildren不同类型的组件更新最后都会调用此方法\n根据props.children生成Fiber子树\n判断Fiber对象是否可以复用\n列表根据key优化\n12345678910111213141516171819202122export function reconcileChildren(  current: Fiber | null,  workInProgress: Fiber,  nextChildren: any,  renderExpirationTime: ExpirationTime,) &#123;  if (current &#x3D;&#x3D;&#x3D; null) &#123;    workInProgress.child &#x3D; mountChildFibers(      workInProgress,      null,      nextChildren,      renderExpirationTime,    );  &#125; else &#123;    workInProgress.child &#x3D; reconcileChildFibers(      workInProgress,      current.child,      nextChildren,      renderExpirationTime,    );  &#125;&#125;\n查看上面两种不同调用的方法引入:\n12345import &#123;  mountChildFibers,  reconcileChildFibers,  cloneChildFibers,&#125; from &#39;.&#x2F;ReactChildFiber&#39;;\n然后去ReactChildFiber.js内查看方法定义：mountChildFibers和reconcileChildFibers方法是一样的，唯一的区别是生成这个方法的时候的一个参数不同\n12export const reconcileChildFibers &#x3D; ChildReconciler(true);export const mountChildFibers &#x3D; ChildReconciler(false);\n这个参数叫shouldTrackSideEffects，他的作用是判断是否要增加一些effectTag，主要是用来优化初次渲染的\n123if (shouldTrackSideEffects &amp;&amp; newFiber.alternate &#x3D;&#x3D;&#x3D; null) &#123;  newFiber.effectTag &#x3D; Placement&#125;\nChildReconciler最终调用的是reconcileChildFibers:\n12345678910function ChildReconciler(shouldTrackSideEffects) &#123;  &#x2F;&#x2F; 省略其他代码  function reconcileChildFibers(    returnFiber: Fiber,    currentFirstChild: Fiber | null,    newChild: any,    expirationTime: ExpirationTime,  ): Fiber | null &#123;&#125;  return reconcileChildFibers;&#125;\nreconcileChildFibers会根据newChild的不同类型进行对应的处理，最终的返回是当前节点的第一个孩子节点，会在performUnitWork中 return 并赋值给nextUnitOfWork。\nchildren的合法类型：\nReactElement，通过createElement和ReactDOM.createPortal创建，$$typeof不同\nstring或者number，abc中div的children就是”abc”\n[// renderAble]数组，每一项都可以是其他合法类型，不能嵌套\nIterator，跟数组类似，只是遍历方式不同\nReact.ConcurrentMode这些内置组件，最终会转换成ReactElement，不同的是ReactElement.type\nreconcileSingleElement &amp; reconcileSinglePortal &amp; reconcileSingleTextNode\nreconcileChildrenArray &amp; reconcileChildrenArray\n","plink":"https://www.hansomezao.com/2019/12/01/note/07-React源码学习-beginWork/"},{"title":"06.React源码学习-任务调度","date":"2019-11-30T08:28:29.000Z","date_formatted":{"ll":"2019年11月30日","L":"2019/11/30","MM-DD":"11-30"},"author":"zao","updated":"2019-11-30T08:28:29.000Z","content":"任务调度任务调度图解：\n\n源码在 react-reconciler 下的 ReactFiberScheduler.js 内：\nscheduleWork:12345678910111213141516171819202122232425262728293031323334353637383940414243function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) &#123;    &#x2F;&#x2F; 更新Fiber及所有子树的expirationTime，    &#x2F;&#x2F; 返回FiberRoot  const root &#x3D; scheduleWorkToRoot(fiber, expirationTime);  if (root &#x3D;&#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; 去掉__DEV__代码    return;  &#125;  if (    !isWorking &amp;&amp;    nextRenderExpirationTime !&#x3D;&#x3D; NoWork &amp;&amp;    expirationTime &gt; nextRenderExpirationTime  ) &#123;    &#x2F;&#x2F; This is an interruption. (Used for performance tracking.)    interruptedBy &#x3D; fiber;    &#x2F;&#x2F; 优先执行高优先级的任务    resetStack();  &#125;  markPendingPriorityLevel(root, expirationTime);  if (    &#x2F;&#x2F; If we&#39;re in the render phase, we don&#39;t need to schedule this root    &#x2F;&#x2F; for an update, because we&#39;ll do it before we exit...    !isWorking ||    isCommitting ||    &#x2F;&#x2F; ...unless this is a different root than the one we&#39;re rendering.    nextRoot !&#x3D;&#x3D; root  ) &#123;    const rootExpirationTime &#x3D; root.expirationTime;    requestWork(root, rootExpirationTime);  &#125;  if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) &#123;    &#x2F;&#x2F; Reset this back to zero so subsequent updates don&#39;t throw.    &#x2F;&#x2F; 防止更新中修改state,无限循环进入更新    nestedUpdateCount &#x3D; 0;    invariant(      false,      &#39;Maximum update depth exceeded. This can happen when a &#39; +        &#39;component repeatedly calls setState inside &#39; +        &#39;componentWillUpdate or componentDidUpdate. React limits &#39; +        &#39;the number of nested updates to prevent infinite loops.&#39;,    );  &#125;&#125;\n\nrequestWork:加入到root调度队列\n判断是否批量更新\n根据expirationTime判断调度类型\n12345678910111213141516171819202122232425function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123;  &#x2F;&#x2F; 处理firstScheduledRoot,lastScheduledRoot,root的expirationTime  addRootToSchedule(root, expirationTime);  if (isRendering) &#123;    &#x2F;&#x2F; 已经开始    return;  &#125;  if (isBatchingUpdates) &#123;    &#x2F;&#x2F; Flush work at the end of the batch.    if (isUnbatchingUpdates) &#123;      &#x2F;&#x2F; ...unless we&#39;re inside unbatchedUpdates, in which case we should      &#x2F;&#x2F; flush it now.      nextFlushedRoot &#x3D; root;      nextFlushedExpirationTime &#x3D; Sync;      performWorkOnRoot(root, Sync, false);    &#125;    return;  &#125;  &#x2F;&#x2F; TODO: Get rid of Sync and use current time?  if (expirationTime &#x3D;&#x3D;&#x3D; Sync) &#123;    performSyncWork();  &#125; else &#123;    scheduleCallbackWithExpirationTime(root, expirationTime);  &#125;&#125;\n\nsetState 是同步的还是异步的？\nsetState本身的方法调用是同步的，但是调用setState并不标志着React的state立马就更新了，这个更新是要根据我们当前的执行环境的上文来判断的如果处于isBatchingUpdates环境下不会同步更新的，另还有异步更新调度也不会同步更新。\nscheduler包（被提到与react-reconciler同级的目录）:维护时间片\n模拟requestIdleCallback(等浏览器把要做的事做完后来调取回调)\n调度列表和超时判断\n主要用到的方法：\n\n1\n\n1function scheduleCallbackWithExpirationTime(root: FiberRoot, expirationTime: ExpirationTime,)&#123;&#125;\n\n异步进行root任务调度就是通过这个方法来做的，这里最主要的就是调用了scheduler的scheduleDeferredCallback方法（在scheduler包中是scheduleWork）\n传入的的是回调函数performAsyncWork，以及一个包含timeout超时事件的对象\n\n2\n\n1function unstable_scheduleCallback(callback, deprecated_options)&#123;&#125;\n\n创建一个调度节点newNode，并按照timoutAt的顺序加入到CallbackNode链表，调用ensureHostCallbackIsScheduled\n这里面的expirationTime是调用时传入的timeoutAt加上当前时间形成的过期时间。\n\n3\n\n1function ensureHostCallbackIsScheduled()&#123;&#125;\n\n如果已经在调用回调了，就 return，因为本来就会继续调用下去，isExecutingCallback在flushWork的时候会被修改为true\n如果isHostCallbackScheduled为false，也就是还没开始调度，那么设为true，如果已经开始了，就直接取消，因为顺序可能变了。\n调用requestHostCallback开始调度\n\n4\n\n1requestHostCallback &#x3D; function(callback, absoluteTimeout)&#123;&#125;\n\n开始进入调度，设置调度的内容，用scheduledHostCallback和timeoutTime这两个全局变量记录回调函数和对应的过期时间\n调用requestAnimationFrameWithTimeout，其实就是调用requestAnimationFrame在加上设置了一个100ms的定时器，防止requestAnimationFrame太久不触发。\n调用回调animtionTick并设置isAnimationFrameScheduled全局变量为true\n\n5\n\n1var animationTick &#x3D; function(rafTime) &#123;&#125;\n\n只要scheduledHostCallback还在就继续调要requestAnimationFrameWithTimeout因为这一帧渲染完了可能队列还没情况，本身也是要进入再次调用的，这边就省去了requestHostCallback在次调用的必要性\n接下去一段代码是用来计算相隔的requestAnimationFrame的时差的，这个时差如果连续两次都小鱼当前的activeFrameTime，说明平台的帧率是很高的，这种情况下会动态得缩小帧时间。\n最后更新frameDeadline，然后如果没有触发idleTick则发送消息\n\n6\n\n123window.addEventListener(&#39;message&#39;, idleTick, false)var idleTick &#x3D; function(event) &#123;&#125;\n\n首先判断postMessage是不是自己的，不是直接返回\n清空scheduledHostCallback和timeoutTime\n获取当前时间，对比frameDeadline，查看是否已经超时了，如果超时了，判断一下任务callback的过期时间有没有到，如果没有到，则重新对这个callback进行一次调度，然后返回。如果到了，则设置didTimeout为true\n接下去就是调用callback了，这里设置isFlushingHostCallback全局变量为true代表正在执行。并且调用callback也就是flushWork并传入didTimeout\n\n7\n\n1function flushWork(didTimeout) &#123;&#125;\n\n先设置isExecutingCallback为true，代表正在调用callback\n设置deadlineObject.didTimeout，在 React 业务中可以用来判断任务是否超时\n如果didTimeout，会一次从firstCallbackNode向后一直执行，知道第一个没过期的任务\n如果没有超时，则依此执行第一个callback，知道帧时间结束为止\n最后清理变量，如果任务没有执行完，则再次调用ensureHostCallbackIsScheduled进入调度\n顺便把Immedia优先级的任务都调用一遍。\n\n8\n\n1function flushFirstCallback() &#123;&#125;\n\n如果当前队列中只有一个回调，清空队列\n调用回调并传入deadline对象，里面有timeRemaining方法通过frameDeadline - now()来判断是否帧时间已经到了\n如果回调有返回内容，把这个返回加入到回调队列\nperformWork:performWork通过两种方式调用:\nperformAsyncWork 异步方式\n异步情况给performWork设置的minExpirationTime是NoWork，并且会判断dl.didTimeout，这个值是指任务的expirationTime是否已经超时，如果超时了，则直接设置newExpirationTimeToWorkOn为当前时间，表示这个任务直接执行就行了，不需要判断是否超过了帧时间\nperformSyncWork 同步方式\n同步方式久比较简单了，设置minExpirationTime为Sync也就是1\nperformWorkOnRoot这里也分为同步和异步两种情况，但是这两种情况的区别其实非常小。\n首先是一个参数的区别，isYieldy在同步的情况下是false，而在异步情况下是true。这个参数顾名思义就是是否可以中断，那么这个区别也就很好理解了。\n第二个区别就是在renderRoot之后判断一下shouldYeild，如果时间片已经用完，则不直接completeRoot，而是等到一下次requestIdleCallback之后再执行。\nrenderRoot 和 completeRoot 分别对应两个阶段：\n渲染阶段\n提交阶段\n渲染阶段可以被打断，而提交阶段不能\nfindHighestPriorityRoot一般情况下我们的 React 应用只会有一个root，所以这里的大部分逻辑其实都不是常见情况。\n循环firstScheduledRoot =&gt; lastScheduledRoot，remainingExpirationTime是root.expirationTime，也就是最早的过期时间。\n如果他是NoWork说明他已经没有任务了，从链表中删除。\n从剩下的中找到expirationTime最小的也就是优先级最高的root然后把他赋值给nextFlushedRoot并把他的expirationTime赋值给nextFlushedExpirationTime这两个公共变量。\n一般来说会直接执行下面这个逻辑\n123456if (root &#x3D;&#x3D;&#x3D; root.nextScheduledRoot) &#123;  &#x2F;&#x2F; This is the only root in the list.  root.nextScheduledRoot &#x3D; null;  firstScheduledRoot &#x3D; lastScheduledRoot &#x3D; null;  break;&#125;\n\nrenderRoot首先是一个判断是否需要初始化变量的判断\n12345678910111213141516if (  expirationTime !&#x3D;&#x3D; nextRenderExpirationTime ||  root !&#x3D;&#x3D; nextRoot ||  nextUnitOfWork &#x3D;&#x3D;&#x3D; null) &#123;  &#x2F;&#x2F; Reset the stack and start working from the root.  resetStack()  nextRoot &#x3D; root  nextRenderExpirationTime &#x3D; expirationTime  nextUnitOfWork &#x3D; createWorkInProgress(    nextRoot.current,    null,    nextRenderExpirationTime,  )  root.pendingCommitExpirationTime &#x3D; NoWork&#125;\n他判断的情况是是否有新的更新进来了。假设这种情况：上一个任务因为时间片用完了而中断了，这个时候nextUnitOfWork是有工作的，这时候如果下一个requestIdleCallback进来了，中途没有新的任务进来，那么这些全局变量都没有变过，root的nextExpirationTimeToWorkOn肯定也没有变化，那么代表是继续上一次的任务。而如果有新的更新进来，则势必nextExpirationTimeToWorkOn或者root会变化，那么肯定需要重置变量\nresetStack如果是被中断的情况，会推出context栈\n然后就进入整体，调用workLoop\n12345678910111213function workLoop(isYieldy) &#123;  if (!isYieldy) &#123;    &#x2F;&#x2F; Flush work without yielding    while (nextUnitOfWork !&#x3D;&#x3D; null) &#123;      nextUnitOfWork &#x3D; performUnitOfWork(nextUnitOfWork)    &#125;  &#125; else &#123;    &#x2F;&#x2F; Flush asynchronous work until the deadline runs out of time.    while (nextUnitOfWork !&#x3D;&#x3D; null &amp;&amp; !shouldYield()) &#123;      nextUnitOfWork &#x3D; performUnitOfWork(nextUnitOfWork)    &#125;  &#125;&#125;\nworkLoop逻辑很简单的，只是判断是否需要继续调用performUnitOfWork\n在workLoop执行完之后，就进入收尾阶段了。\n首先如果didFatal为true，代表有一个无法处理的错误，直接调用onFatal，不commit\n123function onFatal(root) &#123;  root.finishedWork &#x3D; null&#125;\n\n如果nextUnitOfWork !== null，代表任务没有执行完，是yield了，执行onYield\n123function onYield(root) &#123;  root.finishedWork &#x3D; null&#125;\n\n如果以上都没有，说明已经complete整棵树了，如果nextRenderDidError代表有捕获到可处理的错误\n这时候先判断是否有优先级更低的任务，有的话把当前的渲染时间设置进suspendTime，同时调用onSuspend\n如果不符合再判断是否帧时间超时，如果没有超时并且没有root.didError，并且把root.expirationTime设置为Sync，然后调用onSuspend。\n需要注意的是，他们调用onSuspend最后一个参数传递的都是-1，看onSuspend的逻辑可以发现其实什么都不做。什么都不做代表着，他们不会设置root.finishedWork，那么返回到上一层的performWorkOnRoot的时候\n123456789finishedWork &#x3D; root.finishedWorkif (finishedWork !&#x3D;&#x3D; null) &#123;  if (!shouldYield()) &#123;    &#x2F;&#x2F; Still time left. Commit the root.    completeRoot(root, finishedWork, expirationTime)  &#125; else &#123;    root.finishedWork &#x3D; finishedWork  &#125;&#125;\n并不会执行completeRoot也就不会commit，会再返回到performWork找下一个root\n12345678910111213141516171819202122232425262728293031323334353637383940414243function onSuspend(  root: FiberRoot,  finishedWork: Fiber,  suspendedExpirationTime: ExpirationTime,  rootExpirationTime: ExpirationTime,  msUntilTimeout: number,): void &#123;  root.expirationTime &#x3D; rootExpirationTime  if (enableSuspense &amp;&amp; msUntilTimeout &#x3D;&#x3D;&#x3D; 0 &amp;&amp; !shouldYield()) &#123;    &#x2F;&#x2F; Don&#39;t wait an additional tick. Commit the tree immediately.    root.pendingCommitExpirationTime &#x3D; suspendedExpirationTime    root.finishedWork &#x3D; finishedWork  &#125; else if (msUntilTimeout &gt; 0) &#123;    &#x2F;&#x2F; Wait &#96;msUntilTimeout&#96; milliseconds before committing.    root.timeoutHandle &#x3D; scheduleTimeout(      onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),      msUntilTimeout,    )  &#125;&#125;function onTimeout(root, finishedWork, suspendedExpirationTime) &#123;  if (enableSuspense) &#123;    &#x2F;&#x2F; The root timed out. Commit it.    root.pendingCommitExpirationTime &#x3D; suspendedExpirationTime    root.finishedWork &#x3D; finishedWork    &#x2F;&#x2F; Read the current time before entering the commit phase. We can be    &#x2F;&#x2F; certain this won&#39;t cause tearing related to batching of event updates    &#x2F;&#x2F; because we&#39;re at the top of a timer event.    recomputeCurrentRendererTime()    currentSchedulerTime &#x3D; currentRendererTime    if (enableSchedulerTracing) &#123;      &#x2F;&#x2F; Don&#39;t update pending interaction counts for suspense timeouts,      &#x2F;&#x2F; Because we know we still need to do more work in this case.      suspenseDidTimeout &#x3D; true      flushRoot(root, suspendedExpirationTime)      suspenseDidTimeout &#x3D; false    &#125; else &#123;      flushRoot(root, suspendedExpirationTime)    &#125;  &#125;&#125;\n其中scheduleTimeout是不同平台的setTimout\n最后一个判断就是真正的挂起任务了，也就是suquense的情况，其实做的事情跟上面两个差不多，唯一的区别是调用onSuspend的时候最后一个参数肯定是大于等于零的。代表着他是立刻就要commit还是在一个timeout之后再commit。因为我们可以看到onTimeout最后是flushRoot，就是以Sync的方式调用performWork\n如果以上逻辑都没有，那么直接调用onComplete\n12345678function onComplete(  root: FiberRoot,  finishedWork: Fiber,  expirationTime: ExpirationTime,) &#123;  root.pendingCommitExpirationTime &#x3D; expirationTime  root.finishedWork &#x3D; finishedWork&#125;","plink":"https://www.hansomezao.com/2019/11/30/note/06-React源码学习-任务调度/"},{"title":"05.React源码学习-expirationTime","date":"2019-11-29T08:51:29.000Z","date_formatted":{"ll":"2019年11月29日","L":"2019/11/29","MM-DD":"11-29"},"author":"zao","updated":"2019-11-29T08:51:29.000Z","content":"expirationTimeReact 中有两种类型的ExpirationTime，一个是Interactive的，另一种是普通的异步。Interactive的比如说是由事件触发的，那么他的响应优先级会比较高因为涉及到交互。\n源码在 react-reconciler 下的 ReactFiberExpirationTime.js 内：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const UNIT_SIZE &#x3D; 10const MAGIC_NUMBER_OFFSET &#x3D; 2&#x2F;&#x2F; 1 unit of expiration time represents 10ms.function msToExpirationTime(ms) &#123;  &#x2F;&#x2F; Always add an offset so that we don&#39;t clash with the magic number for NoWork.  return ((ms &#x2F; UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET&#125;function expirationTimeToMs(expirationTime) &#123;  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE&#125;function ceiling(num, precision) &#123;  return (((num &#x2F; precision) | 0) + 1) * precision&#125;function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) &#123;  return (    MAGIC_NUMBER_OFFSET +    ceiling(      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs &#x2F; UNIT_SIZE,      bucketSizeMs &#x2F; UNIT_SIZE,    )  )&#125;const LOW_PRIORITY_EXPIRATION &#x3D; 5000const LOW_PRIORITY_BATCH_SIZE &#x3D; 250function computeAsyncExpiration(currentTime) &#123;  return computeExpirationBucket(    currentTime,    LOW_PRIORITY_EXPIRATION,    LOW_PRIORITY_BATCH_SIZE,  )&#125;&#x2F;&#x2F; const HIGH_PRIORITY_EXPIRATION &#x3D; __DEV__ ? 500 : 150;const HIGH_PRIORITY_EXPIRATION &#x3D; 500const HIGH_PRIORITY_BATCH_SIZE &#x3D; 100function computeInteractiveExpiration(currentTime) &#123;  return computeExpirationBucket(    currentTime,    HIGH_PRIORITY_EXPIRATION,    HIGH_PRIORITY_BATCH_SIZE,  )&#125;\n\nceiling函数的(((num / precision) | 0) + 1) * precision类似上取整的操作，以及调用ceiling的参数来源是LOW_PRIORITY_BATCH_SIZE HIGH_PRIORITY_BATCH_SIZE，这么做也许是为了让非常相近的两次更新得到相同的expirationTime，然后在一次更新中完成，相当于一个自动的batchedUpdates。\n","plink":"https://www.hansomezao.com/2019/11/29/note/05-React源码学习-expirationTime/"},{"title":"04.React源码学习-update","date":"2019-11-28T10:26:29.000Z","date_formatted":{"ll":"2019年11月28日","L":"2019/11/28","MM-DD":"11-28"},"author":"zao","updated":"2019-11-28T10:26:29.000Z","content":"update什么是update用于记录组件状态的改变\n存放于updateQueue中\n多个update可以同时存在\n如何创建update源码在 react-reconciler 下的 ReactUpdateQueue.js 内：\n创建update:\n1234567891011121314151617181920export function createUpdate(expirationTime: ExpirationTime): Update&lt;*&gt; &#123;  return &#123;      &#x2F;&#x2F; 更新的过期时间    expirationTime: expirationTime,      &#x2F;&#x2F; export const UpdateState &#x3D; 0;      &#x2F;&#x2F; export const ReplaceState &#x3D; 1;      &#x2F;&#x2F; export const ForceUpdate &#x3D; 2;      &#x2F;&#x2F; export const CaptureUpdate &#x3D; 3;      &#x2F;&#x2F; 指定更新的类型，值为以上几种    tag: UpdateState,      &#x2F;&#x2F; 更新内容，比如&#96;setState&#96;接收的第一个参数    payload: null,      &#x2F;&#x2F; 对应的回调，&#96;setState&#96;，&#96;render&#96;都有    callback: null,      &#x2F;&#x2F; 指向下一个更新    next: null,      &#x2F;&#x2F; 指向下一个&#96;side effect&#96;    nextEffect: null,  &#125;;&#125;\n\n创建updateQueue:\n12345678910111213141516171819export function createUpdateQueue&lt;State&gt;(baseState: State): UpdateQueue&lt;State&gt; &#123;  const queue: UpdateQueue&lt;State&gt; &#x3D; &#123;      &#x2F;&#x2F; 每次操作完更新之后的&#96;state&#96;    baseState,      &#x2F;&#x2F; 队列中的第一个和最后一个&#96;Update&#96;    firstUpdate: null,    lastUpdate: null,      &#x2F;&#x2F; 第一个和最后一个捕获类型的&#96;Update&#96;    firstCapturedUpdate: null,    lastCapturedUpdate: null,      &#x2F;&#x2F; 第一个和最后一个&#96;side effect&#96;    firstEffect: null,    lastEffect: null,      &#x2F;&#x2F; 第一个和最后一个捕获产生的&#96;side effect&#96;    firstCapturedEffect: null,    lastCapturedEffect: null,  &#125;;  return queue;&#125;\n","plink":"https://www.hansomezao.com/2019/11/28/note/04-React源码学习-update/"},{"title":"03.React源码学习-FiberRoot与Fiber","date":"2019-11-27T09:24:29.000Z","date_formatted":{"ll":"2019年11月27日","L":"2019/11/27","MM-DD":"11-27"},"author":"zao","updated":"2019-11-27T09:24:29.000Z","content":"React中的数据结构FiberRoot什么是 FiberRoot？\n整个应用的起点\n包含应用挂载的目标节点\n记录整个应用更新过程的各种信息\n结构如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354type BaseFiberRootProperties &#x3D; &#123;|    &#x2F;&#x2F; root节点，render方法接收的第二个参数  containerInfo: any,    &#x2F;&#x2F; 只有在持久更新中会用到，也就是不支持增量更新的平台，react-dom不会用到  pendingChildren: any,    &#x2F;&#x2F; 当前应用对应的Fiber对象，是Root Fiber  current: Fiber,    &#x2F;&#x2F; 一下的优先级是用来区分    &#x2F;&#x2F; 1) 没有提交(committed)的任务    &#x2F;&#x2F; 2) 没有提交的挂起任务    &#x2F;&#x2F; 3) 没有提交的可能被挂起的任务    &#x2F;&#x2F; 我们选择不追踪每个单独的阻塞登记，为了兼顾性能    &#x2F;&#x2F; The earliest and latest priority levels that are suspended from committing.    &#x2F;&#x2F; 最老和新的在提交的时候被挂起的任务  earliestSuspendedTime: ExpirationTime,  latestSuspendedTime: ExpirationTime,    &#x2F;&#x2F; The earliest and latest priority levels that are not known to be suspended.    &#x2F;&#x2F; 最老和最新的不确定是否会挂起的优先级（所有任务进来一开始都是这个状态）  earliestPendingTime: ExpirationTime,  latestPendingTime: ExpirationTime,    &#x2F;&#x2F; The latest priority level that was pinged by a resolved promise and can    &#x2F;&#x2F; be retried.    &#x2F;&#x2F; 最新的通过一个promise被reslove并且可以重新尝试的优先级  latestPingedTime: ExpirationTime,    &#x2F;&#x2F; 如果有错误被抛出并且没有更多的更新存在，我们尝试在处理错误前同步重新从头渲染    &#x2F;&#x2F; 在&#96;renderRoot&#96;出现无法处理的错误时会被设置为&#96;true&#96;  didError: boolean,    &#x2F;&#x2F; 正在等待提交的任务的&#96;expirationTime&#96;  pendingCommitExpirationTime: ExpirationTime,    &#x2F;&#x2F; 已经完成的任务的FiberRoot对象，如果你只有一个Root，那他永远只可能是这个Root对应的Fiber，或者是null    &#x2F;&#x2F; 在commit阶段只会处理这个值对应的任务  finishedWork: Fiber | null,    &#x2F;&#x2F; 在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout  timeoutHandle: TimeoutHandle | NoTimeout,    &#x2F;&#x2F; 顶层context对象，只有主动调用&#96;renderSubtreeIntoContainer&#96;时才会有用  context: Object | null,  pendingContext: Object | null,    &#x2F;&#x2F; 用来确定第一次渲染的时候是否需要融合  +hydrate: boolean,    &#x2F;&#x2F; 当前root上剩余的过期时间    &#x2F;&#x2F; TODO: 提到renderer里面区处理  nextExpirationTimeToWorkOn: ExpirationTime,    &#x2F;&#x2F; 当前更新对应的过期时间  expirationTime: ExpirationTime,    &#x2F;&#x2F; List of top-level batches. This list indicates whether a commit should be    &#x2F;&#x2F; deferred. Also contains completion callbacks.    &#x2F;&#x2F; TODO: Lift this into the renderer    &#x2F;&#x2F; 顶层批次（批处理任务？）这个变量指明一个commit是否应该被推迟    &#x2F;&#x2F; 同时包括完成之后的回调    &#x2F;&#x2F; 貌似用在测试的时候？  firstBatch: Batch | null,    &#x2F;&#x2F; root之间关联的链表结构  nextScheduledRoot: FiberRoot | null,|&#125;;\n\nFiber什么是Fiber？\n每一个ReactElement对应一个Fiber对象\n记录节点的各种状态\n串联整个应用形成树结构\n结构如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&#x2F;&#x2F; Fiber对应一个组件需要被处理或者已经处理了，一个组件可以有一个或者多个Fibertype Fiber &#x3D; &#123;|    &#x2F;&#x2F; 标记不同的组件类型  tag: WorkTag,    &#x2F;&#x2F; ReactElement里面的key  key: null | string,    &#x2F;&#x2F; ReactElement.type，也就是我们调用&#96;createElement&#96;的第一个参数  elementType: any,    &#x2F;&#x2F; The resolved function&#x2F;class&#x2F; associated with this fiber.    &#x2F;&#x2F; 异步组件resolved之后返回的内容，一般是&#96;function&#96;或者&#96;class&#96;  type: any,    &#x2F;&#x2F; The local state associated with this fiber.    &#x2F;&#x2F; 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）  stateNode: any,    &#x2F;&#x2F; 指向他在Fiber节点树中的&#96;parent&#96;，用来在处理完这个节点之后向上返回  return: Fiber | null,    &#x2F;&#x2F; 单链表树结构    &#x2F;&#x2F; 指向自己的第一个子节点  child: Fiber | null,    &#x2F;&#x2F; 指向自己的兄弟结构    &#x2F;&#x2F; 兄弟节点的return指向同一个父节点  sibling: Fiber | null,  index: number,    &#x2F;&#x2F; ref属性  ref: null | (((handle: mixed) &#x3D;&gt; void) &amp; &#123;_stringRef: ?string&#125;) | RefObject,    &#x2F;&#x2F; 新的变动带来的新的props  pendingProps: any,     &#x2F;&#x2F; 上一次渲染完成之后的props  memoizedProps: any,    &#x2F;&#x2F; 该Fiber对应的组件产生的Update会存放在这个队列里面  updateQueue: UpdateQueue&lt;any&gt; | null,    &#x2F;&#x2F; 上一次渲染的时候的state  memoizedState: any,    &#x2F;&#x2F; 一个列表，存放这个Fiber依赖的context  firstContextDependency: ContextDependency&lt;mixed&gt; | null,    &#x2F;&#x2F; 用来描述当前Fiber和他子树的&#96;Bitfield&#96;    &#x2F;&#x2F; 共存的模式表示这个子树是否默认是异步渲染的    &#x2F;&#x2F; Fiber被创建的时候他会继承父Fiber    &#x2F;&#x2F; 其他的标识也可以在创建的时候被设置    &#x2F;&#x2F; 但是在创建之后不应该再被修改，特别是他的子Fiber创建之前  mode: TypeOfMode,    &#x2F;&#x2F; Effect    &#x2F;&#x2F; 用来记录Side Effect  effectTag: SideEffectTag,    &#x2F;&#x2F; 单链表用来快速查找下一个side effect  nextEffect: Fiber | null,    &#x2F;&#x2F; 子树中第一个side effect  firstEffect: Fiber | null,    &#x2F;&#x2F; 子树中最后一个side effect  lastEffect: Fiber | null,    &#x2F;&#x2F; 代表任务在未来的哪个时间点应该被完成    &#x2F;&#x2F; 不包括他的子树产生的任务  expirationTime: ExpirationTime,    &#x2F;&#x2F; 快速确定子树中是否有不在等待的变化  childExpirationTime: ExpirationTime,    &#x2F;&#x2F; 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber    &#x2F;&#x2F; 我们称他为&#96;current &lt;&#x3D;&#x3D;&gt; workInProgress&#96;    &#x2F;&#x2F; 在渲染完成之后他们会交换位置  alternate: Fiber | null,    &#x2F;&#x2F; 下面是调试相关的，收集每个Fiber和子树渲染时间的  actualDuration?: number,    &#x2F;&#x2F; If the Fiber is currently active in the &quot;render&quot; phase,    &#x2F;&#x2F; This marks the time at which the work began.    &#x2F;&#x2F; This field is only set when the enableProfilerTimer flag is enabled.  actualStartTime?: number,    &#x2F;&#x2F; Duration of the most recent render time for this Fiber.    &#x2F;&#x2F; This value is not updated when we bailout for memoization purposes.    &#x2F;&#x2F; This field is only set when the enableProfilerTimer flag is enabled.  selfBaseDuration?: number,    &#x2F;&#x2F; Sum of base times for all descedents of this Fiber.    &#x2F;&#x2F; This value bubbles up during the &quot;complete&quot; phase.    &#x2F;&#x2F; This field is only set when the enableProfilerTimer flag is enabled.  treeBaseDuration?: number,    &#x2F;&#x2F; Conceptual aliases    &#x2F;&#x2F; workInProgress : Fiber -&gt;  alternate The alternate used for reuse happens    &#x2F;&#x2F; to be the same as work in progress.    &#x2F;&#x2F; __DEV__ only  _debugID?: number,  _debugSource?: Source | null,  _debugOwner?: Fiber | null,  _debugIsCurrentlyTiming?: boolean,|&#125;;\n\n来看看Fiber是如何串联节点的：有如下节点结构：\n\n被Fiber处理成能高效遍历的树形结构后：\n\n","plink":"https://www.hansomezao.com/2019/11/27/note/03-React源码学习-FiberRoot与Fiber/"},{"title":"02.React源码学习-component","date":"2019-11-26T08:23:29.000Z","date_formatted":{"ll":"2019年11月26日","L":"2019/11/26","MM-DD":"11-26"},"author":"zao","updated":"2019-11-26T08:23:29.000Z","content":"ComponentReact.js内是如何引用createElement:\n12345678910&#x2F;&#x2F;首先引入import &#123;Component, PureComponent&#125; from &#39;.&#x2F;ReactBaseClasses&#39;;&#x2F;&#x2F;应用const React &#x3D; &#123;  &#x2F;&#x2F; ...other props  Component,  PureComponent,&#125;;export default React;\n\nComponent代码在同级目录下 ReactBaseClasses.js 内：\n12345678910111213function Component(props, context, updater) &#123;  this.props &#x3D; props;  this.context &#x3D; context;  &#x2F;&#x2F; If a component has string refs, we will assign a different object later.  this.refs &#x3D; emptyObject;  &#x2F;&#x2F; We initialize the default updater but the real one gets injected by the  &#x2F;&#x2F; renderer.  this.updater &#x3D; updater || ReactNoopUpdateQueue;&#125;Component.prototype.forceUpdate &#x3D; function(callback) &#123;  this.updater.enqueueForceUpdate(this, callback, &#39;forceUpdate&#39;);&#125;;\n\n发现一个不常见的api：forceUpdate ：强制刷新组件\n另PureComponent就比Component多了一个isPureReactComponent属性：\n123456789101112131415161718&#x2F;** * Convenience component with default shallow equality check for sCU. *&#x2F;function PureComponent(props, context, updater) &#123;  this.props &#x3D; props;  this.context &#x3D; context;  &#x2F;&#x2F; If a component has string refs, we will assign a different object later.  this.refs &#x3D; emptyObject;  this.updater &#x3D; updater || ReactNoopUpdateQueue;&#125;const pureComponentPrototype &#x3D; (PureComponent.prototype &#x3D; new ComponentDummy());pureComponentPrototype.constructor &#x3D; PureComponent;&#x2F;&#x2F; Avoid an extra prototype jump for these methods.Object.assign(pureComponentPrototype, Component.prototype);pureComponentPrototype.isPureReactComponent &#x3D; true;export &#123;Component, PureComponent&#125;;\n","plink":"https://www.hansomezao.com/2019/11/26/note/02-React源码学习-component/"},{"title":"01.React源码学习-createElement","date":"2019-11-25T03:25:29.000Z","date_formatted":{"ll":"2019年11月25日","L":"2019/11/25","MM-DD":"11-25"},"author":"zao","updated":"2019-11-25T03:25:29.000Z","content":"createElement平时我们在React组件内书写的JSX代码在编译时会被处理成如下:\n\n此效果在 Babel 上实现。\nReact.js内是如何引用createElement:\n12345678910111213141516&#x2F;&#x2F;首先引入import &#123;  createElement,  createFactory,  cloneElement,  isValidElement,&#125; from &#39;.&#x2F;ReactElement&#39;;&#x2F;&#x2F;应用const React &#x3D; &#123;  &#x2F;&#x2F; ...other props  createElement: __DEV__ ? createElementWithValidation : createElement,  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,&#125;;export default React;\n\ncreateElement代码在同级目录下 ReactElement.js 内：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970export function createElement(type, config, children) &#123;  let propName;  &#x2F;&#x2F; Reserved names are extracted  const props &#x3D; &#123;&#125;;  let key &#x3D; null;  let ref &#x3D; null;  let self &#x3D; null;  let source &#x3D; null;  &#x2F;&#x2F; 处理props  if (config !&#x3D; null) &#123;    if (hasValidRef(config)) &#123;      ref &#x3D; config.ref;    &#125;    if (hasValidKey(config)) &#123;      key &#x3D; &#39;&#39; + config.key;    &#125;    self &#x3D; config.__self &#x3D;&#x3D;&#x3D; undefined ? null : config.__self;    source &#x3D; config.__source &#x3D;&#x3D;&#x3D; undefined ? null : config.__source;    &#x2F;&#x2F; Remaining properties are added to a new props object    for (propName in config) &#123;      if (        hasOwnProperty.call(config, propName) &amp;&amp;        !RESERVED_PROPS.hasOwnProperty(propName)      ) &#123;        props[propName] &#x3D; config[propName];      &#125;    &#125;  &#125;  &#x2F;&#x2F; 处理多个children  const childrenLength &#x3D; arguments.length - 2;  if (childrenLength &#x3D;&#x3D;&#x3D; 1) &#123;    props.children &#x3D; children;  &#125; else if (childrenLength &gt; 1) &#123;    const childArray &#x3D; Array(childrenLength);    for (let i &#x3D; 0; i &lt; childrenLength; i++) &#123;      childArray[i] &#x3D; arguments[i + 2];    &#125;    if (__DEV__) &#123;      if (Object.freeze) &#123;        Object.freeze(childArray);      &#125;    &#125;    props.children &#x3D; childArray;  &#125;  &#x2F;&#x2F; defaultProps的处理  if (type &amp;&amp; type.defaultProps) &#123;    const defaultProps &#x3D; type.defaultProps;    for (propName in defaultProps) &#123;      if (props[propName] &#x3D;&#x3D;&#x3D; undefined) &#123;        props[propName] &#x3D; defaultProps[propName];      &#125;    &#125;  &#125;  if (__DEV__) &#123;    if (key || ref) &#123;      const displayName &#x3D; typeof type &#x3D;&#x3D;&#x3D; &#39;function&#39; ? type.displayName || type.name || &#39;Unknown&#39; : type;      if (key) &#123; defineKeyPropWarningGetter(props, displayName); &#125;      if (ref) &#123; defineRefPropWarningGetter(props, displayName); &#125;    &#125;  &#125;  return ReactElement(    type,    key,    ref,    self,    source,    ReactCurrentOwner.current,    props,  );&#125;\nReactElement通过createElement创建，调用该方法需要传入三个参数：\ntype (指代这个ReactElement的类型)\nconfig (ReactElement的属性)\nchildren (ReactElement的内容)\n从如下代码：\n123456if (  hasOwnProperty.call(config, propName) &amp;&amp;  !RESERVED_PROPS.hasOwnProperty(propName)) &#123;  props[propName] &#x3D; config[propName];&#125;\n1234567&#x2F;&#x2F;内嵌propsconst RESERVED_PROPS &#x3D; &#123;  key: true,  ref: true,  __self: true,  __source: true,&#125;;\n可以看出key,ref,__self,__source不会被复到元素的props上去\ncreateElement最后返回了一个ReactElement，ReactElement会返回一个对象代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940const ReactElement &#x3D; function(type, key, ref, self, source, owner, props) &#123;  const element &#x3D; &#123;    &#x2F;&#x2F; This tag allows us to uniquely identify this as a React Element    $$typeof: REACT_ELEMENT_TYPE,    &#x2F;&#x2F; Built-in properties that belong on the element    type: type,    key: key,    ref: ref,    props: props,    &#x2F;&#x2F; Record the component responsible for creating this element.    _owner: owner,  &#125;;  if (__DEV__) &#123;    element._store &#x3D; &#123;&#125;;    Object.defineProperty(element._store, &#39;validated&#39;, &#123;      configurable: false,      enumerable: false,      writable: true,      value: false,    &#125;);    Object.defineProperty(element, &#39;_self&#39;, &#123;      configurable: false,      enumerable: false,      writable: false,      value: self,    &#125;);    Object.defineProperty(element, &#39;_source&#39;, &#123;      configurable: false,      enumerable: false,      writable: false,      value: source,    &#125;);    if (Object.freeze) &#123;      Object.freeze(element.props);      Object.freeze(element);    &#125;  &#125;  return element;&#125;;\nReactElement只是一个用来承载信息的容器，他会告诉后续的操作这个节点的以下信息：\ntype类型，用于判断如何创建节点\nkey和ref这些特殊信息\nprops新的属性内容\n$$typeof 用来标识element是什么类型,用于确定是否属于ReactElement\n","plink":"https://www.hansomezao.com/2019/11/25/note/01-React源码学习-createElement/"},{"title":"正则表达式","date":"2019-11-20T08:40:03.000Z","date_formatted":{"ll":"2019年11月20日","L":"2019/11/20","MM-DD":"11-20"},"author":"zao","updated":"2019-11-20T08:40:03.000Z","content":"第一部分 基础知识一、正则申明方式1、构造函数方式1var reg = new RegExp('\\d', 'gi');\n\n● 通过 new 构造一个正则表达式对象，其中第一个参数 ‘\\d’ 是正则内容，第二个参数 ‘gi’ 是修饰符。两个参数皆为字符串类型\n● 修饰符的作用是对匹配过程进行限定\n● 修饰符有三种：i, g, m，可以同时出现，没有顺序（即 gi 与 ig 一样），请参考下方说明\n\n修饰符说明\n\ni忽略大小写匹配\n\ng全局匹配，即是匹配一个后继续匹配，直到结束\n\nm多行匹配，即是遇到换行后不停止匹配，直到结束\n说明： ● [a-z] 表示从小写字母a到小写字母z之间的任意字符(含a和z)，下文会有详细说明 ● + 表示至少出现一次 ● \\n 在js中表示换行 ● ^[a-z] 表示以任意小写字母开头的行\n123456789101112131415161718192021'aBcd efg'.match(/[a-z]+/);// [\"a\"]'aBcd efg'.match(/[a-z]+/i);// [\"aBcd\"]'aBcd efg'.match(/[a-z]+/g);// [\"a\", \"cd\", \"efg\"]'aBcd efg'.match(/[a-z]+/gi);// [\"aBcd\", \"efg\"]'aB\\ncd\\n efg'.match(/^[a-z]+/m);// [\"a\"]'aB\\ncd\\n efg'.match(/^[a-z]+/g);// [\"a\"]'aB\\ncd\\n efg'.match(/^[a-z]+/gm);// [\"a\", \"cd\"]// 注意不是 [\"a\", \"cd\", \"efg\"]\n\n2、字面量方式相比较上一种方式，这一种更为常见，上面示例也都使用了这种方式\n1var reg = /\\d/gi;\n\n两个斜线内为正则的内容，后面可以跟修饰符，与第一种构造函数方式相比更简洁，缺点是正则内容不能拼接，对于大多数场景俩说足够了\n二、正则相关符号1、方括号 [] 用法用于查找方括号内的任意字符：\n\n在这里插入图片描述\n注意： 1）^ 在 [] 内开始位置及正则双斜线开始位置有特殊含义，其他位置表示 ^ 字符本身\n● // 正则开头位置表示以某某开头的字符串，如下表示以大写或小写字母开头的且连续为字母的字符串：\n12'adobe 2016'.match(/^[a-zA-Z]+/);// [\"adobe\"]\n\n● 在正则 或 匹配中(即 | 匹配)，表示 或者以某某字符开始的字符串，如下表示匹配 连续数字 或 以小写字母开头且连续为小写字母的字符串，所以返回结果包含2016 和 adobe，注意返回结果不是 [“2016”, “adobe”]\n12'adobe2016ps'.match(/\\d+|^[a-z]+/g);// [\"adobe\", \"2016\"]\n\n● 在 [] 内开始位置时，表示不匹配 [] 内除 ^ 以外的所有字符：\n12'adobe'.match(/[^abc]/g);// [\"d\", \"o\", \"e\"]\n\n注： $ 与 ^ 的前两个用法相似，只不过匹配的是以某某字符结尾的字符串，举例：\n1234'adobe 2016'.match(/\\d+|[a-z]+$/g);// [\"2016\"]'adobe'.match(/\\d+|[a-z]+$/g);// [\"adobe\"]\n\n2）- (连字符)表示左边字符的 ASCII 值到右边字符 ASCII 编码值之间及左右字符自身的所有字符\n12'adobe PS 2016'.match(/[a-g]/g);// [\"a\", \"d\", \"b\", \"e\"]\n\n3）- 连字符左侧的字符对应的 ASCII 值一定要小于或等于右侧的字符，否则会报语法错误\n12'adobe'.match(/[z-a]/);// Uncaught SyntaxError: Invalid regular expression: /[z-a]/: Range out of order in character class...\n\n4）如果希望对连字符 - 本身进行匹配，需要用反斜线转义\n12'adobe-2016'.match(/[a-g\\-]/g);// [\"a\", \"d\", \"b\", \"e\", \"-\"]\n\n5）查看 ASCII 表就会发现，大写字母的 ASCII 值是小于小写字母的，因此下面用法会报语法错误\n12'adobe-2016'.match(/[a-Z]/g);// Uncaught SyntaxError: Invalid regular expression: /[a-Z]/: Range out of order in character ...\n\n那么问题来了，如果要表示所有字母，不区分大小写怎么办呢？其实有两种方式： A、第一种是使用修饰符 i，前面提到过。举例：\n12'adobe-PS'.match(/[a-z]/gi);// [\"a\", \"d\", \"o\", \"b\", \"e\", \"P\", \"S\"]\n\nB、第二种是在正则中明确指明大小写字母，举例：\n12'adobe-PS'.match(/[a-zA-Z]/g);// [\"a\", \"d\", \"o\", \"b\", \"e\", \"P\", \"S\"]\n\n返回结果跟第一种一样。当然这个例子有些特殊：匹配了所有大小写字母。当只匹配部分大小写字母的时候只能使用第二种方式，在此就不做示例了，读者可以自己测试\n6）匹配大小字母不能写成 [A-z]，虽然不会报语法错误，但隐式的放大了匹配范围，查看 ASCII 会发现，在大写字母 Z 到小写字母 a 之间还有 [、 \\、 ]、 ^、 _、 ` 这6个字符，因此不能这么写。\n7）想必有同学会问， \\w 不也可以匹配字母么？是的，\\w 确实可以匹配字母，但跟上面说的一样,也隐式的放大了匹配范围，\\w 除了匹配大小字母外还匹配了数字和下划线，即 \\w 与 [A-Za-z0-9_] 等价，当然 A-Z、a-z、0-9(等价于\\d)、_这四组没顺序之分\n2、特殊含义字符● . 匹配任意单个字符，除换行和结束符\n12'1+0.2*2=1.4'.match(/.&#123;2&#125;/g);// [\"1+\", \"0.\", \"2*\", \"2=\", \"1.\"]\n\n● \\w 匹配任意单词字符（数字、字母、下划线），等价于[A-Za-z0-9_]\n12'ad34~!@$ps'.match(/\\w/g);// [\"a\", \"d\", \"3\", \"4\", \"p\", \"s\"]\n\n● \\W 匹配任意单词字符，与\\w相反，等价于[^A-Za-z0-9_]\n12'ad34~!@$ps'.match(/\\W/g);// [\"~\", \"!\", \"@\", \"$\"]\n\n● \\d 匹配数字，等价于 [0-9]\n12'ps6'.match(/\\d/g);// [\"6\"]\n\n● \\D 匹配非数字，等价于 [0-9]\n12'ps6'.match(/\\D/g);// [\"p\", \"s\"]\n\n● \\s 匹配空白字符，主要有(\\n、\\f、\\r、\\t、\\v)，注意’a\\sb’中的\\s依然是字符s，所以’a\\sb’.match(/\\s/g)返回 null\n12'adobe ps'.match(/\\s/g);// [\" \"]\n\n● \\S 匹配非空白字符，与\\s相反\n12'adobe ps'.match(/\\S/g);// [\"a\", \"d\", \"o\", \"b\", \"e\", \"p\", \"s\"]\n\n● \\b 匹配单词边界，注意连续的数字、字母或下划线组成的字符串会认为一个单词\n12'adobe(2016) ps6.4'.match(/\\b(\\w+)/g);// [\"adobe\", \"2016\", \"ps6\", \"4\"]\n\n● \\B 匹配非单词边界，仔细体会下面的示例与\\b的结果\n12'adobe(2016) ps6.4'.match(/\\B(\\w+)/g);// [\"dobe\", \"016\", \"s6\"]\n\n● \\0 匹配NUL字符\n12'\\0'.match(/\\0/);// [\"NUL\"]\n\n● \\n 匹配换行符（编码：10，newline）\n12'adobe\\nps'.match(/\\n/).index;// 5\n\n● \\f 匹配换页符\n12'adobe\\fps'.match(/\\f/).index;// 5\n\n● \\r 匹配回车符（编码：13，return）\n12'adobe\\rps'.match(/\\r/).index;// 5\n\n● \\t 匹配制表符，键盘tab对应的字符\n12'adobe\\tps'.match(/\\t/).index;// 5\n\n● \\v 匹配垂直制表符\n12'adobe\\vps'.match(/\\v/).index;// 5\n\n● \\xxx 匹配以八进制数xxx规定的字符\n1234'a'.charCodeAt(0).toString(8);// \"141\"'adobe ps'.match(/\\141/g);// [\"a\"]\n\n● \\xdd 匹配以十六进制数dd规定的字符\n1234'a'.charCodeAt(0).toString(16);// \"61\"'adobe ps'.match(/\\x61/g);// [\"a\"]\n\n● \\uxxxx 匹配以十六进制数xxxx规定的 Unicode字符，注意位数不够需要补0\n1234'a'.charCodeAt(0).toString(16);// \"61\"'adobe ps'.match(/\\u0061/g);// [\"a\"]\n\n注意： window系统回车换行符为\\r\\n，linux系统下没有\\r，linux系统通过vi编辑器打开window系统的文本文件时候，经常在行尾出现^M符号，也就是\\r的原因，解析文本的时候需要注意相关判断。\n3、量词说明● n+ 匹配包含至少一个n的字符串\n12'adobe paas'.match(/a+\\w+/g);// [\"adobe\", \"aas\"]\n\n● n* 匹配包含零个或多个n的字符串\n12'ab3 aa12bb'.match(/a*\\d+/g);// [\"3\", \"aa12\"]\n\n● n? 匹配包含零个或一个n的字符串\n12'ab3 aa12bb'.match(/a?\\d+/g);// [\"3\", \"a12\"]\n\n● n{x} 匹配包含连续x个n的字符串\n12'ab3 aa12bb aaa34'.match(/a&#123;2&#125;\\d+/g);// [\"aa12\", \"aa34\"]\n\n● n{x,y} 匹配包含至少连续x个且最多连续y个n的字符串\n12'a3 aaa12bb aaaaaaa34'.match(/a&#123;2,4&#125;\\d+/g);// [\"aaa12\", \"aaaa34\"]\n\n● n{x,} 匹配包含至少连续x个n的字符串\n12'a3 aaa12bbaa4'.match(/a&#123;2,&#125;\\d+/g);// [\"aaa12\", \"aa4\"]\n\n由上可知，以下 表达式1 与 表达式2 等价\n\n表达式1表达式2\n\nn+n{1,}\n\nn*n{0,}\n\nn？n{0,1}\n4、符号说明符号 {}、、$、*、+、?、[]、[]、- 已经在前面介绍过，接下来看下其他特殊字符 ● a|b 匹配包含a或b的字符串\n12'adobe ps13'.match(/([a-g]+l\\d+)/g);// [\"ad\", \"be\", \"13\"]\n\n● / 字面量方式申明正则时的界定符\n12'adobe'.match(/\\w+/);// [\"adobe\"]\n\n● \\ 普通反斜线字符\n12'a\\\\dobe'.match(/\\\\/);// [\"\\\"]\n\n5、小括号 () 用法正则在非全局(g)模式下，通过match方式，返回的数组第一个值整体匹配的字符串，其他值为通过括号分组匹配到的 1）捕获用法 ● 表示对匹配的字符串进行分组\n123'adobe cs9cs10, adobe cs11'.match(/([a-z]+\\d+)+/);// [\"cs9cs10\", \"cs10\"]// 注意&#123;2,&#125;是对 括弧内的匹配 的描述\n\n● 与|一起使用表示选择性\n12\"he is 12. she is 13. it's box\".match(/(it|she|he)\\s+is/g);// [\"he is\", \"she is\"]\n\n● 表示对匹配的字符串捕获\n1234'adobe cs9'.match(/[a-z]+\\d+/);// [\"cs9\"]'adobe cs9'.match(/[a-z]+(\\d+)/);// [\"cs9\", \"9\"]\n\n● 表示对匹配的字符串反向引用，引用从 \\1 开始，从正则左侧第一个左括号（当然要是闭合的括号才行）开始计算，每多一对括号，引用数加一，在非捕获情况下不会加一。但正则比较复杂时，减少引用可以提升匹配性能，关于 非捕获 下方会详细介绍 引用的结果可以通过 构造函数 RegExp 获取，即 RegExp.9\n123456789'Can you can a can as a canner can can a can?'.match(/([cC]an+)\\s+\\1/g);// [\"can can\"]// 注意 `\\1` 等价于正则里的 `([a-z]+)`，即与下面示例相同'Can you can a can as a canner can can a can?'.match(/[cC]an+\\s+[cC]an+/g);// [\"can can\"]// 如果把括弧去掉可以看下结果'Can you can a can as a canner can can a can?'.match(/[cC]an+\\s+\\1/g);// null\n\n2）非捕获用法，以(?)形式出现 ● (?:n ) 表示非捕获组\n123// 不使用括号时'adobe12ps15test'.match(/[a-z]+\\d+[a-z]+/);// [\"adobe12ps\"]\n\n// 使用括号分组\n12345'adobe12ps15test'.match(/[a-z]+(\\d+)([a-z]+)/);// [\"adobe12ps\", \"12\", \"ps\"]'adobe12ps15test'.match(/[a-z]+(?:\\d+)([a-z]+)/);// [\"adobe12ps\", \"ps\"]\n\n// 看起来上面语句不用(?:)也可以得到相同结果，即：\n12'adobe12ps15test'.match(/[a-z]+\\d+([a-z]+)/);// [\"adobe12ps\", \"ps\"]\n\n// 注意，但需求希望匹配字母之间的规则复杂时，如希望匹配字母，且字母之间可以为1或3时，但不需要1和3\n12'adobe11ps15test'.match(/[a-z]+(1|3)+([a-z]+)/);// [\"adobe11ps\", \"1\", \"ps\"]\n\n// 返回中不希望包含数字怎么办，可以使用非捕获\n12'adobe11ps15test'.match(/[a-z]+(?:1|3)+([a-z]+)/);// [\"adobe11ps\", \"ps\"]\n\n● (?=n ) 匹配任何其后紧跟字符n的字符串，但返回中不包含n\n12'adobe12ps15test'.match(/[a-z]+(?=\\d)/g);// [\"adobe\", \"ps\"]\n\n● (?!n ) 匹配任何其后没有紧跟字符n的字符串，返回中不包含n\n12'adobe12ps15test'.match(/[a-z]+(?!\\d)/g);// [\"adob\", \"p\", \"test\"]\n\n● (?&lt;=n ) 匹配任何其前紧跟字符n的字符串，返回中不包含n\n12'adobe12ps15test'.match(/(?&lt;=\\d)[a-z]+/g);// [\"ps\", \"test\"]\n\n● (?&lt;!n ) 匹配任何其前紧跟字符n的字符串，返回中不包含n\n12'adobe12ps15test'.match(/(?&lt;!\\d)[a-z]+/g);// [\"adobe\", \"s\", \"est\"]\n\n3）注意 ● A、如果希望对上面特殊字符本身进行匹配，需要在其前面添加\\进行转移\n1234'11+2=13'.match(/\\d+\\+/g); // [\"11+\"]'(11+2)*2=26'.match(/\\(\\d+\\+\\d+\\)/g); // [\"(11+2)\"]\n\n● B、\\举例\n12345// 注意下面两个表达式返回的结果'path C:\\Windows\\System32'.match(/([a-zA-Z]:\\\\\\w+)/g); // null'path C:\\\\Windows\\\\System32'.match(/([a-zA-Z]:\\\\\\w+)/g); // [\"C:\\Windows\"]\n\n\n说明: 在申明字符串 ‘path C:\\Windows\\System32’ 时，其中的 ‘’ 就已经被当做转移符，既是 ‘\\W’ === ‘W’,所以如果希望申明的字符串中包含反斜线，需要在加一个反斜线转义，即 \\\n\n6、正则相关方法1） RegExp对象相关方法\n\n在这里插入图片描述\n2）String对象相关方法\n\n在这里插入图片描述\n3）replace 具体用法 顾名思义，是字符串替换方法，但用法比较广泛，相信读者已经非常熟悉了。在此就当复习了 A、 基本用法 直接传入字符串进行替换，找到子串后只替换一次，举例：\n123'adobe abc'.replace('b', '_')// \"ado_e abc\"// 注意 第二个 b 没有被替换\n\n如果希望全部替换，可以使用正则表达式并用全局修饰符 g 方式，举例：\n12'adobe abc'.replace(/b/g, '_')// \"ado_e a_c\"\n\nB、 高级用法 第二个参数可以使用 function，其中有三个参数，分别为 匹配的字符串、当前匹配的字符串index值、匹配的源字符串，最终结果根据每次匹配结果进行相应的替换 举例：\n12345678'adobe aacc bbaa'.replace(/a+/g, function(str, index, source)&#123;    if(index &gt; 0)&#123;        return str.toUpperCase();    &#125; else &#123;        return str;    &#125;&#125;);// \"adobe AAcc bbAA\"\n\n第二部分 案例分析一、常见匹配在写正则之前，需要注意以下几点：\n一定要清楚期望的规则是什么，不然无从匹配\n有些正则不只一种写法，要注意简短干练，复杂的正则表达式不仅难懂，而且容易出BUG，性能也不是很好\n正则虽好，可要适度奥。有些字符串处理不一定适合用正则\n1、手机号规则：以1开头第二位为3、5、7、8且长度为11位的数字组合\n12/^1[3578]\\d&#123;9&#125;$/.test(13600001111);// true\n\n2、 字符串提取举例：提取字符串中的数字 分析： 根据对数字的理解，可能为负数，即-?，如果是负数，其后需要是数字且至少一位，即 -?\\d+，小数部分可能有也可能没有，所以需要对小数部分括弧起来用 ? 或 {0, 1}限定，因为.是特殊字符需要转义，于是表达式为：-?\\d+(.\\d+)?\n12'(12.3 - 32.3)*2 = -40'.match(/-?\\d+(\\.\\d+)?/g);// [\"12.3\", \"32.3\", \"2\", \"-40\"]\n\n二、jQuery中的正则片段1、表达式 在jQuery 3.1.2-pre中找到一个解析单标签的正则，如下：\n1/^&lt;([a-z][^\\/\\0&gt;:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?&gt;(?:&lt;\\/\\1&gt;|)$/i\n\n2、分解 乍一看有点懵，其实拆解之后就容易理解了，注意拆解的步骤，通常来说： 1） 第一步可以先看括号 () ，可以将各个小括号及非括号的分成不同部分，如\n1/^&lt;  ([a-z][^\\/\\0&gt;:\\x20\\t\\r\\n\\f]*)  [\\x20\\t\\r\\n\\f]*\\/?&gt;  (?:&lt;\\/\\1&gt;|)  $/i\n\n2） 第二步可以将中括号分开\n1/^&lt;  (  [a-z]  [^\\/\\0&gt;:\\x20\\t\\r\\n\\f]*  )  [\\x20\\t\\r\\n\\f]*  \\/?&gt;  (?:&lt;\\/\\1&gt;|)  $/i\n\n现在是不是已经很清楚了，接下来分解下，就很容易理解了 3、详解 ● 1）^&lt; 很明显在匹配标签左尖括号括号，且以其开始\n● 2）( [a-z] [^\\/\\0&gt;:\\x20\\t\\r\\n\\f]* ) 这个括号有两部分，第一个 [a-z] 没什么好解释，即标签&lt;紧跟的必须为字母，因为全局加了 i(忽略大小写) 修饰符，所以大小写字母都可以；[^\\/\\0&gt;:\\x20\\t\\r\\n\\f]*，及限制标签名必须以字母开始，且第二个字母不能为/ \\0 &gt; : \\20 t \\r \\n \\f的任意多个字符（思考为什么），() 表示对标签的分组，方便取到标签名\n● 3）[\\x20\\t\\r\\n\\f]* 表示可能含有 [\\x20\\t\\r\\n\\f] 这些特殊字符，与前面的 [^\\/\\0&gt;:\\x20\\t\\r\\n\\f]* 相似却不一样，通过这里可以看出&lt;br之后进行回车也能匹配到 ● 4）/?&gt; 能匹配或\n ● 5）(?:&lt;\\/\\1&gt;|) 这里不捕获，并用\\1去反向引用第一个括号的表达式 ([a-z][^\\/\\0&gt;:\\x20\\t\\r\\n\\f]*)。这里的|表示 &lt;/\\1&gt; 可有可无，即：(?:&lt;\\/\\1&gt;|) 与 (?:&lt;\\/\\1&gt;)?匹配结果一样\n","plink":"https://www.hansomezao.com/2019/11/20/note/正则表达式/"},{"title":"restful API","date":"2019-11-10T06:52:21.000Z","date_formatted":{"ll":"2019年11月10日","L":"2019/11/10","MM-DD":"11-10"},"author":"网上收集,来源不明","updated":"2019-11-10T06:52:21.000Z","content":"一、URL 设计1.1 动词 + 宾语RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如，GET /articles这个命令，GET是动词，/articles是宾语。\n动词通常就是五种 HTTP 方法，对应 CRUD 操作。\n\nGET：读取（Read）\nPOST：新建（Create）\nPUT：更新（Update）\nPATCH：更新（Update），通常是部分更新\nDELETE：删除（Delete）\n\n根据 HTTP 规范，动词一律大写。\n1.2 动词的覆盖有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。\n这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。\n\n12POST /api/Person/4 HTTP/1.1  X-HTTP-Method-Override: PUT\n\n上面代码中，X-HTTP-Method-Override指定本次请求的方法是PUT，而不是POST。\n1.3 宾语必须是名词宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。\n\n/getAllCars\n/createNewCar\n/deleteAllRedCars\n\n1.4 复数 URL既然 URL 是名词，那么应该使用复数，还是单数？\n这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。\n为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。\n1.5 避免多级 URL常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。\n\n1GET /authors/12/categories/2\n\n这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。\n更好的做法是，除了第一级，其他级别都用查询字符串表达。\n\n1GET /authors/12?categories=2\n\n下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。\n\n1GET /articles/published\n\n查询字符串的写法明显更好。\n\n1GET /articles?published=true\n\n二、状态码2.1 状态码必须精确客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。\nHTTP 状态码就是一个三位数，分成五个类别。\n\n1xx：相关信息\n2xx：操作成功\n3xx：重定向\n4xx：客户端错误\n5xx：服务器错误\n\n这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。\nAPI 不需要1xx状态码，下面介绍其他四类状态码的精确含义。\n2.2 2xx 状态码200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。\n\nGET: 200 OK\nPOST: 201 Created\nPUT: 200 OK\nPATCH: 200 OK\nDELETE: 204 No Content\n\n上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。\n此外，202 Accepted状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。\n\n12345678HTTP/1.1 202 Accepted&#123;  \"task\": &#123;    \"href\": \"/api/company/job-management/jobs/2130040\",    \"id\": \"2130040\"  &#125;&#125;\n\n2.3 3xx 状态码API 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。\nAPI 用到的3xx状态码，主要是303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是”暂时重定向”，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。\n\n12HTTP/1.1 303 See OtherLocation: /api/orders/12345\n\n2.4 4xx 状态码4xx状态码表示客户端错误，主要有下面几种。\n400 Bad Request：服务器不理解客户端的请求，未做任何处理。\n401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。\n403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。\n404 Not Found：所请求的资源不存在，或不可用。\n405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。\n410 Gone：所请求的资源已从这个地址转移，不再可用。\n415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。\n422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。\n429 Too Many Requests：客户端的请求次数超过限额。\n2.5 5xx 状态码5xx状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。\n500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。\n503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。\n三、服务器回应3.1 不要返回纯本文API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。\n客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。下面是一个例子。\n\n12GET /orders/2 HTTP/1.1 Accept: application/json\n\n3.2 发生错误时，不要返回 200 状态码有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面，就像下面这样。\n\n123456789HTTP/1.1 200 OKContent-Type: application/json&#123;  \"status\": \"failure\",  \"data\": &#123;    \"error\": \"Expected at least two items in list.\"  &#125;&#125;\n\n上面代码中，解析数据体以后，才能得知操作失败。\n这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。\n\n123456789HTTP/1.1 400 Bad RequestContent-Type: application/json&#123;  \"error\": \"Invalid payoad.\",  \"detail\": &#123;     \"surname\": \"This field is required.\"  &#125;&#125;\n\n3.3 提供链接API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。\n举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。\n\n123456789&#123;  ...  \"feeds_url\": \"https://api.github.com/feeds\",  \"followers_url\": \"https://api.github.com/user/followers\",  \"following_url\": \"https://api.github.com/user/following&#123;/target&#125;\",  \"gists_url\": \"https://api.github.com/gists&#123;/gist_id&#125;\",  \"hub_url\": \"https://api.github.com/hub\",  ...&#125;\n\n上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。\nHATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。\n\n12345678910HTTP/1.1 200 OKContent-Type: application/json&#123;  \"status\": \"In progress\",   \"links\": &#123;[    &#123; \"rel\":\"cancel\", \"method\": \"delete\", \"href\":\"/api/status/12345\" &#125; ,    &#123; \"rel\":\"edit\", \"method\": \"put\", \"href\":\"/api/status/12345\" &#125;  ]&#125;&#125;\n","plink":"https://www.hansomezao.com/2019/11/10/note/restfulAPI/"},{"title":"ES6 bilibili（92集之前）","date":"2019-10-18T05:43:24.000Z","date_formatted":{"ll":"2019年10月18日","L":"2019/10/18","MM-DD":"10-18"},"author":"zao","updated":"2019-10-18T05:43:24.000Z","content":"面向过程编程面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。\n面向过程，就是按照我们分析好了的步骤，按照步骤解决问题。\n面向对象编程面向对象是把事物分解成一个个对象，然后由对象之间分工与合作。\n面向对象是以对象功能来划分问题，而不是步骤。\n在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。\n面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。\n面向对象的特性封装性 \n继承性\n多态性\n面向过程与面向对象的优缺点面向过程优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。\n缺点：没有面向对象易维护、易复用、易扩展。\n面向对象优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。\n缺点：性能比面向过程低。\nES6中的类和对象面向对象面向对象更贴近我们的实际生活,可以使用面向对象描述现实世界事物。\n但是事物分为具体的事物和抽象的事物面向对象的思维特点抽取（抽象）对象共用的属性和行为组织（封装）一个类（模板）。\n\n对类进行实例化, 获取类的对象。\n  面向对象编程我们考虑的是有哪些对象，按照面向对象的思维特点，不断的创建对象，使用对象，指挥对象做事情。\n\n对象现实生活中：万物皆对象，对象是一个具体的事物，看得见摸\n得着的实物。例如，一本书、一辆汽车、一个人可以是“对象”，\n一个数据库、一张网页、一个与远程服务器的连接也可以是\n“对象”。\n\n在 JavaScript中，对象是一组无序的相关属性和方法的集合，\n所有的事物都是对象，例如字符串、数值、数组、函数等。对象是由属性和方法组成的：属性：事物的特征，在对象中用属性来表示（常用名词）\n方法：事物的行为，在对象中用方法来表示（常用动词）\n类class在 ES6 中新增加了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象。注意： 类必须使用 new 实例化对象\n类 constructor 构造函数constructor()方法是类的构造函数(默认方法)，用于传递参\n数，返回实例对象，通过new命令生成对象实例时，自动调用\n该方法。\n如果没有显示定义，类内部会自动给我们创建一个constructor() 创建类12345678&lt;!-- 1. 创建一个class，创建一个“明星”类--&gt;class Star&#123;    constructor(uname)&#123;        this.uame &#x2F;&#x2F;指向创建的实例    &#125;&#125; 2.利用类创建对象 new new Star()  &#x2F;&#x2F;只要加了new，自动调用constructor\n通过class关键字创建类，类名习惯性定义首字母大写\n类里面有个constructor()函数，可以接受传过来的参数，同时返回实例对象。\nconstructor函数只要new生成实例时，就会自动调用这个函数；如果我们不写这个函数，类也会自动生成这个函数。\n生成实例new不能省略。\n最后注意语法规范，创建类时，类名后面不要加小括号；生成实例，类名后面加小括号，构造函数不需要加function。 \n类添加方法123456789101112131415161718192021222324&lt;script&gt;    &#x2F;&#x2F; 1. 创建类 class  创建一个 明星类    class Star &#123;        &#x2F;&#x2F; 类的共有属性放到 constructor 里面        constructor(uname, age) &#123;            this.uname &#x3D; uname;            this.age &#x3D; age;        &#125;        sing(song) &#123;            &#x2F;&#x2F; console.log(&#39;我唱歌&#39;);            console.log(this.uname + song);        &#125;    &#125;    &#x2F;&#x2F; 2. 利用类创建对象 new    var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);    var zxy &#x3D; new Star(&#39;张学友&#39;, 20);    console.log(ldh);    console.log(zxy);    &#x2F;&#x2F; (1) 我们类里面所有的函数不需要写function     &#x2F;&#x2F; (2) 多个函数方法之间不需要添加逗号分隔    ldh.sing(&#39;冰雨&#39;);    zxy.sing(&#39;李香兰&#39;);&lt;&#x2F;script&gt;\n类的继承子类通过==extends==可以继承父类的一些属性和方法。  \n注意    \n继承中属性或者方法的查找原则：就近原则。        \n继承中，如果实例化子类输出一个方法，先看子类有没有这\n个方法，如果有就先执行子类的；如果子类中没，就去父类\n中查找，如果有，就执行父类中的这个方法（就近原则）。12345678910111213class Father&#123;   &#x2F;&#x2F; 父类    conostrctor()&#123;            &#125;    money()&#123;        console.log(100)    &#125;&#125; class  Son extends Father &#123;  &#x2F;&#x2F; 子类继承父类    &#125;var son&#x3D;new Son();son.money()\nsuper关键字super 关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数。\n注意子类在构造函数中使用super, 必须放到 this 前面(必须先调用父类的构造方法,在使用子类构造方法)\n123456789101112131415161718class Father &#123;    constructor(x, y) &#123;        this.x &#x3D; x;        this.y &#x3D; y;    &#125;    sum() &#123;        console.log(this.x + this.y);    &#125;&#125;class Son extends Father &#123;    constructor(x, y) &#123;        super(x, y); &#x2F;&#x2F;调用了父类中的构造函数    &#125;&#125;var son &#x3D; new Son(1, 2);var son1 &#x3D; new Son(11, 22);son.sum();son1.sum();\nsuper必须放到this前面\n123456789101112131415161718192021222324252627282930&lt;script&gt;       &#x2F;&#x2F; 父类有加法方法       class Father &#123;           constructor(x, y) &#123;               this.x &#x3D; x;               this.y &#x3D; y;           &#125;           sum() &#123;               console.log(this.x + this.y);           &#125;       &#125;       &#x2F;&#x2F; 子类继承父类加法方法 同时 扩展减法方法       class Son extends Father &#123;           constructor(x, y) &#123;               &#x2F;&#x2F; 利用super 调用父类的构造函数               &#x2F;&#x2F; super 必须在子类this之前调用               super(x, y);               this.x &#x3D; x;               this.y &#x3D; y;           &#125;           subtract() &#123;               console.log(this.x - this.y);           &#125;       &#125;       var son &#x3D; new Son(5, 3);       son.subtract();       son.sum();   &lt;&#x2F;script&gt;\n\n使用类的注意事项在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象。\n类里面的共有属性和方法一定要加this使用。\n类里面的this指向问题：constructor 里面的this指向实例对象，方法里面的this 指向这个方法的调用者。12345678910111213141516171819202122232425262728293031323334353637383940var that;    var _that;    class Star &#123;        constructor(uname, age) &#123;            &#x2F;&#x2F; constructor 里面的this 指向的是 创建的实例对象            that &#x3D; this;            console.log(this);            this.uname &#x3D; uname;            this.age &#x3D; age;            &#x2F;&#x2F; this.sing();            this.btn &#x3D; document.querySelector(&#39;button&#39;);            this.btn.onclick &#x3D; this.sing;        &#125;        sing() &#123;            &#x2F;&#x2F; 这个sing方法里面的this 指向的是 btn             这个按钮,因为这个按钮调用了这个函数            console.log(this);            console.log(that.uname);             &#x2F;&#x2F; that里面存储的是constructor里面的this        &#125;        dance() &#123;            &#x2F;&#x2F; 这个dance里面的this 指向的是实例对象             ldh 因为ldh 调用了这个函数            _that &#x3D; this;            console.log(this);        &#125;    &#125;    var ldh &#x3D; new Star(&#39;刘德华&#39;);    console.log(that &#x3D;&#x3D;&#x3D; ldh);    ldh.dance();    console.log(_that &#x3D;&#x3D;&#x3D; ldh);&#x2F;&#x2F; 1. 在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象&#x2F;&#x2F; 2. 类里面的共有的属性和方法一定要加this使用.\n\n\n\n构造函数构造函数是一种特殊的函数，主要用来初始化对象，即为对\n象成员变量赋初始值，它总与new一起使用。我们可以把对象\n中一些公共的属性和方法抽取出来，然后封装到这个函数里面。在 JS 中，使用构造函数时要注意以下两点：\n构造函数用于创建某一类对象，其首字母要大写\n构造函数要和 new 一起使用才有意义\nnew 在执行时会做四件事情在内存中创建一个新的空对象。\n让 this 指向这个新的对象。\n执行构造函数里面的代码，给这个新对象添加属性和方法。\n返回这个新对象（所以构造函数里面不需要 return ）。\n成员JavaScript的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this上添加。通过这两种方式添加的成员，就分别称为==静态成员==和==实例成员==。\n静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问 。\n实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。1234567891011121314151617181920function Star()&#123;    this.name&#x3D;name    this.age&#x3D;age    this.sing&#x3D;function()&#123;        console.log(SSS)    &#125;&#125;var XXX&#x3D;new Star(&quot;XX&quot;,&quot;YY&quot;)&#x2F;&#x2F;1.实例成员就是构造函数内部通过this添加的成员name age sing 就是实例成员&#x2F;&#x2F; 实例成员只能通过实例化的对象来访问console.log(XXX.name);XXX.sing();&#x2F;&#x2F; console.log(Star.uname);  &#x2F;&#x2F;不可以通过构造函数来访问实例成员&#x2F;&#x2F; 2. 静态成员 在构造函数本身上添加的成员  sex 就是静态成员Star.sex &#x3D; &#39;男&#39;;&#x2F;&#x2F; 静态成员只能通过构造函数来访问console.log(Star.sex);console.log(ldh.sex); &#x2F;&#x2F; 不能通过对象来访问\n构造函数的问题存在浪费内存的问题123456789function Star(uname, age) &#123;    this.uname &#x3D; uname;    this.age &#x3D; age;    this.sing &#x3D; function() &#123;        console.log(&#39;我会唱歌&#39;);    &#125;&#125;var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);var zxy &#x3D; new Star(&#39;张学友&#39;, 19);\n\n构造函数原型 prototype构造函数通过原型分配的函数是所有对象所共享的。JavaScript 规定，每一个构造函数==都有一个 prototype==属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。\n\n我们可以把那些不变的方法，直接定义在 prototype对象上，这样所有对象的实例就可以共享这些方法。\n\n一般情况下，我们把公共属性定义到构造函数里面，公共的方法我们放到原型对象身上。\n\n问答原型是什么 ？一个对象，我们也称为 prototype 为原型对象。\n原型的作用是什么 ？共享方法。\n对象原型  __ proto __对象都会有一个属性 __ proto __ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __ proto __ 原型的存在。\n1234567891011121314151617181920212223&lt;script&gt;        function Star(uname, age) &#123;            this.uname &#x3D; uname;            this.age &#x3D; age;        &#125;                Star.prototype.sing &#x3D; function() &#123;            console.log(&#39;我会唱歌&#39;);        &#125;                var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);        var zxy &#x3D; new Star(&#39;张学友&#39;, 19);        ldh.sing();                console.log(ldh); &#x2F;&#x2F; 对象身上系统自己添加一个         __proto__ 指向我们构造函数的原型对象 prototype                console.log(ldh.__proto__ &#x3D;&#x3D;&#x3D; Star.prototype);        &#x2F;&#x2F; 方法的查找规则: 首先先看ldh 对象身上是否有         sing 方法,如果有就执行这个对象上的sing        &#x2F;&#x2F; 如果没有sing这个方法,因为有__proto__的存在,就        去构造函数原型对象prototype身上去查找sing这个方法    &lt;&#x2F;script&gt;\n\nproto对象原型和原型对象 prototype 是等价的\nproto对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype\nconstructor  构造函数对象原型（ __ proto __）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。\n\nconstructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。\n\n一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个constructor指向原来的构造函数。\n\n构造函数、实例、原型对象三者之间的关系\n1234567891011121314151617181920212223242526272829303132&lt;script&gt;       function Star(uname, age) &#123;           this.uname &#x3D; uname;           this.age &#x3D; age;       &#125;       &#x2F;&#x2F; 很多情况下,我们需要手动的利用constructor        这个属性指回原来的构造函数       &#x2F;&#x2F; Star.prototype.sing &#x3D; function() &#123;       &#x2F;&#x2F;     console.log(&#39;我会唱歌&#39;);       &#x2F;&#x2F; &#125;;       &#x2F;&#x2F; Star.prototype.movie &#x3D; function() &#123;       &#x2F;&#x2F;     console.log(&#39;我会演电影&#39;);       &#x2F;&#x2F; &#125;       Star.prototype &#x3D; &#123;           &#x2F;&#x2F; 如果我们修改了原来的原型对象,给原型对象赋           值的是一个对象,则必须手动的利用constructor指           回原来的构造函数           constructor: Star,           sing: function() &#123;               console.log(&#39;我会唱歌&#39;);           &#125;,           movie: function() &#123;               console.log(&#39;我会演电影&#39;);           &#125;       &#125;       var ldh &#x3D; new Star(&#39;刘德华&#39;, 18);       var zxy &#x3D; new Star(&#39;张学友&#39;, 19);       console.log(Star.prototype);       console.log(ldh.__proto__);       console.log(Star.prototype.constructor);       console.log(ldh.__proto__.constructor);   &lt;&#x2F;script&gt;\n原型链\n只要是对象就有proto 原型, 指向原型对象\n\n我们Star原型对象里面的proto原型指向的是 Object.prototype\n\n我们Object.prototype原型对象里面的proto原型  指向为 null\n\nJavaScript 的成员查找机制(规则)当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。\n如果没有就查找它的原型（也就是 proto指向的 prototype 原型对象）。\n如果还没有就查找原型对象的原型（Object的原型对象）。\n依此类推一直找到 Object 为止（null）。\nproto对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。\n原型对象this指向构造函数中的this指向我们实例对象。\n原型对象里面放的是方法，这个方法里面的this 指向的是 这个方法的调用者，也就是这个实例对象。\n扩展内置对象可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。（原型对象的应用）\n123456789Array.prototype.sum&#x3D;function()&#123;        var sum&#x3D;0        for(i&#x3D;0;i&lt;this.length;i++)&#123;            sum +&#x3D; this[i]        &#125;        return sum    &#125;    var arr&#x3D;[1,2,3]    console.log(arr.sum())\n注意数组和字符串==内置对象==不能以对象的形式追加，因为会覆盖原本的内置方法——Array.prototype = {} ，只能使用Array.prototype.xxx = function(){} 的方式。\n继承ES6之前并没有给我们提供extends继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。\ncall()调用这个函数, 并且修改函数运行时的 this 指向\n1fun.call(thisArg, arg1, arg2, ...)\nthisArg：当前调用函数 this 的指向对象。\n\narg1，arg2：传递的其他参数。\n1234567891011121314151617&lt;script&gt;    function fn(x,y,z)&#123;        console.log(&quot;deadly sleepy&quot;)        console.log(this)        console.log(x+y+z)    &#125;    var o&#x3D;&#123;        think:&quot;want to sleep&quot;    &#125;    var postgraduate&#x3D;&quot;postgraduate&quot;;    var is&#x3D;&quot;is&quot;;    var important&#x3D;&quot;important&quot;    fn.call()    fn.call(o)    fn.call(o,postgraduate,is,important)&lt;&#x2F;script&gt;\n借用构造函数继承父类型属性核心原理：通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。\n  extends属于类的继承，写法是class Son extends Father。  这里是函数  super()是访问和调用父构造函数的方法  call()是继承父构造函数的类和方法\n1234567891011121314&#x2F;&#x2F; 父类function Father(name, age, sex) &#123;  this.name &#x3D; name;  this.age &#x3D; age;  this.sex &#x3D; sex;&#125;&#x2F;&#x2F; 子类function Son(name, age, sex, score) &#123;  Father.call(this, name, age, sex);  &#x2F;&#x2F; 此时父类的 this   指向子类的 this，同时调用这个函数  this.score &#x3D; score;&#125;var s1 &#x3D; new Son(&#39;zs&#39;, 18, &#39;男&#39;, 100);console.dir(s1);\n子类构造函数中通过call将父类构造函数this指向自身，达到继承父类属性目的\n1234567891011121314151617181920212223242526272829303132333435&lt;script&gt;       &#x2F;&#x2F; 借用父构造函数继承属性       &#x2F;&#x2F; 1. 父构造函数       function Father(uname, age) &#123;           &#x2F;&#x2F; this 指向父构造函数的对象实例           this.uname &#x3D; uname;           this.age &#x3D; age;       &#125;       Father.prototype.money &#x3D; function() &#123;           console.log(100000);       &#125;;       &#x2F;&#x2F; 2 .子构造函数        function Son(uname, age, score) &#123;           &#x2F;&#x2F; this 指向子构造函数的对象实例           Father.call(this, uname, age);           this.score &#x3D; score;       &#125;       &#x2F;&#x2F; Son.prototype &#x3D; Father.prototype;        &#x2F;&#x2F;这样直接赋值会有问题,如果修改了子原型对象,父原型      &#x2F;&#x2F;对象也会跟着一起变化       Son.prototype &#x3D; new Father();       &#x2F;&#x2F; 如果利用对象的形式修改了原型对象,别忘了利用       &#x2F;&#x2F;constructor 指回原来的构造函数       Son.prototype.constructor &#x3D; Son;       &#x2F;&#x2F; 这个是子构造函数专门的方法,原型链查找       Son.prototype.exam &#x3D; function() &#123;           console.log(&#39;孩子要考试&#39;);       &#125;       var son &#x3D; new Son(&#39;刘德华&#39;, 18, 100);       console.log(son);       console.log(Father.prototype);       console.log(Son.prototype.constructor);   &lt;&#x2F;script&gt;\n一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。核心原理： \n\n将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类()  \n\n本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象\n\n将子类的 constructor 从新指向子类的构造函数\n\n类的本质class本质还是function（简单认为，构造函数的另外一种写法）；\n类的所有方法都定义在类的prototype属性上；\n类创建的实例,里面也有proto指向类的prototype原型对象；\n所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已；\n所以ES6的类其实就是语法糖；\n语法糖:语法糖就是一种便捷写法。简单理解,有两种方法可以实现同样的功能,但是一种写法更加清晰、方便,那么这个方法就是语法糖。\nES6之前通过 ==构造函数+ 原型实现面向对象== 编程\n构造函数有原型对象prototype；\n构造函数原型对象prototype 里面有constructor 指向构造函数本身；\n构造函数可以通过原型对象添加方法；\n构造函数创建的实例对象有proto原型指向构造函数的原型对象。\nES6通过 ==类== 实现面向对象编程\n1234567891011121314151617181920212223&lt;script&gt;    class Star &#123;                &#125;    console.log(typeof Star);    &#x2F;&#x2F; 1. 类的本质其实还是一个函数我们也可以简单的认为    &#x2F;&#x2F;类就是构造函数的另外一种写法    &#x2F;&#x2F; (1) 类有原型对象prototype     console.log(Star.prototype);    &#x2F;&#x2F; (2) 类原型对象prototype 里面有constructor 指向类本身    console.log(Star.prototype.constructor);    &#x2F;&#x2F; (3)类可以通过原型对象添加方法    Star.prototype.sing &#x3D; function() &#123;        console.log(&#39;冰雨&#39;);    &#125;    var ldh &#x3D; new Star();    console.dir(ldh);    &#x2F;&#x2F; (4) 类创建的实例对象有__proto__ 原型指向 类的原型对象    console.log(ldh.__proto__ &#x3D;&#x3D;&#x3D; Star.prototype);    i &#x3D; i + 1;    i++&lt;&#x2F;script&gt;\n\nES5新增方法数组方法迭代(遍历)方法：      forEach()、map()、filter()、some()、every()；\nforEach()array.forEach(function(value, index, array))\n1. value每一个数组元素\n2. index每一个数组元素的索引号\n3. array数组本身123456var arr &#x3D; [1, 2, 3]arr.forEach(function (value, index, array) &#123;    console.log(&#39;每个数组元素&#39; + value);    console.log(&#39;每个数组元素的索引号&#39; + index);    console.log(&#39;数组本身&#39; + array);&#125;)\n\nfilter()array.filter(function(value, index, array))\n1. value每一个数组元素\n2. index每一个数组元素的索引号\n3. array数组本身filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于==筛选数组==。\n注意它直接返回一个==新==数组\n1234567var arr &#x3D; [12, 66, 4, 88, 3, 7];&#x2F;&#x2F;newAArr接收返回的数组var newArr &#x3D; arr.filter(function (value, index) &#123;    &#x2F;&#x2F; return value &gt;&#x3D; 20;    return value % 2 &#x3D;&#x3D;&#x3D; 0;&#125;);console.log(newArr);\n\nsome()array.some(function(value, index, array))\n1. value每一个数组元素\n2. index每一个数组元素的索引号\n3. array数组本身some() 方法用于检测数组中的元素是否满足指定条件。即查找数组中是否有满足条件的元素。\n注意它==返回值是布尔值==， 如果查找到这个元素， 就返回true，  如果查找不到就返回false。\n如果找到第一个满足条件的元素，则终止循环，不在继续查找。\n1. filter()查找到满足条件的元素后，返回的是一个数组， \n而且是把所有满足条件的元素返回回来。\n2. some()查找满足条件的元素是否存在，返回的是一个布尔\n值，查找到第一个满足条件的元素就终止循环。some()和forEach的区别在forEach() 和filter() 里面 return 不会终止迭代。\n在some()里面遇到 return true 就是终止遍历，迭代效率更高。\n12345678910var arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;];&#x2F;&#x2F; 1. forEach迭代 遍历arr.forEach(function(value) &#123;    if (value &#x3D;&#x3D; &#39;green&#39;) &#123;        console.log(&#39;找到了该元素&#39;);&#x2F;&#x2F;         return true; &#x2F;&#x2F; 在forEach 里面 return 不会终止迭代    &#125;    console.log(11);&#125;)\n12345678910&#x2F;&#x2F; 如果查询数组中唯一的元素, 用some方法更合适,arr.some(function (value) &#123;    if (value &#x3D;&#x3D; &#39;green&#39;) &#123;        console.log(&#39;找到了该元素&#39;);        return true; &#x2F;&#x2F;  在some 里面 遇到 return true         &#x2F;&#x2F;就是终止遍历 迭代效率更高    &#125;    console.log(11);&#125;);\n12345678arr.filter(function (value) &#123;    if (value &#x3D;&#x3D; &#39;green&#39;) &#123;        console.log(&#39;找到了该元素&#39;);        return true; &#x2F;&#x2F; filter 里面 return 不会终止迭代    &#125;    console.log(11);&#125;);\n字符串方法trim()trim() 方法会从一个字符串的两端删除空白字符。       \ntrim() 方法并不影响原字符串本身，它返回的是一个新的字符串。\n解决表单提交用户输入空格的问题。\n对象方法Object.keys()用于获取对象自身所有的属性\nObject.keys(对象参数名)效果类似 for…in\n返回一个由==属性名==组成的==数组==\nObject.defineProperty()定义对象中新属性或修改原有的属性。(了解)\nObject.defineProperty(obj, prop, descriptor)obj：必需。目标对象 。\nprop：必需。需要定义或修改的属性的名字。\ndescriptor：必需。目标属性所拥有的特性。\n第三个参数 descriptor 说明：以对象形式 { } 书写\nvalue: 设置属性的值。默认为undefined；\nwritable: 值是否可以重写。true | false  ，默认为false；\nenumerable: 目标属性是否可以被枚举（能不能被遍历）。true | false  ，默认为 false；\nconfigurable: 目标属性是否可以被删除或是否可以再次修改特性， true | false  ，默认为false。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#x2F;&#x2F; Object.defineProperty() 定义新属性或修改原有的属性   var obj &#x3D; &#123;       id: 1,       pname: &#39;小米&#39;,       price: 1999   &#125;;   Object.defineProperty(obj, &#39;num&#39;, &#123;       value: 1000,       enumerable: true   &#125;);   console.log(obj);   Object.defineProperty(obj, &#39;price&#39;, &#123;       value: 9.9   &#125;);   console.log(obj);   Object.defineProperty(obj, &#39;id&#39;, &#123;       &#x2F;&#x2F; 如果值为false 不允许修改这个属性值 默认值也是false       writable: false,   &#125;);   obj.id &#x3D; 2;   console.log(obj);   Object.defineProperty(obj, &#39;address&#39;, &#123;       value: &#39;中国山东蓝翔技校xx单元&#39;,       writable: false,       &#x2F;&#x2F; enumerable 如果值为false 则不允许遍历, 默认的值是 false       enumerable: false,       &#x2F;&#x2F; configurable 如果为false 则不允许删除这个属性        &#x2F;&#x2F;不允许再修改第三个参数里面的特性 默认为false       configurable: false   &#125;);   console.log(obj);   console.log(Object.keys(obj));   delete obj.address;   console.log(obj);   delete obj.pname;   console.log(obj);   Object.defineProperty(obj, &#39;address&#39;, &#123;       value: &#39;中国山东蓝翔技校xx单元&#39;,       &#x2F;&#x2F; 如果值为false 不允许修改这个属性值 默认值也是false       writable: true,       &#x2F;&#x2F; enumerable 如果值为false 则不允许遍历, 默认的值是 false       enumerable: true,       &#x2F;&#x2F; configurable 如果为false 则不允许删除以及这个属性        不允许再修改第三个参数里面的特性默认为false       configurable: true   &#125;);   console.log(obj.address);&#x2F;&#x2F;不允许再修改第三个参数里面的特性\n\n函数进阶函数的定义和调用函数的定义方式函数声明方式 function 关键字 (命名函数)\nfunction fn(){};函数表达式 (匿名函数)\nvar fun =function(){};new Function()   \nvar fn = new Function(&apos;参数1&apos;,&apos;参数2&apos;..., &apos;函数体&apos;)Function 里面参数都必须是字符串格式\n第三种方式执行效率低，也不方便书写，因此较少使用\n所有函数都是 Function 的实例(对象)  \n函数也属于对象\n\n函数的调用方式普通函数\nfunction fn() {\n    console.log(&apos;人生的巅峰&apos;);\n}对象的方法\nvar o = {\n    sayHi: function() {\n        console.log(&apos;人生的巅峰&apos;);\n\n    }\n}\no.sayHi();构造函数\nfunction Star() {};\nnew Star();绑定事件函数\nbtn.onclick = function() {};   // 点击了按钮就可以调用这个函数定时器函数\nsetInterval(function() {}, 1000);  \n//这个函数是定时器自动1秒钟调用一次立即执行函数\n(function() {\n        console.log(&apos;人生的巅峰&apos;);\n    })();\n    // 立即执行函数是自动调用\n两种写法\n( function () {} ) ()\n( function () {} () )this函数内 this 的指向调用方式的不同决定了this 的指向不同，一般指向调用者。调用方式 | this指向—|—普通函数调用 | window对象方法调用 | 对象构造函数调用 | 实例对象；原型对象里的this也指向实例对象绑定事件调用 | 绑定事件的对象定时器函数调用 | window立即执行函数调用 | window\n改变函数内部 this 指向常用的有 bind()、call()、apply() 三种方法。\ncall 方法call() 方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。\nfun.call(thisArg, arg1, arg2, ...)thisArg：在 fun 函数运行时指定的 this 值\narg1，arg2：传递的其他参数\n返回值就是函数的返回值，因为它就是调用函数\n因此当我们想改变this指向，同时想调用这个函数的时候，可以使用 call，比如继承。\napply 方法apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。\nfun.apply(thisArg, [argsArray])thisArg：在fun函数运行时指定的 this 值\nargsArray：传递的值，必须包含在数组里面\n返回值就是函数的返回值，因为它就是调用函数\n因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值\n不用指向对象时，可以写null\n1234567var arr &#x3D; [1, 66, 3, 99, 4];var arr1 &#x3D; [&#39;red&#39;, &#39;pink&#39;];&lt;!--var max &#x3D; Math.max.apply(null, arr);--&gt;&lt;!--写null可能会出现问题，详见严格模式章节--&gt;var max &#x3D; Math.max.apply(Math, arr);var min &#x3D; Math.min.apply(Math, arr);console.log(max, min);\n\nbind()方法bind() 方法不会调用函数。但是能改变函数内部this指向。\nfun.bind(thisArg, arg1, arg2, ...) thisArg：在 fun 函数运行时指定的 this 值；\narg1，arg2：传递的其他参数；\n返回由指定的this值和初始化参数改造的原函数拷贝。当我们只是想改变this指向，并且不想调用这个函数的时候，可以使用 bind。\n不会调用原来的函数，可以改变原来函数内部的this 指向\n返回的是原函数改变this之后产生的新函数；\n如果有的函数我们不需要立即调用，但是又想改变这个函数内部的this指向此时用bind；\n我们有一个按钮,当我们点击了之后，就禁用这个按钮，3秒钟之后开启这个按钮。12345678910111213143. bind()  绑定 捆绑的意思 var o &#x3D; &#123;     name: &#39;andy&#39; &#125;; function fn(a, b) &#123;     console.log(this);     console.log(a + b); &#125;; var f &#x3D; fn.bind(o, 1, 2); f();\n123456789101112131415161718192021222324252627282930    &#x2F;&#x2F; 1. 不会调用原来的函数       可以改变原来函数内部的this 指向    &#x2F;&#x2F; 2. 返回的是原函数改变this之后产生的新函数    &#x2F;&#x2F; 3. 如果有的函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind    &#x2F;&#x2F; 4. 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮&lt;button&gt;点击&lt;&#x2F;button&gt;&lt;button&gt;点击&lt;&#x2F;button&gt;&lt;button&gt;点击&lt;&#x2F;button&gt;&lt;script&gt;    &#x2F;&#x2F; var btn1 &#x3D; document.querySelector(&#39;button&#39;);    &#x2F;&#x2F; btn1.onclick &#x3D; function() &#123;    &#x2F;&#x2F;     this.disabled &#x3D; true; &#x2F;&#x2F; 这个this 指向的是 btn 这个按钮    &#x2F;&#x2F;     &#x2F;&#x2F; var that &#x3D; this;    &#x2F;&#x2F;     setTimeout(function() &#123;    &#x2F;&#x2F;         &#x2F;&#x2F; that.disabled &#x3D; false; &#x2F;&#x2F; 定时器函数里面的this 指向的是window    &#x2F;&#x2F;         this.disabled &#x3D; false; &#x2F;&#x2F; 此时定时器函数里面的this 指向的是btn    &#x2F;&#x2F;     &#125;.bind(this), 3000); &#x2F;&#x2F; 这个this 指向的是btn 这个对象    &#x2F;&#x2F; &#125;            var btns &#x3D; document.querySelectorAll(&#39;button&#39;);    for (var i &#x3D; 0; i &lt; btns.length; i++) &#123;        btns[i].onclick &#x3D; function() &#123;            this.disabled &#x3D; true;            setTimeout(function() &#123;                this.disabled &#x3D; false;            &#125;.bind(this), 2000);        &#125;    &#125;&lt;&#x2F;script&gt;\ncall()    apply()     bind() 总结相同点都可以改变this指向\n区别点call和apply会调用函数，并且改变函数内部this指向；\ncall 和 apply 传递的参数不一样，call 传递参数 aru1, aru2…形式 。 apply 必须数组形式[arg]\nbind  不会调用函数, 可以改变函数内部this指向.\n主要应用场景call 经常做继承. \napply 经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值\nbind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. \n严格模式什么是严格模式JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，即在严格的条件下运行 JS 代码。\n严格模式在 IE10以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。\n严格模式对正常的 JavaScript 语义做了一些更改： \n消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。\n消除代码运行的一些不安全之处，保证代码运行的安全。\n提高编译器效率，增加运行速度。\n禁用了在 ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的Javascript做好铺垫。比如一些保留字如：class, enum, export, extends, import,super不能做变量名\n开启严格模式严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。\n为脚本开启严格模式为整个脚本文件开启严格模式，需要在==所有语句之前放一个特定语句“use strict”;（或‘use strict’;）。==\n&lt;!--为整个脚本文件开启严格模式--&gt;\n&lt;script&gt;\n　　&quot;use strict&quot;;\n　　console.log(&quot;这是严格模式。&quot;);\n&lt;/script&gt;因为”use strict”加了引号，所以老版本的浏览器会把它当作一行普通字符串而忽略。\n==有的 script 基本是严格模式，有的script脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他 script 脚本文件。==\n&lt;script&gt;\n  (function (){\n　　　　&quot;use strict&quot;;\n　　　　function fn() {}\n　  })();\n&lt;/script&gt;为函数开启严格模式要给某个函数开启严格模式，需要把“use strict”;  (或 ‘use strict’; ) 声明放在函数体所有语句之前。\nfunction fn(){\n&lt;!--将 &quot;usestrict&quot;放在函数体的第一行，则整个函数以 &quot;严格模式&quot; 运行。--&gt;\n　　&quot;use strict&quot;;\n　　这里面的代码按照严格模式执行\n}\nfunction fun(){\n    这里面还是按照普通模式执行\n}严格模式中的变化变量规定在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用var 命令声明，然后再使用。\n严禁删除已经声明变量。例如，delete x; 语法是错误的。\n严格模式下 this 指向问题严格模式下全局作用域中的函数this指向的是undefined；\n未开启严格模式构造函数时不加new也可以调用，当普通函数，this指向全局对象；严格模式下，必须加new。如果不加new，会报错undefined。给它赋值，会报错；\nnew 实例化的构造函数指向创建的对象实例；\n定时器 this 还是指向 window ；\n事件、对象还是指向调用者。\n函数变化函数不能有重名的参数。\n函数必须声明在顶层。新版本的 JavaScript 会引入“块级作用域”（ES6中已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数。\n更多严格模式要求参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\n高阶函数高阶函数是对其他函数进行操作的函数，它==接收函数作为参数==或==将函数作为返回值输出。==\n&lt;!--接收函数作为参数--&gt;\n&lt;script&gt;\n    function fn(callback){\n      callback&amp;&amp;callback();\n    }\n    fn(function(){alert(&apos;hi&apos;)}\n&lt;/script&gt;\n\n&lt;!--将函数作为返回值输出--&gt;\n&lt;script&gt;\n    function fn(){\n        return function() {}\n    }\n     fn();\n&lt;/script&gt;闭包变量作用域变量根据作用域的不同分为两种：全局变量和局部变量。\n函数内部可以使用全局变量。\n函数外部不可以使用局部变量。\n当函数执行完毕，本作用域内的局部变量会销毁。\n什么是闭包\n闭包（closure）指有权访问另一个函数作用域中变量的函数。—–  《JavaScript 高级程序设计》\n\n简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。 \n闭包的作用提问：我们怎么能在fn()函数外面访问fn()中的局部变量 num 呢\n12345678910&lt;script&gt; function fn() &#123;　　　　    var num &#x3D; 10;　　　　    return function &#123;　　　　　　         console.log(num); &#x2F;&#x2F; 10         　　　　     &#125;  &#125;  var f &#x3D; fn();  f()&lt;&#x2F;script&gt;\n\n\n闭包作用：延伸变量的作用范围。内存泄漏：是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。\n递归什么是递归？如果==一个函数在内部可以调用其本身==，那么这个函数就是递归函数；\n简单理解:函数内部自己调用自己, 这个函数就是递归函数；\n递归函数的作用和循环效果一样；\n==由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return。==\n浅拷贝和深拷贝浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用。只是把地址拷贝了，被拷贝的数据修改，浅拷贝得到的也会被修改。\n深拷贝拷贝多层, 每一级别的数据都会拷贝.\n浅拷贝Object.assign(target, ...sources)     \n属于es6 新增方法，可以浅拷贝。深拷贝这块的代码建议配合视频理解。\n12345678910111213141516171819202122232425262728293031323334353637383940 &lt;script&gt;    &#x2F;&#x2F; 深拷贝拷贝多层, 每一级别的数据都会拷贝.    var obj &#x3D; &#123;        id: 1,        name: &#39;andy&#39;,        msg: &#123;            age: 18        &#125;,        color: [&#39;pink&#39;, &#39;red&#39;]    &#125;;    var o &#x3D; &#123;&#125;;    &#x2F;&#x2F; 封装函数     function deepCopy(newobj, oldobj) &#123;        for (var k in oldobj) &#123;            &#x2F;&#x2F; 判断我们的属性值属于那种数据类型            &#x2F;&#x2F; 1. 获取属性值  oldobj[k]            var item &#x3D; oldobj[k];            &#x2F;&#x2F; 2. 判断这个值是否是数组            if (item instanceof Array) &#123;                newobj[k] &#x3D; [];                deepCopy(newobj[k], item)            &#125; else if (item instanceof Object) &#123;                &#x2F;&#x2F; 3. 判断这个值是否是对象                newobj[k] &#x3D; &#123;&#125;;                deepCopy(newobj[k], item)            &#125; else &#123;                &#x2F;&#x2F; 4. 属于简单数据类型                newobj[k] &#x3D; item;            &#125;        &#125;    &#125;    deepCopy(o, obj);    console.log(o);    var arr &#x3D; [];    console.log(arr instanceof Object);    o.msg.age &#x3D; 20;    console.log(obj);&lt;&#x2F;script&gt;\n其余深拷贝操作可以参照以下链接的内容及其评论。\n\nhttps://www.cnblogs.com/renbo/p/9563050.html\n\n正则表达式因之前接触过正则表达式，个人觉得用时百度就可以了，视频讲的内容理解就够了。\n特点1. 灵活性、逻辑性和功能性非常的强。\n2. 可以迅速地用极简单的方式达到字符串的复杂控制。\n3. 对于刚接触的人来说，比较晦涩难懂。比如验证邮箱：\n^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n4. 实际开发,一般都是直接复制写好的正则表达式。 \n但是要求会使用正则表达式并且根据实际情况修改正则\n表达式。比如用户名:  /^[a-z0-9_-]{3,16}$/ 创建正则表达式在 JavaScript 中，可以通过两种方式创建一个正则表达式。\n1. 通过调用 RegExp 对象的构造函数创建\nvar 变量名 = new RegExp(/表达式/); 2. 通过字面量创建\nvar 变量名 = /表达式/; 以上    // 注释中间放表达式就是正则字面量，更推荐使用第二种\n测试正则表达式 testtest() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。\nregexObj.test(str) \n\nregexObj 是写的正则表达式\nstr 我们要测试的文本\n就是检测str文本是否符合我们写的正则表达式规范.正则表达式的组成一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。\n特殊字符非常多，可以参考：      \nMDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\njQuery 手册：正则表达式部分\n正则测试工具: http://tool.oschina.net/regex\n边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符。\n\n边界符说明\n\n^表示匹配行首的文本（以谁开始）\n\n$表示匹配行尾的文本（以谁结束）\n如果 ^ 和 $ 在一起，表示必须是精确匹配。\n字符类字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。\n1. []  方括号多选一\n\n/[abc]/.test(&apos;andy&apos;)     // true\n\n字符串只要包含 abc 中任意一个字符都会返回 true 。\n\n\n/^[abc]$/.test(&apos;andy&apos;)     // true\n\n三选一 只有是a 或者是 b  或者是c 这三个字母才返回 true2. [-]  方括号内部 范围符 -var reg = /^[a-z]$/; //\n\n26个英文字母任何一个字母返回 true  - 表示的是a 到z 的范围  \n\n方括号内部加上 - 表示范围，这里表示 a 到 z 26个英文字母都可以。3. 字符组合var reg = /^[a-zA-Z0-9_-]$/; \n\n26个英文字母(大写和小写都可以)任何一个字母返回 true  4. [^]  方括号内部 取反符^如果中括号里面有^ 表示取反的意思 不要与 边界符 ^ 混淆\n\nvar reg = /^[^a-zA-Z0-9_-]$/;量词符量词符用来设定某个模式出现的次数。\n\nheader 1header 2\n\n*重复 0 次 或者 更多次\n\n+重复一次 或者 更多次\n\n?重复 0 次 或 一次\n\n{n}重复 n 次\n\n{n,}重复 n 次 或者 更多次\n\n{n,m}重复 n 次 到 m 次\n括号总结\n符号属性意义\n\n大括号量词符。里面表示重复次数\n\n中括号字符集合。匹配方括号中的任意字符.\n\n小括号表示优先级。\n中括号：字符集合。匹配方括号中的任意字符。\n\nvar reg = /^[abc]$/;\n&lt;!--a 也可以 b 也可以 c 可以  a ||b || c--&gt;\n\n\n\n大括号：量词符。里面表示重复次数。\n\nvar reg = /^abc{3}$/; \n&lt;!--它只是让c重复三次   abccc--&gt;\n\n\n小括号：表示优先级。\n\nvar reg = /^(abc){3}$/; \n&lt;!--它是让abcc重复三次--&gt;replace替换str.replace(regexp|substr, newSubStr|function)\n参数定义\n\nregexp (pattern)一个RegExp对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。\n\nsubstr (pattern)一个将被 newSubStr替换的 字符串。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。\n\nnewSubStr (replacement)用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。\n\nfunction (replacement)一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。\n正则表达式参数/表达式/[switch]switch（也称修饰符）：按照什么样的模式来匹配，有三种值：        \ng：全局匹配\ni：忽略大小写\ngi：全局匹配+忽略大小写\n用多个敏感词使用 “ | ”  \n例如：/第一个|第二个/123456789101112131415161718&lt;body&gt;    &lt;textarea name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; cols&#x3D;&quot;30&quot; rows&#x3D;&quot;10&quot;&gt;&lt;&#x2F;textarea&gt;    &lt;button&gt;submit&lt;&#x2F;button&gt;    &lt;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script&gt;    &#x2F;&#x2F;替换 replace    &#x2F;&#x2F; var str&#x3D;&quot;andy和red&quot;    &#x2F;&#x2F; var newStr&#x3D;str.replace(&quot;andy&quot;,&quot;baby&quot;)    &#x2F;&#x2F; console.log(newStr)    var text &#x3D; document.querySelector(&quot;textarea&quot;)    var btn &#x3D; document.querySelector(&quot;button&quot;)    var div &#x3D; document.querySelector(&#39;div&#39;)    btn.onclick &#x3D; function () &#123;        div.innerHTML &#x3D; text.value.replace(&#x2F;激情|嗯哼&#x2F;g, &#39;**&#39;)    &#125;  &lt;&#x2F;script&gt;","plink":"https://www.hansomezao.com/2019/10/18/note/ES6 bilibili（92集之前）/"},{"title":"ES6 bilibili（92集之后）","date":"2019-10-13T02:42:58.000Z","date_formatted":{"ll":"2019年10月13日","L":"2019/10/13","MM-DD":"10-13"},"author":"zao","updated":"2019-10-13T02:42:58.000Z","content":"ES6的新增语法let关键字let关键字就是用来声明变量的；使用let关键字声明的变量具有块级作用域；\n注意：使用let关键字声明的变量才具有块级作用域，使用var声明的不具有块级作用域特性；\n防止循环变量变成全局变量；\n不存在变量提升；\n暂时性死区；123&lt;!--let关键字就是用来声明变量的--&gt;let a &#x3D; 10;console.log(a);&#x2F;&#x2F; a is not defined\n\n\n12345678910&lt;!--使用let关键字声明的变量具有块级作用域--&gt;\tif (true) &#123;\t    let b &#x3D; 20;    \tconsole.log(b)        if (true) &#123;    \t    let c &#x3D; 30;\t    &#125;\t    console.log(c);\t&#125;\tconsole.log(b)\n\n123456789&lt;!--在一个大括号中,使用let关键字声明的变量才具有块级作用域，var关键字是不具备这个特点的。--&gt;\tif (true) &#123;\t    let num &#x3D; 100;    \tvar abc &#x3D; 200;\t&#125;\tconsole.log(abc);\tconsole.log(num)\n123&lt;!--防止循环变量变成全局变量--&gt;\tfor (let i &#x3D; 0; i &lt; 2; i++) &#123;&#125;\tconsole.log(i)\n123&lt;!--使用let关键字声明的变量没有变量提升--&gt;\tconsole.log(a);\tlet a &#x3D; 100;\n123456&lt;!--使用let关键字声明的变量具有暂时性死区特性--&gt;var tmp &#x3D; 123;if (true) &#123;     tmp &#x3D; &#39;abc&#39;;    let tmp; &#x2F;&#x2F;tmp is not defined&#125;\n\n经典面试题面试题1 var12345678var arr &#x3D; [];for (var i &#x3D; 0; i &lt; 2; i++) &#123;    arr[i] &#x3D; function () &#123;        console.log(i);     &#125;&#125;arr[0]();arr[1]();\n\n经典面试题图解：此题的关键点在于变量i是全局的，函数执\n行时输出的都是全局作用域下的i值。面试题2 let12345678let arr &#x3D; [];for (let i &#x3D; 0; i &lt; 2; i++) &#123;    arr[i] &#x3D; function () &#123;        console.log(i);     &#125;&#125;arr[0]();arr[1]();\n\n经典面试题图解：此题的关键点在于每次循环都会产生一个块\n级作用域，每个块级作用域中的变量都是不同的，函数执行时\n输出的是自己上一级（循环产生的块级作用域）作用域下的i\n值.const关键字作用：声明常量，常量就是值（内存地址）不能变化的量;具有块级作用域;\n声明常量时必须赋值;\n常量赋值后，值不能修改;\n12345&lt;!--使用const关键字声明的常量具有块级作用域--&gt;if (true) &#123;     const a &#x3D; 10;&#125;console.log(a) &#x2F;&#x2F; a is not defined\n\n\n12&lt;!--&#x2F;使用const关键字声明的常量必须赋初始值--&gt;const PI; &#x2F;&#x2F; Missing initializer in const declaration\n\n12345678&lt;!--常量声明后值不可更改--&gt;const PI &#x3D; 3.14;PI &#x3D; 100;const ary &#x3D; [100, 200];ary[0] &#x3D; 123;&#x2F;&#x2F;（没有更改内存地址）数据可以更改即数据结构内部的值可以更改ary &#x3D; [1, 2] &#x2F;&#x2F;更改的是内存地址，所以数据值本身不可更改console.log(ary);\n\nlet const var的区别使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象。\n使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。\n使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值。\n\nvarletconst\n\n函数级作用域块级作用域块级作用域\n\n变量提升不存在变量提升不存在变量提升\n\n只可更改只可更改值不可更改\n解构赋值ES6中允许从数组中提取值，按照对应位置，对变量赋值。对\n象也可以实现解构。数组解构允许我们按照一一对应的关系从数组中提取值，然后将值赋给变量1234let [a, b, c] &#x3D; [1, 2, 3];console.log(a)console.log(b)console.log(c)\n如果解构不成功，变量的值为undefined。\n12let [foo] &#x3D; [];let [bar, foo] &#x3D; [1];\n对象解构对象解构允许我们使用变量的名字匹配对象的属性，匹配成\n功将对象属性的值赋给变量12345678let person &#x3D; &#123; name: &#39;zhangsan&#39;, age: 20 &#125;; let &#123; name, age &#125; &#x3D; person;console.log(name); &#x2F;&#x2F; &#39;zhangsan&#39; console.log(age); &#x2F;&#x2F; 20let &#123;name: myName, age: myAge&#125; &#x3D; person; &#x2F;&#x2F; myName myAge 属于别名console.log(myName); &#x2F;&#x2F; &#39;zhangsan&#39; console.log(myAge); &#x2F;&#x2F; 20\n\n箭头函数ES6中新增的定义函数的方式，用来简化函数定义语法的。\n书写格式 ： () =&gt; {} 函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号;\n在箭头函数中，如果形参只有一个，形参外面的小括号也可以省略;\n箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this。1234const fn &#x3D; () &#x3D;&gt; &#123;    console.log(123)&#125;fn()\n  函数体中只有一句代码，且代码的执行结果就是返回值，可  以省略大括号。12345678&lt;!--传统函数--&gt;function sum(num1, num2) &#123;     return num1 + num2; &#125;&lt;!--ES6--&gt;const sum &#x3D; (num1, num2) &#x3D;&gt; num1 + num2;const result&#x3D;sum(10,20)\n  在箭头函数中，如果形参只有一个，形参外面的小括号也可以省略.1234function fn (v) &#123;    return v;&#125; const fn &#x3D; v &#x3D;&gt; v;\n  箭头函数不绑定this关键字，箭头函数中的this，指向的是  函数定义位置的上下文this。  也就是说箭头函数被定义在哪里，箭头函数中的this就指向哪里。123456789const obj &#x3D; &#123; name: &#39;张三&#39;&#125; function fn () &#123;     console.log(this);    return () &#x3D;&gt; &#123;         console.log(this)    &#125; &#125; const resFn &#x3D; fn.call(obj); resFn();\n箭头函数面试题12345678var obj &#x3D; &#123;    age: 20,    say: () &#x3D;&gt; &#123;        alert(this.age)    &#125;&#125;obj.say();&#x2F;&#x2F;会alert undefined\n  上方代码中对象不能产生作用域，所以此处的箭头函数被定  义在了全局 作用域下，此时的this指向的是window，window  下没有age属性，所以undefined。\n123456789var age&#x3D;100var obj &#x3D; &#123;    age: 20,    say: () &#x3D;&gt; &#123;        alert(this.age)    &#125;&#125;obj.say();&#x2F;&#x2F;会alert undefined\n\n剩余参数剩余参数语法允许我们将一个不定数量的参数表示为一个数组。箭头函数使用不了传送函数中的arguments；\n(…参数名)：表示接收所有的参数；\n(参数名1,…参数名2)：参数名2，表示结束剩余的所有参数。12345678910111213function sum (first, ...args) &#123;    console.log(first); &#x2F;&#x2F; 10    console.log(args); &#x2F;&#x2F; [20, 30] &#125;sum(10, 20, 30)const sum &#x3D; (...args) &#x3D;&gt; &#123;    let total &#x3D; 0;        args.forEach(item &#x3D;&gt; total +&#x3D; item);        return total;    &#125;;console.log(sum(10, 20));console.log(sum(10, 20, 30));\n剩余参数和解构配合使用\n1234let ary1 &#x3D; [&#39;张三&#39; , &#39;李四&#39;, &#39;王五&#39;];let [s1, ...s2] &#x3D; ary1;console.log(s1)console.log(s2)&#x2F;&#x2F;...s2已经变成了一个数组，存储了&quot;李四&quot;,&quot;王五&quot;\nES6的内置语法扩展Array的扩展方法扩展运算符（展开语法）扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。1234let ary &#x3D; [1, 2, 3];...ary  &#x2F;&#x2F; 1, 2, 3console.log(...ary);    &#x2F;&#x2F; 1 2 3console.log(1, 2, 3)\n\n扩展运算符的应用1. 扩展运算符可以应用于合并数组12345678910&#x2F;&#x2F; 方法一 let ary1 &#x3D; [1, 2, 3]; let ary2 &#x3D; [3, 4, 5];let ary3 &#x3D; [...ary1, ...ary2];&#x2F;&#x2F; 方法二 let ary1 &#x3D; [1, 2, 3];let ary2 &#x3D; [4, 5, 6];ary1.push(...ary2);console.log(ary1)\n2.  利用扩展运算符将伪数组或者可遍历对象转换为真正的数组12345var oDivs &#x3D; document.getElementsByTagName(&#39;div&#39;);console.log(oDivs)var ary &#x3D; [...oDivs];ary.push(&#39;a&#39;);console.log(ary);\n\n构造函数方法：Array.from()1. 将类数组或可遍历对象转换为真正的数组\n2. 该方法还可以接受第二个参数，作用类似于数组的map方\n   法，用来对每个元素进行处理，将处理后的值放入返回的\n   数组。123456789var arrayLike &#x3D; &#123; \t&quot;0&quot;: &quot;张三&quot;,\t&quot;1&quot;: &quot;李四&quot;,\t&quot;2&quot;: &quot;王五&quot;,\t&quot;length&quot;: 3\t&#125;var ary &#x3D; Array.from(arrayLike);console.log(ary)\n12345678var arrayLike &#x3D; &#123;\t&quot;0&quot;: &quot;1&quot;,\t&quot;1&quot;: &quot;2&quot;,\t&quot;length&quot;: 2&#125;var ary &#x3D; Array.from(arrayLike, item &#x3D;&gt; item * 2)console.log(ary)&#x2F;&#x2F;输出处理后的结果。\n实例方法find()用于找出第一个符合条件的数组成员，它的参数是一个回调\n函数，所有数组成员依次执行该回调函数，直到找出第一个\n返回值为true的成员，然后返回该成员。如果没有找到返回\nundefined123456789var ary &#x3D; [&#123;    id: 1,    name: &#39;张三&#39;&#125;, &#123;    id: 2,    name: &#39;李四&#39;&#125;];let target &#x3D; ary.find(item &#x3D;&gt; item.id &#x3D;&#x3D; 3);console.log(target)&#x2F;&#x2F;返回undefined\nfindIndex()返回第一个符合条件的数组成员的位置，如果所有成员都不\n符合条件，则返回-1。123let ary &#x3D; [1, 5, 10, 15];let index &#x3D; ary.findIndex((value, index) &#x3D;&gt; value &gt; 9); console.log(index); &#x2F;&#x2F; 2(第一个符合条件的索引，即10的索引是2)\nincludes()判断某个数组是否包含给定的值，返回布尔值12[1, 2, 3].includes(2) &#x2F;&#x2F; true [1, 2, 3].includes(4) &#x2F;&#x2F; false\n该方法的第二个参数表示搜索的起始位置，默认为0。如果第\n二个参数为负数，则表示倒数（shu）的位置，如果这时它大于数组\n长度（比如第二个参数为-4，但数组长度为3），则会重置为\n从0开始。12[1, 2, 3].includes(3, 3);  &#x2F;&#x2F; false[1, 2, 3].includes(3, -1); &#x2F;&#x2F; true\n\nString 的扩展方法模板字符串ES6新增的创建字符串的方式，使用反引号定义。\n1. 模板字符串中可以解析变量;\n2. 模板字符串中可以换行;\n3. 在模板字符串中可以调用函数。12345let name &#x3D; &#96;张三&#96;;console.log(name)&lt;!--模板字符串中可以解析变量--&gt;let sayHello &#x3D; &#96;Hello, 我的名字叫$&#123;name&#125;&#96;;console.log(sayHello);\n123456789101112&lt;!--模板字符串中可以换行--&gt;&#x2F;&#x2F; let html &#x3D; &#96;        &lt;div&gt;        &lt;span&gt;$&#123;result.name&#125;&lt;&#x2F;span&gt;        &lt;span&gt;$&#123;result.age&#125;&lt;&#x2F;span&gt;        &lt;&#x2F;div&gt;    &#96;;console.log(html);\t\t\t\tconst fn &#x3D; () &#x3D;&gt; &#123;\t\t\treturn &#39;我是fn函数&#39;\t\t&#125;\n1234567&lt;!--在模板字符串中可以调用函数--&gt;const fn &#x3D; () &#x3D;&gt; &#123;    return &#39;我是fn函数&#39;&#125;let html &#x3D; &#96;我是模板字符串 $&#123;fn()&#125;&#96;;console.log(html)\n\nstartsWith() 和 endsWith()includes()：返回布尔值，表示是否找到了参数字符串；\nstartsWith()：表示参数字符串是否在原字符串的头部，返回布尔值；\nendsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值。\n这三个方法都支持第二个参数，表示开始搜索的位置。123456789let str &#x3D; &#39;Hello ECMAScript 2015&#39;;let r1 &#x3D; str.startsWith(&#39;Hello&#39;);console.log(r1);&#x2F;&#x2F; truelet r2 &#x3D; str.endsWith(&#39;2015&#39;);console.log(r2);&#x2F;&#x2F; truelet r2 &#x3D; str.endsWith(&#39;2016&#39;);console.log(r2) &#x2F;&#x2F;false\nrepeat()repeat方法表示将原字符串重复n次，返回一个新字符串。Set 数据结构ES6 提供了新的数据结构——Set。\n1. 它类似于数组，但是成员的值都是唯一的，没有重复的值。\n2. Set本身是一个构造函数，用来生成 Set 数据结构。\n3. Set函数可以接受一个数组作为参数，用来初始化。\n4. Set可以去除数组重复元素。1234567891011const s1 &#x3D; new Set();console.log(s1.size)&#x2F;&#x2F;返回0const s2 &#x3D; new Set([&quot;a&quot;, &quot;b&quot;]);console.log(s2.size)&#x2F;&#x2F;返回2const s3 &#x3D; new Set([&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;]);console.log(s3.size)&#x2F;&#x2F;返回2const ary &#x3D; [...s3];console.log(ary)&#x2F;&#x2F;数组中存储了[&quot;a&quot;,&quot;b&quot;]\n\n实例方法add(value)：添加某个值，返回 Set 结构本身；\ndelete(value)：删除某个值，返回一个布尔值，表示删除是否成功；\nhas(value)：返回一个布尔值，表示该值是否为 Set 的成员；\nclear()：清除所有成员，没有返回值。123456789101112131415161718const s4 &#x3D; new Set();&lt;!--向set结构中添加值 使用add方法--&gt;s4.add(&#39;a&#39;).add(&#39;b&#39;);&#x2F;&#x2F;链式调用console.log(s4.size)&lt;!--从set结构中删除值 用到的方法是delete--&gt;const r1 &#x3D; s4.delete(&#39;c&#39;);console.log(s4.size)console.log(r1);&lt;!--判断某一个值是否是set数据结构中的成员 使用has--&gt;const r2 &#x3D; s4.has(&#39;d&#39;);console.log(r2)&lt;!--清空set数据结构中的值 使用clear方法--&gt;s4.clear();console.log(s4.size);\n\n\n遍历Set 结构的实例与数组一样，也拥有forEach方法，用于对每\n个成员执行某种操作，没有返回值。12345&#x2F;&#x2F; 遍历set数据结构 从中取值const s5 &#x3D; new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);    s5.forEach(value &#x3D;&gt; &#123;    console.log(value)&#125;)","plink":"https://www.hansomezao.com/2019/10/13/note/ES6 bilibili（92集之后）/"}]