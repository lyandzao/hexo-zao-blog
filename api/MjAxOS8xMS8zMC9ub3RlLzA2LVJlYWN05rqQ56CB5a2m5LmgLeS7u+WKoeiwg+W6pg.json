{"title":"06.React源码学习-任务调度","date":"2019-11-30T08:28:29.000Z","date_formatted":{"ll":"2019年11月30日","L":"2019/11/30","MM-DD":"11-30"},"author":"zao","link":"2019/11/30/note/06-React源码学习-任务调度","tags":["react源码"],"categories":["note"],"updated":"2019-11-30T08:28:29.000Z","content":"<h2 id=\"任务调度\">任务调度<a href=\"#任务调度\" title=\"任务调度\"></a></h2><p>任务调度图解：</p>\n<p><img src=\"https://s2.ax1x.com/2020/03/01/3gntAO.jpg\" class=\"φcy\" alt=\"Event Loop\"></p>\n<p>源码在 react-reconciler 下的 ReactFiberScheduler.js 内：</p>\n<h5 id=\"schedulework\">scheduleWork:<a href=\"#schedulework\" title=\"scheduleWork:\"></a></h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 更新Fiber及所有子树的expirationTime，</span><br><span class=\"line\">    &#x2F;&#x2F; 返回FiberRoot</span><br><span class=\"line\">  const root &#x3D; scheduleWorkToRoot(fiber, expirationTime);</span><br><span class=\"line\">  if (root &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 去掉__DEV__代码</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (</span><br><span class=\"line\">    !isWorking &amp;&amp;</span><br><span class=\"line\">    nextRenderExpirationTime !&#x3D;&#x3D; NoWork &amp;&amp;</span><br><span class=\"line\">    expirationTime &gt; nextRenderExpirationTime</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; This is an interruption. (Used for performance tracking.)</span><br><span class=\"line\">    interruptedBy &#x3D; fiber;</span><br><span class=\"line\">    &#x2F;&#x2F; 优先执行高优先级的任务</span><br><span class=\"line\">    resetStack();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  markPendingPriorityLevel(root, expirationTime);</span><br><span class=\"line\">  if (</span><br><span class=\"line\">    &#x2F;&#x2F; If we&#39;re in the render phase, we don&#39;t need to schedule this root</span><br><span class=\"line\">    &#x2F;&#x2F; for an update, because we&#39;ll do it before we exit...</span><br><span class=\"line\">    !isWorking ||</span><br><span class=\"line\">    isCommitting ||</span><br><span class=\"line\">    &#x2F;&#x2F; ...unless this is a different root than the one we&#39;re rendering.</span><br><span class=\"line\">    nextRoot !&#x3D;&#x3D; root</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    const rootExpirationTime &#x3D; root.expirationTime;</span><br><span class=\"line\">    requestWork(root, rootExpirationTime);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Reset this back to zero so subsequent updates don&#39;t throw.</span><br><span class=\"line\">    &#x2F;&#x2F; 防止更新中修改state,无限循环进入更新</span><br><span class=\"line\">    nestedUpdateCount &#x3D; 0;</span><br><span class=\"line\">    invariant(</span><br><span class=\"line\">      false,</span><br><span class=\"line\">      &#39;Maximum update depth exceeded. This can happen when a &#39; +</span><br><span class=\"line\">        &#39;component repeatedly calls setState inside &#39; +</span><br><span class=\"line\">        &#39;componentWillUpdate or componentDidUpdate. React limits &#39; +</span><br><span class=\"line\">        &#39;the number of nested updates to prevent infinite loops.&#39;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"requestwork\">requestWork:<a href=\"#requestwork\" title=\"requestWork:\"></a></h5><ul><li>加入到root调度队列</li>\n<li>判断是否批量更新</li>\n<li>根据expirationTime判断调度类型</li>\n</ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 处理firstScheduledRoot,lastScheduledRoot,root的expirationTime</span><br><span class=\"line\">  addRootToSchedule(root, expirationTime);</span><br><span class=\"line\">  if (isRendering) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 已经开始</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (isBatchingUpdates) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Flush work at the end of the batch.</span><br><span class=\"line\">    if (isUnbatchingUpdates) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; ...unless we&#39;re inside unbatchedUpdates, in which case we should</span><br><span class=\"line\">      &#x2F;&#x2F; flush it now.</span><br><span class=\"line\">      nextFlushedRoot &#x3D; root;</span><br><span class=\"line\">      nextFlushedExpirationTime &#x3D; Sync;</span><br><span class=\"line\">      performWorkOnRoot(root, Sync, false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; TODO: Get rid of Sync and use current time?</span><br><span class=\"line\">  if (expirationTime &#x3D;&#x3D;&#x3D; Sync) &#123;</span><br><span class=\"line\">    performSyncWork();</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    scheduleCallbackWithExpirationTime(root, expirationTime);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>setState 是同步的还是异步的？</p>\n<p>setState本身的方法调用是同步的，但是调用setState并不标志着React的state立马就更新了，这个更新是要根据我们当前的执行环境的上文来判断的如果处于<code>isBatchingUpdates</code>环境下不会同步更新的，另还有异步更新调度也不会同步更新。</p>\n<h5 id=\"scheduler包（被提到与react-reconciler同级的目录）\">scheduler包（被提到与react-reconciler同级的目录）:<a href=\"#scheduler包（被提到与react-reconciler同级的目录）\" title=\"scheduler包（被提到与react-reconciler同级的目录）:\"></a></h5><ul><li>维护时间片</li>\n<li>模拟requestIdleCallback(等浏览器把要做的事做完后来调取回调)</li>\n<li>调度列表和超时判断</li>\n</ul><p>主要用到的方法：</p>\n<blockquote>\n<p>1</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function scheduleCallbackWithExpirationTime(root: FiberRoot, expirationTime: ExpirationTime,)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>异步进行root任务调度就是通过这个方法来做的，这里最主要的就是调用了scheduler的scheduleDeferredCallback方法（在scheduler包中是scheduleWork）</p>\n<p>传入的的是回调函数performAsyncWork，以及一个包含timeout超时事件的对象</p>\n<blockquote>\n<p>2</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unstable_scheduleCallback(callback, deprecated_options)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个调度节点newNode，并按照timoutAt的顺序加入到CallbackNode链表，调用ensureHostCallbackIsScheduled</p>\n<p>这里面的expirationTime是调用时传入的timeoutAt加上当前时间形成的过期时间。</p>\n<blockquote>\n<p>3</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ensureHostCallbackIsScheduled()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果已经在调用回调了，就 return，因为本来就会继续调用下去，isExecutingCallback在flushWork的时候会被修改为true</p>\n<p>如果isHostCallbackScheduled为false，也就是还没开始调度，那么设为true，如果已经开始了，就直接取消，因为顺序可能变了。</p>\n<p>调用requestHostCallback开始调度</p>\n<blockquote>\n<p>4</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requestHostCallback &#x3D; function(callback, absoluteTimeout)&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开始进入调度，设置调度的内容，用scheduledHostCallback和timeoutTime这两个全局变量记录回调函数和对应的过期时间</p>\n<p>调用requestAnimationFrameWithTimeout，其实就是调用requestAnimationFrame在加上设置了一个100ms的定时器，防止requestAnimationFrame太久不触发。</p>\n<p>调用回调animtionTick并设置isAnimationFrameScheduled全局变量为true</p>\n<blockquote>\n<p>5</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var animationTick &#x3D; function(rafTime) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只要scheduledHostCallback还在就继续调要requestAnimationFrameWithTimeout因为这一帧渲染完了可能队列还没情况，本身也是要进入再次调用的，这边就省去了requestHostCallback在次调用的必要性</p>\n<p>接下去一段代码是用来计算相隔的requestAnimationFrame的时差的，这个时差如果连续两次都小鱼当前的activeFrameTime，说明平台的帧率是很高的，这种情况下会动态得缩小帧时间。</p>\n<p>最后更新frameDeadline，然后如果没有触发idleTick则发送消息</p>\n<blockquote>\n<p>6</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&#39;message&#39;, idleTick, false)</span><br><span class=\"line\"></span><br><span class=\"line\">var idleTick &#x3D; function(event) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先判断postMessage是不是自己的，不是直接返回</p>\n<p>清空scheduledHostCallback和timeoutTime</p>\n<p>获取当前时间，对比frameDeadline，查看是否已经超时了，如果超时了，判断一下任务callback的过期时间有没有到，如果没有到，则重新对这个callback进行一次调度，然后返回。如果到了，则设置didTimeout为true</p>\n<p>接下去就是调用callback了，这里设置isFlushingHostCallback全局变量为true代表正在执行。并且调用callback也就是flushWork并传入didTimeout</p>\n<blockquote>\n<p>7</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function flushWork(didTimeout) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先设置isExecutingCallback为true，代表正在调用callback</p>\n<p>设置deadlineObject.didTimeout，在 React 业务中可以用来判断任务是否超时</p>\n<p>如果didTimeout，会一次从firstCallbackNode向后一直执行，知道第一个没过期的任务</p>\n<p>如果没有超时，则依此执行第一个callback，知道帧时间结束为止</p>\n<p>最后清理变量，如果任务没有执行完，则再次调用ensureHostCallbackIsScheduled进入调度</p>\n<p>顺便把Immedia优先级的任务都调用一遍。</p>\n<blockquote>\n<p>8</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function flushFirstCallback() &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果当前队列中只有一个回调，清空队列</p>\n<p>调用回调并传入deadline对象，里面有timeRemaining方法通过frameDeadline - now()来判断是否帧时间已经到了</p>\n<p>如果回调有返回内容，把这个返回加入到回调队列</p>\n<h5 id=\"performwork\">performWork:<a href=\"#performwork\" title=\"performWork:\"></a></h5><p><code>performWork</code>通过两种方式调用:</p>\n<ul><li>performAsyncWork 异步方式</li>\n</ul><p>异步情况给performWork设置的minExpirationTime是NoWork，并且会判断dl.didTimeout，这个值是指任务的expirationTime是否已经超时，如果超时了，则直接设置newExpirationTimeToWorkOn为当前时间，表示这个任务直接执行就行了，不需要判断是否超过了帧时间</p>\n<ul><li>performSyncWork 同步方式</li>\n</ul><p>同步方式久比较简单了，设置minExpirationTime为Sync也就是1</p>\n<h5 id=\"performworkonroot\">performWorkOnRoot<a href=\"#performworkonroot\" title=\"performWorkOnRoot\"></a></h5><p>这里也分为同步和异步两种情况，但是这两种情况的区别其实非常小。</p>\n<p>首先是一个参数的区别，isYieldy在同步的情况下是false，而在异步情况下是true。这个参数顾名思义就是是否可以中断，那么这个区别也就很好理解了。</p>\n<p>第二个区别就是在renderRoot之后判断一下shouldYeild，如果时间片已经用完，则不直接completeRoot，而是等到一下次requestIdleCallback之后再执行。</p>\n<p><code>renderRoot</code> 和 <code>completeRoot</code> 分别对应两个阶段：</p>\n<ul><li>渲染阶段</li>\n<li>提交阶段</li>\n</ul><p>渲染阶段可以被打断，而提交阶段不能</p>\n<h5 id=\"findhighestpriorityroot\">findHighestPriorityRoot<a href=\"#findhighestpriorityroot\" title=\"findHighestPriorityRoot\"></a></h5><p>一般情况下我们的 React 应用只会有一个root，所以这里的大部分逻辑其实都不是常见情况。</p>\n<p>循环<code>firstScheduledRoot =&gt; lastScheduledRoot</code>，<code>remainingExpirationTime</code>是<code>root.expirationTime</code>，也就是最早的过期时间。</p>\n<p>如果他是<code>NoWork</code>说明他已经没有任务了，从链表中删除。</p>\n<p>从剩下的中找到<code>expirationTime</code>最小的也就是优先级最高的<code>root</code>然后把他赋值给<code>nextFlushedRoot</code>并把他的<code>expirationTime</code>赋值给<code>nextFlushedExpirationTime</code>这两个公共变量。</p>\n<p>一般来说会直接执行下面这个逻辑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (root &#x3D;&#x3D;&#x3D; root.nextScheduledRoot) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; This is the only root in the list.</span><br><span class=\"line\">  root.nextScheduledRoot &#x3D; null;</span><br><span class=\"line\">  firstScheduledRoot &#x3D; lastScheduledRoot &#x3D; null;</span><br><span class=\"line\">  break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"renderroot\">renderRoot<a href=\"#renderroot\" title=\"renderRoot\"></a></h5><p>首先是一个判断是否需要初始化变量的判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (</span><br><span class=\"line\">  expirationTime !&#x3D;&#x3D; nextRenderExpirationTime ||</span><br><span class=\"line\">  root !&#x3D;&#x3D; nextRoot ||</span><br><span class=\"line\">  nextUnitOfWork &#x3D;&#x3D;&#x3D; null</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; Reset the stack and start working from the root.</span><br><span class=\"line\">  resetStack()</span><br><span class=\"line\">  nextRoot &#x3D; root</span><br><span class=\"line\">  nextRenderExpirationTime &#x3D; expirationTime</span><br><span class=\"line\">  nextUnitOfWork &#x3D; createWorkInProgress(</span><br><span class=\"line\">    nextRoot.current,</span><br><span class=\"line\">    null,</span><br><span class=\"line\">    nextRenderExpirationTime,</span><br><span class=\"line\">  )</span><br><span class=\"line\">  root.pendingCommitExpirationTime &#x3D; NoWork</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>他判断的情况是是否有新的更新进来了。假设这种情况：上一个任务因为时间片用完了而中断了，这个时候nextUnitOfWork是有工作的，这时候如果下一个requestIdleCallback进来了，中途没有新的任务进来，那么这些全局变量都没有变过，root的nextExpirationTimeToWorkOn肯定也没有变化，那么代表是继续上一次的任务。而如果有新的更新进来，则势必nextExpirationTimeToWorkOn或者root会变化，那么肯定需要重置变量</p>\n<p><code>resetStack</code>如果是被中断的情况，会推出<code>context</code>栈</p>\n<p>然后就进入整体，调用workLoop</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function workLoop(isYieldy) &#123;</span><br><span class=\"line\">  if (!isYieldy) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Flush work without yielding</span><br><span class=\"line\">    while (nextUnitOfWork !&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">      nextUnitOfWork &#x3D; performUnitOfWork(nextUnitOfWork)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Flush asynchronous work until the deadline runs out of time.</span><br><span class=\"line\">    while (nextUnitOfWork !&#x3D;&#x3D; null &amp;&amp; !shouldYield()) &#123;</span><br><span class=\"line\">      nextUnitOfWork &#x3D; performUnitOfWork(nextUnitOfWork)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>workLoop逻辑很简单的，只是判断是否需要继续调用performUnitOfWork</p>\n<p>在workLoop执行完之后，就进入收尾阶段了。</p>\n<p>首先如果didFatal为true，代表有一个无法处理的错误，直接调用onFatal，不commit</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function onFatal(root) &#123;</span><br><span class=\"line\">  root.finishedWork &#x3D; null</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果nextUnitOfWork !== null，代表任务没有执行完，是yield了，执行onYield</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function onYield(root) &#123;</span><br><span class=\"line\">  root.finishedWork &#x3D; null</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果以上都没有，说明已经complete整棵树了，如果nextRenderDidError代表有捕获到可处理的错误</p>\n<p>这时候先判断是否有优先级更低的任务，有的话把当前的渲染时间设置进suspendTime，同时调用onSuspend</p>\n<p>如果不符合再判断是否帧时间超时，如果没有超时并且没有root.didError，并且把root.expirationTime设置为Sync，然后调用onSuspend。</p>\n<p>需要注意的是，他们调用onSuspend最后一个参数传递的都是-1，看onSuspend的逻辑可以发现其实什么都不做。什么都不做代表着，他们不会设置root.finishedWork，那么返回到上一层的performWorkOnRoot的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">finishedWork &#x3D; root.finishedWork</span><br><span class=\"line\">if (finishedWork !&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">  if (!shouldYield()) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Still time left. Commit the root.</span><br><span class=\"line\">    completeRoot(root, finishedWork, expirationTime)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    root.finishedWork &#x3D; finishedWork</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并不会执行completeRoot也就不会commit，会再返回到performWork找下一个root</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function onSuspend(</span><br><span class=\"line\">  root: FiberRoot,</span><br><span class=\"line\">  finishedWork: Fiber,</span><br><span class=\"line\">  suspendedExpirationTime: ExpirationTime,</span><br><span class=\"line\">  rootExpirationTime: ExpirationTime,</span><br><span class=\"line\">  msUntilTimeout: number,</span><br><span class=\"line\">): void &#123;</span><br><span class=\"line\">  root.expirationTime &#x3D; rootExpirationTime</span><br><span class=\"line\">  if (enableSuspense &amp;&amp; msUntilTimeout &#x3D;&#x3D;&#x3D; 0 &amp;&amp; !shouldYield()) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Don&#39;t wait an additional tick. Commit the tree immediately.</span><br><span class=\"line\">    root.pendingCommitExpirationTime &#x3D; suspendedExpirationTime</span><br><span class=\"line\">    root.finishedWork &#x3D; finishedWork</span><br><span class=\"line\">  &#125; else if (msUntilTimeout &gt; 0) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; Wait &#96;msUntilTimeout&#96; milliseconds before committing.</span><br><span class=\"line\">    root.timeoutHandle &#x3D; scheduleTimeout(</span><br><span class=\"line\">      onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),</span><br><span class=\"line\">      msUntilTimeout,</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function onTimeout(root, finishedWork, suspendedExpirationTime) &#123;</span><br><span class=\"line\">  if (enableSuspense) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; The root timed out. Commit it.</span><br><span class=\"line\">    root.pendingCommitExpirationTime &#x3D; suspendedExpirationTime</span><br><span class=\"line\">    root.finishedWork &#x3D; finishedWork</span><br><span class=\"line\">    &#x2F;&#x2F; Read the current time before entering the commit phase. We can be</span><br><span class=\"line\">    &#x2F;&#x2F; certain this won&#39;t cause tearing related to batching of event updates</span><br><span class=\"line\">    &#x2F;&#x2F; because we&#39;re at the top of a timer event.</span><br><span class=\"line\">    recomputeCurrentRendererTime()</span><br><span class=\"line\">    currentSchedulerTime &#x3D; currentRendererTime</span><br><span class=\"line\"></span><br><span class=\"line\">    if (enableSchedulerTracing) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; Don&#39;t update pending interaction counts for suspense timeouts,</span><br><span class=\"line\">      &#x2F;&#x2F; Because we know we still need to do more work in this case.</span><br><span class=\"line\">      suspenseDidTimeout &#x3D; true</span><br><span class=\"line\">      flushRoot(root, suspendedExpirationTime)</span><br><span class=\"line\">      suspenseDidTimeout &#x3D; false</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      flushRoot(root, suspendedExpirationTime)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中scheduleTimeout是不同平台的setTimout</p>\n<p>最后一个判断就是真正的挂起任务了，也就是suquense的情况，其实做的事情跟上面两个差不多，唯一的区别是调用onSuspend的时候最后一个参数肯定是大于等于零的。代表着他是立刻就要commit还是在一个timeout之后再commit。因为我们可以看到onTimeout最后是flushRoot，就是以Sync的方式调用performWork</p>\n<p>如果以上逻辑都没有，那么直接调用onComplete</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function onComplete(</span><br><span class=\"line\">  root: FiberRoot,</span><br><span class=\"line\">  finishedWork: Fiber,</span><br><span class=\"line\">  expirationTime: ExpirationTime,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  root.pendingCommitExpirationTime &#x3D; expirationTime</span><br><span class=\"line\">  root.finishedWork &#x3D; finishedWork</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","prev":{"title":"07.React源码学习-beginWork","link":"2019/12/01/note/07-React源码学习-beginWork"},"next":{"title":"05.React源码学习-expirationTime","link":"2019/11/29/note/05-React源码学习-expirationTime"},"plink":"https://www.hansomezao.com/2019/11/30/note/06-React源码学习-任务调度/","toc":[{"id":"任务调度","title":"任务调度","index":"1"}]}