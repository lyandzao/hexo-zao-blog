{"title":"05.React源码学习-expirationTime","date":"2019-11-29T08:51:29.000Z","date_formatted":{"ll":"2019年11月29日","L":"2019/11/29","MM-DD":"11-29"},"author":"zao","link":"2019/11/29/note/05-React源码学习-expirationTime","tags":["react源码"],"categories":["note"],"updated":"2019-11-29T08:51:29.000Z","content":"<h2 id=\"expirationtime\">expirationTime<a href=\"#expirationtime\" title=\"expirationTime\"></a></h2><p>React 中有两种类型的ExpirationTime，一个是Interactive的，另一种是普通的异步。Interactive的比如说是由事件触发的，那么他的响应优先级会比较高因为涉及到交互。</p>\n<p>源码在 react-reconciler 下的 ReactFiberExpirationTime.js 内：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const UNIT_SIZE &#x3D; 10</span><br><span class=\"line\">const MAGIC_NUMBER_OFFSET &#x3D; 2</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 1 unit of expiration time represents 10ms.</span><br><span class=\"line\">function msToExpirationTime(ms) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; Always add an offset so that we don&#39;t clash with the magic number for NoWork.</span><br><span class=\"line\">  return ((ms &#x2F; UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function expirationTimeToMs(expirationTime) &#123;</span><br><span class=\"line\">  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function ceiling(num, precision) &#123;</span><br><span class=\"line\">  return (((num &#x2F; precision) | 0) + 1) * precision</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    MAGIC_NUMBER_OFFSET +</span><br><span class=\"line\">    ceiling(</span><br><span class=\"line\">      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs &#x2F; UNIT_SIZE,</span><br><span class=\"line\">      bucketSizeMs &#x2F; UNIT_SIZE,</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const LOW_PRIORITY_EXPIRATION &#x3D; 5000</span><br><span class=\"line\">const LOW_PRIORITY_BATCH_SIZE &#x3D; 250</span><br><span class=\"line\"></span><br><span class=\"line\">function computeAsyncExpiration(currentTime) &#123;</span><br><span class=\"line\">  return computeExpirationBucket(</span><br><span class=\"line\">    currentTime,</span><br><span class=\"line\">    LOW_PRIORITY_EXPIRATION,</span><br><span class=\"line\">    LOW_PRIORITY_BATCH_SIZE,</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; const HIGH_PRIORITY_EXPIRATION &#x3D; __DEV__ ? 500 : 150;</span><br><span class=\"line\">const HIGH_PRIORITY_EXPIRATION &#x3D; 500</span><br><span class=\"line\">const HIGH_PRIORITY_BATCH_SIZE &#x3D; 100</span><br><span class=\"line\"></span><br><span class=\"line\">function computeInteractiveExpiration(currentTime) &#123;</span><br><span class=\"line\">  return computeExpirationBucket(</span><br><span class=\"line\">    currentTime,</span><br><span class=\"line\">    HIGH_PRIORITY_EXPIRATION,</span><br><span class=\"line\">    HIGH_PRIORITY_BATCH_SIZE,</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ceiling函数的<code>(((num / precision) | 0) + 1) * precision</code>类似上取整的操作，以及调用ceiling的参数来源是<code>LOW_PRIORITY_BATCH_SIZE</code> <code>HIGH_PRIORITY_BATCH_SIZE</code>，这么做也许是为了让非常相近的两次更新得到相同的expirationTime，然后在一次更新中完成，相当于一个自动的batchedUpdates。</p>\n","prev":{"title":"06.React源码学习-任务调度","link":"2019/11/30/note/06-React源码学习-任务调度"},"next":{"title":"04.React源码学习-update","link":"2019/11/28/note/04-React源码学习-update"},"plink":"https://www.hansomezao.com/2019/11/29/note/05-React源码学习-expirationTime/","toc":[{"id":"expirationtime","title":"expirationTime","index":"1"}]}