{"title":"04.redux","date":"2019-12-10T05:39:02.000Z","date_formatted":{"ll":"2019年12月10日","L":"2019/12/10","MM-DD":"12-10"},"author":"zao","link":"2019/12/10/note/04.redux","tags":["react"],"categories":["note"],"updated":"2019-12-10T05:39:02.000Z","content":"<h2 id=\"redux\">redux<a href=\"#redux\" title=\"redux\"></a></h2><blockquote>\n<h3 id=\"基础\">基础<a href=\"#基础\" title=\"基础\"></a></h3></blockquote>\n<p><img src=\"../assets/img/redux.jpg\" class=\"φcy\" alt=\"redux工作流\"></p>\n<h4 id=\"1数据流\"><strong><em>1.数据流:</em></strong><a href=\"#1数据流\" title=\"1.数据流:\"></a></h4><p>  <strong>严格的单向数据流是 Redux 架构的设计核心。</strong><br>  <strong>Redux 应用中数据的生命周期遵循下面 4 个步骤：</strong></p>\n<ol><li>调用 store.dispatch(action)。<ul><li>Action 就是一个描述“发生了什么”的普通对象。</li>\n</ul></li>\n<li>Redux store 调用传入的 reducer 函数。<ul><li>Store 会把两个参数传入 reducer： 当前的 state 树和 action。</li>\n</ul></li>\n<li>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。<ul><li>根 reducer 的结构完全由你决定。Redux 原生提供combineReducers()辅助函数，来把根 reducer 拆分成多个函数，用于分别处理 state 树的一个分支。</li>\n</ul></li>\n<li>Redux store 保存了根 reducer 返回的完整 state 树。<ul><li>这个新的树就是应用的下一个 state！所有订阅 store.subscribe(listener) 的监听器都将被调用；监听器里可以调用 store.getState() 获得当前 state。</li>\n</ul></li>\n</ol><hr>\n<h4 id=\"2action\"><strong><em>2.Action:</em></strong><a href=\"#2action\" title=\"2.Action:\"></a></h4><p>  <strong>Action是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。</strong><br>  <strong>一般来说你会通过 store.dispatch() 将 action 传到 store。</strong><br>  <strong>可以把 action 理解成新闻的摘要。如 “玛丽喜欢42号文章。” 或者 “任务列表里添加了’学习 Redux 文档’”。</strong><br>  <strong>你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。</strong></p>\n<hr>\n<h4 id=\"3reducer\"><strong><em>3.Reducer:</em></strong><a href=\"#3reducer\" title=\"3.Reducer:\"></a></h4><p>  <strong>Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，</strong><br>  <strong>Reducers 就是一个纯函数，接收旧的 state 和 action，返回新的 state。(previousState, action) =&gt; newState</strong><br>  <strong>永远不要在 reducer 里做这些操作：</strong></p>\n<ol><li>修改传入参数；</li>\n<li>执行有副作用的操作，如 API 请求和路由跳转；</li>\n<li>调用非纯函数，如 Date.now() 或 Math.random()。</li>\n</ol><hr>\n<h4 id=\"4store\"><strong><em>4.Store:</em></strong><a href=\"#4store\" title=\"4.Store:\"></a></h4><p>  <strong>Store 就是用来维持应用所有的 state 树 的一个对象。 改变 store 内 state 的惟一途径是对它 dispatch 一个 action。</strong><br>  <strong>Store 不是类。它只是有几个方法的对象。 要创建它，只需要把根部的 reducing 函数 传递给 createStore。</strong><br>  <strong>Store 就是把Action和Reducer联系到一起的对象。</strong></p>\n<ul><li><h5 id=\"store的方法\">Store的方法:<a href=\"#store的方法\" title=\"Store的方法:\"></a></h5><ul><li><h6 id=\"getstate\">getState()<a href=\"#getstate\" title=\"getState()\"></a></h6><ul><li><h6 id=\"作用：\"><em>作用：</em><a href=\"#作用：\" title=\"作用：\"></a></h6>返回应用当前的 state 树。它与 store 的最后一个 reducer 返回值相同。</li>\n<li><h6 id=\"返回值：\"><em>返回值：</em><a href=\"#返回值：\" title=\"返回值：\"></a></h6>(any): 应用当前的 state 树。</li>\n</ul></li>\n<li><h6 id=\"dispatchaction\">dispatch(action)<a href=\"#dispatchaction\" title=\"dispatch(action)\"></a></h6><ul><li><h6 id=\"作用：-1\"><em>作用：</em><a href=\"#作用：-1\" title=\"作用：\"></a></h6>分发 action。这是触发 state 变化的惟一途径。会使用当前 getState() 的结果和传入的 action 以同步方式的调用 store 的 reduce 函数。返回值会被作为下一个 state。从现在开始，这就成为了 getState() 的返回值，同时变化监听器(change listener)会被触发。</li>\n<li><h6 id=\"参数：\"><em>参数：</em><a href=\"#参数：\" title=\"参数：\"></a></h6>action (Object)</li>\n<li><h6 id=\"返回值：-1\"><em>返回值：</em><a href=\"#返回值：-1\" title=\"返回值：\"></a></h6>(Object): 要 dispatch 的 action。</li>\n<li><h6 id=\"注意：\"><em>注意：</em><a href=\"#注意：\" title=\"注意：\"></a></h6>使用 createStore 创建的 “纯正” store 只支持普通对象类型的 action，而且会立即传到 reducer 来执行。<br>但是，如果你用 applyMiddleware 来套住 createStore 时，middleware 可以修改 action 的执行，并支持执行 dispatch intent（意图）。Intent 一般是异步操作如 Promise、Observable 或者 Thunk。</li>\n</ul></li>\n<li><h6 id=\"subscribelistener\">subscribe(listener)<a href=\"#subscribelistener\" title=\"subscribe(listener)\"></a></h6><ul><li><h6 id=\"作用：-2\"><em>作用：</em><a href=\"#作用：-2\" title=\"作用：\"></a></h6>添加一个变化监听器。每当 dispatch action 的时候就会执行，state 树中的一部分可能已经变化。你可以在回调函数里调用 getState() 来拿到当前 state。如果需要解绑这个变化监听器，执行 subscribe 返回的函数即可。</li>\n<li><h6 id=\"参数：-1\"><em>参数：</em><a href=\"#参数：-1\" title=\"参数：\"></a></h6>listener (Function): 每当 dispatch action 的时候都会执行的回调。state 树中的一部分可能已经变化。你可以在回调函数里调用 getState() 来拿到当前 state。store 的 reducer 应该是纯函数，因此你可能需要对 state 树中的引用做深度比较来确定它的值是否有变化。</li>\n<li><h6 id=\"返回值：-2\"><em>返回值：</em><a href=\"#返回值：-2\" title=\"返回值：\"></a></h6>(Function): 一个可以解绑变化监听器的函数。</li>\n</ul></li>\n<li><h6 id=\"subscribelistener-1\">subscribe(listener)<a href=\"#subscribelistener-1\" title=\"subscribe(listener)\"></a></h6><ul><li><h6 id=\"作用：-3\"><em>作用：</em><a href=\"#作用：-3\" title=\"作用：\"></a></h6>替换 store 当前用来计算 state 的 reducer。这是一个高级 API。只有在你需要实现代码分隔，而且需要立即加载一些 reducer 的时候才可能会用到它。在实现 Redux 热加载机制的时候也可能会用到。</li>\n<li><h6 id=\"参数：-2\"><em>参数：</em><a href=\"#参数：-2\" title=\"参数：\"></a></h6>reducer (Function) store 会使用的下一个 reducer。<blockquote>\n<h3 id=\"api\">API<a href=\"#api\" title=\"API\"></a></h3></blockquote>\n</li>\n</ul></li>\n<li><h4 id=\"createstorereducer-preloadedstate-enhancer\"><strong><em>createStore(reducer, [preloadedState], enhancer)</em></strong><a href=\"#createstorereducer-preloadedstate-enhancer\" title=\"createStore(reducer, [preloadedState], enhancer)\"></a></h4></li>\n</ul></li>\n<li><h6 id=\"作用：-4\"><em>作用：</em><a href=\"#作用：-4\" title=\"作用：\"></a></h6><p>创建一个 Redux store 来以存放应用中所有的 state。应用中应有且仅有一个 store。</p>\n</li>\n<li><h6 id=\"参数：-3\"><em>参数：</em><a href=\"#参数：-3\" title=\"参数：\"></a></h6><ul><li><p>reducer (Function): </p>\n<p>接收两个参数，分别是当前的 state 树和要处理的 action，返回新的state 树。</p>\n</li>\n<li><p>[preloadedState] (any):</p>\n<p> 初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 水合（hydrate）后传给它，或者从之前保存的用户会话中恢复一个传给它。如果你使用 combineReducers 创建 reducer，它必须是一个普通对象，与传入的 keys 保持同样的结构。否则，你可以自由传入任何 reducer 可理解的内容。</p>\n</li>\n<li><p>enhancer (Function):</p>\n<p>Store enhancer 是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。</p>\n</li>\n</ul></li>\n<li><h6 id=\"返回值：-3\"><em>返回值：</em><a href=\"#返回值：-3\" title=\"返回值：\"></a></h6><p>(Store): 保存了应用所有 state 的对象。改变 state 的惟一方法是 dispatch action。你也可以 subscribe 监听 state 的变化，然后更新 UI。</p>\n</li>\n</ul><hr>\n<ul><li><h4 id=\"combinereducers\"><strong><em>combineReducers()</em></strong><a href=\"#combinereducers\" title=\"combineReducers()\"></a></h4><ul><li><h6 id=\"作用：-5\"><em>作用：</em><a href=\"#作用：-5\" title=\"作用：\"></a></h6>combineReducers() 所做的只是生成一个函数，这个函数来调用你的一系列 reducer，每个 reducer 根据它们的 key 来筛选出 state 中的一部分数据并处理，然后这个生成的函数再将所有 reducer 的结果合并成一个大的对象。没有任何魔法。正如其他 reducers，如果 combineReducers() 中包含的所有 reducers 都没有更改 state，那么也就不会创建一个新的对象。</li>\n</ul><hr>\n</li>\n<li><h4 id=\"applymiddlewaremiddlewares\"><strong><em>applyMiddleware(…middlewares)</em></strong><a href=\"#applymiddlewaremiddlewares\" title=\"applyMiddleware(…middlewares)\"></a></h4><ul><li><h6 id=\"作用：-6\"><em>作用：</em><a href=\"#作用：-6\" title=\"作用：\"></a></h6>使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息。<br>Middleware 最常见的使用场景是无需引用大量代码或依赖类似 Rx 的第三方库实现异步 actions。这种方式可以让你像 dispatch 一般的 actions 那样 dispatch 异步 actions。</li>\n</ul><hr>\n</li>\n<li><h4 id=\"bindactioncreatorsactioncreators-dispatch\"><strong><em>bindActionCreators(actionCreators, dispatch)</em></strong><a href=\"#bindactioncreatorsactioncreators-dispatch\" title=\"bindActionCreators(actionCreators, dispatch)\"></a></h4><ul><li><h6 id=\"作用：-7\"><em>作用：</em><a href=\"#作用：-7\" title=\"作用：\"></a></h6>把一个 value 为不同 action creator 的对象，转成拥有同名 key 的对象。同时使用 dispatch 对每个 action creator 进行包装，以便可以直接调用它们。<br>一般情况下你可以直接在 Store 实例上调用 dispatch。如果你在 React 中使用 Redux，react-redux 会提供 dispatch 函数让你直接调用它 。<br>惟一会使用到 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 dispatch 或 Redux store 传给它。<br>为方便起见，你也可以传入一个函数作为第一个参数，它会返回一个函数。<br>另一替代 bindActionCreators 的做法是直接把 dispatch 函数当作 prop 传递给子组件，但这时你的子组件需要引入 action creator 并且感知它们</li>\n</ul><hr>\n</li>\n<li><h4 id=\"composefunctions\"><strong><em>compose(…functions)</em></strong><a href=\"#composefunctions\" title=\"compose(…functions)\"></a></h4><ul><li><h6 id=\"作用：-8\"><em>作用：</em><a href=\"#作用：-8\" title=\"作用：\"></a></h6>从右到左来组合多个函数。<br>这是函数式编程中的方法，为了方便，被放到了 Redux 里。当需要把多个 store 增强器 依次执行的时候，需要用到它。</li>\n</ul></li>\n</ul><blockquote>\n<h3 id=\"react-redux\">react-redux<a href=\"#react-redux\" title=\"react-redux\"></a></h3></blockquote>\n<p>Redux 官方提供的 React 绑定库,具有高效且灵活的特性。此库并不是 Redux 内置，需要单独安装。</p>\n<ul><li><h4 id=\"react-redux-api\">react-redux API:<a href=\"#react-redux-api\" title=\"react-redux API:\"></a></h4><ul><li><h5 id=\"ltprovider-storegt\"><strong><em><code>&lt;Provider store&gt;</code></em></strong><a href=\"#ltprovider-storegt\" title=\"&lt;Provider store&gt;\"></a></h5><ul><li><h6 id=\"作用：-9\"><em>作用：</em><a href=\"#作用：-9\" title=\"作用：\"></a></h6><code>&lt;Provider store&gt;</code> 使组件层级中的 connect() 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 <code>&lt;Provider&gt;</code> 中才能使用 connect() 方法。</li>\n<li><h6 id=\"属性：\"><em>属性：</em><a href=\"#属性：\" title=\"属性：\"></a></h6><ul><li>store (Redux Store): 应用程序中唯一的 Redux store 对象</li>\n<li>children (ReactElement) 组件层级的根组件。</li>\n</ul></li>\n</ul></li>\n<li><h5 id=\"connectmapstatetoprops-mapdispatchtoprops-mergeprops-options\"><strong><em><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code></em></strong><a href=\"#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options\" title=\"connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\"></a></h5><ul><li><h6 id=\"作用：-10\"><em>作用：</em><a href=\"#作用：-10\" title=\"作用：\"></a></h6><p>连接 React 组件与 Redux store。连接操作不会改变原来的组件类。反而返回一个新的已与 Redux store 连接的组件类。</p>\n</li>\n<li><h6 id=\"参数：-4\"><em>参数：</em><a href=\"#参数：-4\" title=\"参数：\"></a></h6><ul><li><p>[mapStateToProps(state, [ownProps]): stateProps] (Function)：</p>\n<p>如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。</p>\n</li>\n<li><p>[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function)：</p>\n<p>如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()。如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。</p>\n</li>\n<li><p>[mergeProps(stateProps, dispatchProps, ownProps): props] (Function)：</p>\n<p>如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。你也许可以用这个回调函数，根据组件的 props 来筛选部分的 state 数据，或者把 props 中的某个特定变量与 action creator 绑定在一起。如果你省略这个参数，默认情况下返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。</p>\n</li>\n<li><p>[options] (Object)：</p>\n<p> 如果指定这个参数，可以定制 connector 的行为。</p>\n<p> <code>[pure = true]</code> (Boolean):如果为 true，connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。默认值为 true。</p>\n<p> <code>[withRef = false]</code> (Boolean): 如果为 true，connector 会保存一个对被被包含的组件实例的引用，该引用通过 getWrappedInstance() 方法获得。默认值为 false。</p>\n</li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul><blockquote>\n<h3 id=\"异步ation\">异步Ation<a href=\"#异步ation\" title=\"异步Ation\"></a></h3><p>  <a href=\"https://github.com/TigerHee/shareJS/blob/master/react/05.redux-saga.md\" target=\"_blank\">redux-saga</a></p>\n</blockquote>\n<blockquote>\n<h3 id=\"示例项目\">示例项目:<a href=\"#示例项目\" title=\"示例项目:\"></a></h3><p>💯<a href=\"https://github.com/TigerHee/tiger-react-cli\" target=\"_blank\">tiger-react-cli</a></p>\n</blockquote>\n","prev":{"title":"05.redux-saga","link":"2019/12/10/note/05.redux-saga"},"next":{"title":"js常用小技巧","link":"2019/12/10/note/js常用小技巧"},"plink":"https://www.hansomezao.com/2019/12/10/note/04.redux/","toc":[{"id":"redux","title":"redux","index":"1","children":[{"id":"基础","title":"基础","index":"1.1"},{"id":"api","title":"API","index":"1.2"},{"id":"react-redux","title":"react-redux","index":"1.3"},{"id":"异步ation","title":"异步Ation","index":"1.4"},{"id":"示例项目","title":"示例项目:","index":"1.5"}]}]}