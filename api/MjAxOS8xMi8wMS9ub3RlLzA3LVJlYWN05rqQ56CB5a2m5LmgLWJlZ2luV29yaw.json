{"title":"07.React源码学习-beginWork","date":"2019-12-01T07:25:29.000Z","date_formatted":{"ll":"2019年12月1日","L":"2019/12/01","MM-DD":"12-01"},"author":"zao","link":"2019/12/01/note/07-React源码学习-beginWork","tags":["react源码"],"categories":["note"],"updated":"2019-12-01T07:25:29.000Z","content":"<h2 id=\"beginwork\">beginWork<a href=\"#beginwork\" title=\"beginWork\"></a></h2><p>执行对整棵树的每一个节点进行更新的操作（performUnitOfWork内调用beginWork）</p>\n<p>源码在 react-reconciler 下的 ReactFiberBeginWork.js 内：</p>\n<p><code>beginWork()</code>方法里通过 <code>switch (workInProgress.tag)</code>对不同的组件做不同的更新处理：</p>\n<p>下面看看不同组件的更新：</p>\n<p>出现频率很高的一个判断 <code>current === null</code> 用于判断组件是否是第一次渲染。</p>\n<h3 id=\"1functioncomponent\">1.FunctionComponent<a href=\"#1functioncomponent\" title=\"1.FunctionComponent\"></a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function updateFunctionComponent(</span><br><span class=\"line\">  current,</span><br><span class=\"line\">  workInProgress,</span><br><span class=\"line\">  Component,</span><br><span class=\"line\">  nextProps: any,</span><br><span class=\"line\">  renderExpirationTime,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 此处去掉__DEV__代码</span><br><span class=\"line\">  const unmaskedContext &#x3D; getUnmaskedContext(workInProgress, Component, true);</span><br><span class=\"line\">  const context &#x3D; getMaskedContext(workInProgress, unmaskedContext);</span><br><span class=\"line\">  let nextChildren;</span><br><span class=\"line\">  prepareToReadContext(workInProgress, renderExpirationTime);</span><br><span class=\"line\">  prepareToUseHooks(current, workInProgress, renderExpirationTime);</span><br><span class=\"line\">  if (__DEV__) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 此处去掉__DEV__代码</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    nextChildren &#x3D; Component(nextProps, context);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nextChildren &#x3D; finishHooks(Component, nextProps, nextChildren, context);</span><br><span class=\"line\">  &#x2F;&#x2F; React DevTools reads this flag.</span><br><span class=\"line\">  workInProgress.effectTag |&#x3D; PerformedWork;</span><br><span class=\"line\">  reconcileChildren(</span><br><span class=\"line\">    current,</span><br><span class=\"line\">    workInProgress,</span><br><span class=\"line\">    nextChildren,</span><br><span class=\"line\">    renderExpirationTime,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  return workInProgress.child;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用<code>Component</code>时传入了两个值<code>nextProps</code>和<code>context</code>, 那么函数组件可以直接通过第二个参数拿到<code>context</code>，官方文档没有说明过这点。</p>\n<h3 id=\"2classcomponent\">2.ClassComponent<a href=\"#2classcomponent\" title=\"2.ClassComponent\"></a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function updateClassComponent(</span><br><span class=\"line\">  current: Fiber | null,</span><br><span class=\"line\">  workInProgress: Fiber,</span><br><span class=\"line\">  Component: any,</span><br><span class=\"line\">  nextProps,</span><br><span class=\"line\">  renderExpirationTime: ExpirationTime,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  if (__DEV__) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 去掉__DEV__代码</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; Push context providers early to prevent context stack mismatches.</span><br><span class=\"line\">  &#x2F;&#x2F; During mounting we don&#39;t know the child context yet as the instance doesn&#39;t exist.</span><br><span class=\"line\">  &#x2F;&#x2F; We will invalidate the child context in finishClassComponent() right after rendering.</span><br><span class=\"line\">  let hasContext;</span><br><span class=\"line\">  if (isLegacyContextProvider(Component)) &#123;</span><br><span class=\"line\">    hasContext &#x3D; true;</span><br><span class=\"line\">    pushLegacyContextProvider(workInProgress);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    hasContext &#x3D; false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  prepareToReadContext(workInProgress, renderExpirationTime);</span><br><span class=\"line\"></span><br><span class=\"line\">  const instance &#x3D; workInProgress.stateNode;</span><br><span class=\"line\">  let shouldUpdate;</span><br><span class=\"line\">  if (instance &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">    if (current !&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; An class component without an instance only mounts if it suspended</span><br><span class=\"line\">      &#x2F;&#x2F; inside a non- concurrent tree, in an inconsistent state. We want to</span><br><span class=\"line\">      &#x2F;&#x2F; tree it like a new mount, even though an empty version of it already</span><br><span class=\"line\">      &#x2F;&#x2F; committed. Disconnect the alternate pointers.</span><br><span class=\"line\">      current.alternate &#x3D; null;</span><br><span class=\"line\">      workInProgress.alternate &#x3D; null;</span><br><span class=\"line\">      &#x2F;&#x2F; Since this is conceptually a new fiber, schedule a Placement effect</span><br><span class=\"line\">      workInProgress.effectTag |&#x3D; Placement;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; In the initial pass we might need to construct the instance.</span><br><span class=\"line\">    constructClassInstance(</span><br><span class=\"line\">      workInProgress,</span><br><span class=\"line\">      Component,</span><br><span class=\"line\">      nextProps,</span><br><span class=\"line\">      renderExpirationTime,</span><br><span class=\"line\">    );</span><br><span class=\"line\">    mountClassInstance(</span><br><span class=\"line\">      workInProgress,</span><br><span class=\"line\">      Component,</span><br><span class=\"line\">      nextProps,</span><br><span class=\"line\">      renderExpirationTime,</span><br><span class=\"line\">    );</span><br><span class=\"line\">    shouldUpdate &#x3D; true;</span><br><span class=\"line\">  &#125; else if (current &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; In a resume, we&#39;ll already have an instance we can reuse.</span><br><span class=\"line\">    shouldUpdate &#x3D; resumeMountClassInstance(</span><br><span class=\"line\">      workInProgress,</span><br><span class=\"line\">      Component,</span><br><span class=\"line\">      nextProps,</span><br><span class=\"line\">      renderExpirationTime,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    shouldUpdate &#x3D; updateClassInstance(</span><br><span class=\"line\">      current,</span><br><span class=\"line\">      workInProgress,</span><br><span class=\"line\">      Component,</span><br><span class=\"line\">      nextProps,</span><br><span class=\"line\">      renderExpirationTime,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const nextUnitOfWork &#x3D; finishClassComponent(</span><br><span class=\"line\">    current,</span><br><span class=\"line\">    workInProgress,</span><br><span class=\"line\">    Component,</span><br><span class=\"line\">    shouldUpdate,</span><br><span class=\"line\">    hasContext,</span><br><span class=\"line\">    renderExpirationTime,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  if (__DEV__) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 去掉__DEV__代码</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return nextUnitOfWork;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开始是对context的操作，因为ClassComponent可以成为context provider。</p>\n<p>current === null只会出现在第一次渲染的时候，因为会先创建workInProcess，在渲染结束之后才会把workInProcess拷贝成current，代表着第一次渲染结束。而后面也会出现根据current === null来判断是否需要调用componentDidMount的代码</p>\n<p>在这里如果current === null就行要进行实例的构建工作，如果不是，直接updateClassInstance</p>\n<p>如果是还要判断实例是否已经创建workInProgress.stateNode === null，如果是的话要创建这个实例，通过constructClassInstance(代码在同级的ReactFiberClassComponent.js内，这个方法调用adoptClassInstance给 ClassComponent 的实例挂载一个updater对象，里面包含我们常用的方法：forceUpdate, replaceState, setState)，并且挂载实例mountClassInstance（初始化 props、state 等实例属性，如果有updateQueue就更新之，一般来说第一次渲染是没有的。）</p>\n<p>如果已经有current则调用updateClassInstance</p>\n<p>最后调用finishClassComponent</p>\n<h3 id=\"3indeterminatecomponent\">3.IndeterminateComponent<a href=\"#3indeterminatecomponent\" title=\"3.IndeterminateComponent\"></a></h3><p>FunctionalComponent在含有render方法时会被当做ClassComponent来处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default ()&#x3D;&gt;&#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      console.log(&#39;Indeterminate&#39;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      return &lt;div&gt;Indeterminate&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4hostcomponent\">4.HostComponent<a href=\"#4hostcomponent\" title=\"4.HostComponent\"></a></h3><p>原生的html标签（completeWork阶段就是从HostComponent开始逆着Fiber输往回return Fiber,并在HostComponent上进行虚拟DOM的diff判断比较props）</p>\n<h3 id=\"reconcilechildren\">reconcileChildren<a href=\"#reconcilechildren\" title=\"reconcileChildren\"></a></h3><p><em>不同类型的组件更新最后都会调用此方法</em></p>\n<ul><li>根据props.children生成Fiber子树</li>\n<li>判断Fiber对象是否可以复用</li>\n<li>列表根据key优化</li>\n</ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function reconcileChildren(</span><br><span class=\"line\">  current: Fiber | null,</span><br><span class=\"line\">  workInProgress: Fiber,</span><br><span class=\"line\">  nextChildren: any,</span><br><span class=\"line\">  renderExpirationTime: ExpirationTime,</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  if (current &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">    workInProgress.child &#x3D; mountChildFibers(</span><br><span class=\"line\">      workInProgress,</span><br><span class=\"line\">      null,</span><br><span class=\"line\">      nextChildren,</span><br><span class=\"line\">      renderExpirationTime,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    workInProgress.child &#x3D; reconcileChildFibers(</span><br><span class=\"line\">      workInProgress,</span><br><span class=\"line\">      current.child,</span><br><span class=\"line\">      nextChildren,</span><br><span class=\"line\">      renderExpirationTime,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查看上面两种不同调用的方法引入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">  mountChildFibers,</span><br><span class=\"line\">  reconcileChildFibers,</span><br><span class=\"line\">  cloneChildFibers,</span><br><span class=\"line\">&#125; from &#39;.&#x2F;ReactChildFiber&#39;;</span><br></pre></td></tr></table></figure>\n<p>然后去ReactChildFiber.js内查看方法定义：<br>mountChildFibers和reconcileChildFibers方法是一样的，唯一的区别是生成这个方法的时候的一个参数不同</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const reconcileChildFibers &#x3D; ChildReconciler(true);</span><br><span class=\"line\">export const mountChildFibers &#x3D; ChildReconciler(false);</span><br></pre></td></tr></table></figure>\n<p>这个参数叫shouldTrackSideEffects，他的作用是判断是否要增加一些effectTag，主要是用来优化初次渲染的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (shouldTrackSideEffects &amp;&amp; newFiber.alternate &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">  newFiber.effectTag &#x3D; Placement</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ChildReconciler最终调用的是reconcileChildFibers:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ChildReconciler(shouldTrackSideEffects) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 省略其他代码</span><br><span class=\"line\">  function reconcileChildFibers(</span><br><span class=\"line\">    returnFiber: Fiber,</span><br><span class=\"line\">    currentFirstChild: Fiber | null,</span><br><span class=\"line\">    newChild: any,</span><br><span class=\"line\">    expirationTime: ExpirationTime,</span><br><span class=\"line\">  ): Fiber | null &#123;&#125;</span><br><span class=\"line\">  return reconcileChildFibers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>reconcileChildFibers会根据newChild的不同类型进行对应的处理，最终的返回是当前节点的第一个孩子节点，会在performUnitWork中 return 并赋值给nextUnitOfWork。</p>\n<p>children的合法类型：</p>\n<ul><li>ReactElement，通过createElement和ReactDOM.createPortal创建，$$typeof不同</li>\n<li>string或者number，<div>abc</div>中div的children就是”abc”</li>\n<li>[// renderAble]数组，每一项都可以是其他合法类型，不能嵌套</li>\n<li>Iterator，跟数组类似，只是遍历方式不同</li>\n<li>React.ConcurrentMode这些内置组件，最终会转换成ReactElement，不同的是ReactElement.type</li>\n<li>reconcileSingleElement &amp; reconcileSinglePortal &amp; reconcileSingleTextNode</li>\n<li>reconcileChildrenArray &amp; reconcileChildrenArray</li>\n</ul>","prev":{"title":"08.React源码学习-commit","link":"2019/12/02/note/08-React源码学习-commit"},"next":{"title":"06.React源码学习-任务调度","link":"2019/11/30/note/06-React源码学习-任务调度"},"plink":"https://www.hansomezao.com/2019/12/01/note/07-React源码学习-beginWork/","toc":[{"id":"beginwork","title":"beginWork","index":"1","children":[{"id":"1functioncomponent","title":"1.FunctionComponent","index":"1.1"},{"id":"2classcomponent","title":"2.ClassComponent","index":"1.2"},{"id":"3indeterminatecomponent","title":"3.IndeterminateComponent","index":"1.3"},{"id":"4hostcomponent","title":"4.HostComponent","index":"1.4"},{"id":"reconcilechildren","title":"reconcileChildren","index":"1.5"}]}]}