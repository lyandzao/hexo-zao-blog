{"title":"ES6 bilibili（92集之后）","date":"2019-10-13T02:42:58.000Z","date_formatted":{"ll":"2019年10月13日","L":"2019/10/13","MM-DD":"10-13"},"author":"zao","link":"2019/10/13/note/ES6 bilibili（92集之后）","tags":["es6"],"categories":["note"],"updated":"2019-10-13T02:42:58.000Z","content":"<h1 id=\"es6的新增语法\">ES6的新增语法<a href=\"#es6的新增语法\" title=\"ES6的新增语法\"></a></h1><h2 id=\"let关键字\">let关键字<a href=\"#let关键字\" title=\"let关键字\"></a></h2><pre><code>let关键字就是用来声明变量的；</code></pre><ul><li>使用let关键字声明的变量具有块级作用域；</li>\n<li>注意：使用let关键字声明的变量才具有块级作用域，使用var声明的不具有块级作用域特性；</li>\n<li>防止循环变量变成全局变量；</li>\n<li>不存在变量提升；</li>\n<li>暂时性死区；<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--let关键字就是用来声明变量的--&gt;</span><br><span class=\"line\">let a &#x3D; 10;</span><br><span class=\"line\">console.log(a);&#x2F;&#x2F; a is not defined</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--使用let关键字声明的变量具有块级作用域--&gt;</span><br><span class=\"line\">\tif (true) &#123;</span><br><span class=\"line\">\t    let b &#x3D; 20;</span><br><span class=\"line\">    \tconsole.log(b)</span><br><span class=\"line\">        if (true) &#123;</span><br><span class=\"line\">    \t    let c &#x3D; 30;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    console.log(c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconsole.log(b)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--在一个大括号中,使用let关键字声明的变量才具有块级作用域，var</span><br><span class=\"line\">关键字是不具备这个特点的。--&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (true) &#123;</span><br><span class=\"line\">\t    let num &#x3D; 100;</span><br><span class=\"line\">    \tvar abc &#x3D; 200;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconsole.log(abc);</span><br><span class=\"line\">\tconsole.log(num)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--防止循环变量变成全局变量--&gt;</span><br><span class=\"line\">\tfor (let i &#x3D; 0; i &lt; 2; i++) &#123;&#125;</span><br><span class=\"line\">\tconsole.log(i)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--使用let关键字声明的变量没有变量提升--&gt;</span><br><span class=\"line\">\tconsole.log(a);</span><br><span class=\"line\">\tlet a &#x3D; 100;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--使用let关键字声明的变量具有暂时性死区特性--&gt;</span><br><span class=\"line\">var tmp &#x3D; 123;</span><br><span class=\"line\">if (true) &#123; </span><br><span class=\"line\">    tmp &#x3D; &#39;abc&#39;;</span><br><span class=\"line\">    let tmp; &#x2F;&#x2F;tmp is not defined</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"经典面试题\">经典面试题<a href=\"#经典面试题\" title=\"经典面试题\"></a></h3><h4 id=\"面试题1-var\">面试题1 var<a href=\"#面试题1-var\" title=\"面试题1 var\"></a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr &#x3D; [];</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class=\"line\">    arr[i] &#x3D; function () &#123;</span><br><span class=\"line\">        console.log(i); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr[0]();</span><br><span class=\"line\">arr[1]();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/BXsweetheart/youdaoNotes/blob/master/var%E9%9D%A2%E8%AF%95%E9%A2%98.png?raw=true\" class=\"φcy\" alt=\"image\"></p>\n<pre><code>经典面试题图解：此题的关键点在于变量i是全局的，函数执\n行时输出的都是全局作用域下的i值。</code></pre><h4 id=\"面试题2-let\">面试题2 let<a href=\"#面试题2-let\" title=\"面试题2 let\"></a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [];</span><br><span class=\"line\">for (let i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class=\"line\">    arr[i] &#x3D; function () &#123;</span><br><span class=\"line\">        console.log(i); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr[0]();</span><br><span class=\"line\">arr[1]();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/BXsweetheart/youdaoNotes/blob/master/let%E9%9D%A2%E8%AF%95%E9%A2%98.png?raw=true\" class=\"φcy\" alt=\"image\"></p>\n<pre><code>经典面试题图解：此题的关键点在于每次循环都会产生一个块\n级作用域，每个块级作用域中的变量都是不同的，函数执行时\n输出的是自己上一级（循环产生的块级作用域）作用域下的i\n值.</code></pre><h2 id=\"const关键字\">const关键字<a href=\"#const关键字\" title=\"const关键字\"></a></h2><pre><code>作用：声明常量，常量就是值（内存地址）不能变化的量;</code></pre><ul><li>具有块级作用域;</li>\n<li>声明常量时必须赋值;</li>\n<li>常量赋值后，值不能修改;</li>\n</ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--使用const关键字声明的常量具有块级作用域--&gt;</span><br><span class=\"line\">if (true) &#123; </span><br><span class=\"line\">    const a &#x3D; 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a) &#x2F;&#x2F; a is not defined</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--&#x2F;使用const关键字声明的常量必须赋初始值--&gt;</span><br><span class=\"line\">const PI; &#x2F;&#x2F; Missing initializer in const declaration</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--常量声明后值不可更改--&gt;</span><br><span class=\"line\">const PI &#x3D; 3.14;</span><br><span class=\"line\">PI &#x3D; 100;</span><br><span class=\"line\">const ary &#x3D; [100, 200];</span><br><span class=\"line\">ary[0] &#x3D; 123;&#x2F;&#x2F;（没有更改内存地址）数据可以更改</span><br><span class=\"line\">即数据结构内部的值可以更改</span><br><span class=\"line\">ary &#x3D; [1, 2] &#x2F;&#x2F;更改的是内存地址，所以数据值本身不可更改</span><br><span class=\"line\">console.log(ary);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"let-const-var的区别\">let const var的区别<a href=\"#let-const-var的区别\" title=\"let const var的区别\"></a></h2><ol><li>使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象。</li>\n<li>使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。</li>\n<li>使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值。</li>\n</ol><div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>var</th><th>let</th><th>const</th></tr>\n</thead><tbody><tr>\n<td>函数级作用域</td><td>块级作用域</td><td>块级作用域</td></tr>\n<tr>\n<td>变量提升</td><td>不存在变量提升</td><td>不存在变量提升</td></tr>\n<tr>\n<td>只可更改</td><td>只可更改</td><td>值不可更改</td></tr>\n</tbody></table></div></div><h2 id=\"解构赋值\">解构赋值<a href=\"#解构赋值\" title=\"解构赋值\"></a></h2><pre><code>ES6中允许从数组中提取值，按照对应位置，对变量赋值。对\n象也可以实现解构。</code></pre><h3 id=\"数组解构\">数组解构<a href=\"#数组解构\" title=\"数组解构\"></a></h3><pre><code>允许我们按照一一对应的关系从数组中提取值，然后将值赋给变量</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a, b, c] &#x3D; [1, 2, 3];</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">console.log(b)</span><br><span class=\"line\">console.log(c)</span><br></pre></td></tr></table></figure>\n<p>如果解构不成功，变量的值为undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo] &#x3D; [];</span><br><span class=\"line\">let [bar, foo] &#x3D; [1];</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象解构\">对象解构<a href=\"#对象解构\" title=\"对象解构\"></a></h3><pre><code>对象解构允许我们使用变量的名字匹配对象的属性，匹配成\n功将对象属性的值赋给变量</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let person &#x3D; &#123; name: &#39;zhangsan&#39;, age: 20 &#125;; </span><br><span class=\"line\">let &#123; name, age &#125; &#x3D; person;</span><br><span class=\"line\">console.log(name); &#x2F;&#x2F; &#39;zhangsan&#39; </span><br><span class=\"line\">console.log(age); &#x2F;&#x2F; 20</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123;name: myName, age: myAge&#125; &#x3D; person; &#x2F;&#x2F; myName myAge 属于别名</span><br><span class=\"line\">console.log(myName); &#x2F;&#x2F; &#39;zhangsan&#39; </span><br><span class=\"line\">console.log(myAge); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\">箭头函数<a href=\"#箭头函数\" title=\"箭头函数\"></a></h2><pre><code>ES6中新增的定义函数的方式，用来简化函数定义语法的。\n书写格式 ： () =&gt; {} </code></pre><ul><li>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号;</li>\n<li>在箭头函数中，如果形参只有一个，形参外面的小括号也可以省略;</li>\n<li>箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(123)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()</span><br></pre></td></tr></table></figure>\n  函数体中只有一句代码，且代码的执行结果就是返回值，可<br>  以省略大括号。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!--传统函数--&gt;</span><br><span class=\"line\">function sum(num1, num2) &#123; </span><br><span class=\"line\">    return num1 + num2; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;!--ES6--&gt;</span><br><span class=\"line\">const sum &#x3D; (num1, num2) &#x3D;&gt; num1 + num2;</span><br><span class=\"line\">const result&#x3D;sum(10,20)</span><br></pre></td></tr></table></figure>\n  在箭头函数中，如果形参只有一个，形参外面的小括号也可以省略.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn (v) &#123;</span><br><span class=\"line\">    return v;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">const fn &#x3D; v &#x3D;&gt; v;</span><br></pre></td></tr></table></figure>\n  箭头函数不绑定this关键字，箭头函数中的this，指向的是<br>  函数定义位置的上下文this。<br>  也就是说箭头函数被定义在哪里，箭头函数中的this就指向哪里。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj &#x3D; &#123; name: &#39;张三&#39;&#125; </span><br><span class=\"line\">function fn () &#123; </span><br><span class=\"line\">    console.log(this);</span><br><span class=\"line\">    return () &#x3D;&gt; &#123; </span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">const resFn &#x3D; fn.call(obj); </span><br><span class=\"line\">resFn();</span><br></pre></td></tr></table></figure>\n<h3 id=\"箭头函数面试题\">箭头函数面试题<a href=\"#箭头函数面试题\" title=\"箭头函数面试题\"></a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj &#x3D; &#123;</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    say: () &#x3D;&gt; &#123;</span><br><span class=\"line\">        alert(this.age)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.say();&#x2F;&#x2F;会alert undefined</span><br></pre></td></tr></table></figure>\n  上方代码中对象不能产生作用域，所以此处的箭头函数被定<br>  义在了全局 作用域下，此时的this指向的是window，window<br>  下没有age属性，所以undefined。</li>\n</ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var age&#x3D;100</span><br><span class=\"line\">var obj &#x3D; &#123;</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    say: () &#x3D;&gt; &#123;</span><br><span class=\"line\">        alert(this.age)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.say();&#x2F;&#x2F;会alert undefined</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"剩余参数\">剩余参数<a href=\"#剩余参数\" title=\"剩余参数\"></a></h2><pre><code>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。</code></pre><ul><li>箭头函数使用不了传送函数中的arguments；</li>\n<li>(…参数名)：表示接收所有的参数；</li>\n<li>(参数名1,…参数名2)：参数名2，表示结束剩余的所有参数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sum (first, ...args) &#123;</span><br><span class=\"line\">    console.log(first); &#x2F;&#x2F; 10</span><br><span class=\"line\">    console.log(args); &#x2F;&#x2F; [20, 30] </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sum(10, 20, 30)</span><br><span class=\"line\"></span><br><span class=\"line\">const sum &#x3D; (...args) &#x3D;&gt; &#123;</span><br><span class=\"line\">    let total &#x3D; 0;</span><br><span class=\"line\">        args.forEach(item &#x3D;&gt; total +&#x3D; item);</span><br><span class=\"line\">        return total;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">console.log(sum(10, 20));</span><br><span class=\"line\">console.log(sum(10, 20, 30));</span><br></pre></td></tr></table></figure>\n<h3 id=\"剩余参数和解构配合使用\">剩余参数和解构配合使用<a href=\"#剩余参数和解构配合使用\" title=\"剩余参数和解构配合使用\"></a></h3></li>\n</ul><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ary1 &#x3D; [&#39;张三&#39; , &#39;李四&#39;, &#39;王五&#39;];</span><br><span class=\"line\">let [s1, ...s2] &#x3D; ary1;</span><br><span class=\"line\">console.log(s1)</span><br><span class=\"line\">console.log(s2)&#x2F;&#x2F;...s2已经变成了一个数组，存储了&quot;李四&quot;,&quot;王五&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"es6的内置语法扩展\">ES6的内置语法扩展<a href=\"#es6的内置语法扩展\" title=\"ES6的内置语法扩展\"></a></h1><h2 id=\"array的扩展方法\">Array的扩展方法<a href=\"#array的扩展方法\" title=\"Array的扩展方法\"></a></h2><h3 id=\"扩展运算符（展开语法）\">扩展运算符（展开语法）<a href=\"#扩展运算符（展开语法）\" title=\"扩展运算符（展开语法）\"></a></h3><pre><code>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ary &#x3D; [1, 2, 3];</span><br><span class=\"line\">...ary  &#x2F;&#x2F; 1, 2, 3</span><br><span class=\"line\">console.log(...ary);    &#x2F;&#x2F; 1 2 3</span><br><span class=\"line\">console.log(1, 2, 3)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"扩展运算符的应用\">扩展运算符的应用<a href=\"#扩展运算符的应用\" title=\"扩展运算符的应用\"></a></h4><pre><code>1. 扩展运算符可以应用于合并数组</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 方法一 </span><br><span class=\"line\">let ary1 &#x3D; [1, 2, 3]; </span><br><span class=\"line\">let ary2 &#x3D; [3, 4, 5];</span><br><span class=\"line\">let ary3 &#x3D; [...ary1, ...ary2];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 方法二 </span><br><span class=\"line\">let ary1 &#x3D; [1, 2, 3];</span><br><span class=\"line\">let ary2 &#x3D; [4, 5, 6];</span><br><span class=\"line\">ary1.push(...ary2);</span><br><span class=\"line\">console.log(ary1)</span><br></pre></td></tr></table></figure>\n<pre><code>2.  利用扩展运算符将伪数组或者可遍历对象转换为真正的数组</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var oDivs &#x3D; document.getElementsByTagName(&#39;div&#39;);</span><br><span class=\"line\">console.log(oDivs)</span><br><span class=\"line\">var ary &#x3D; [...oDivs];</span><br><span class=\"line\">ary.push(&#39;a&#39;);</span><br><span class=\"line\">console.log(ary);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造函数方法：arrayfrom\">构造函数方法：Array.from()<a href=\"#构造函数方法：arrayfrom\" title=\"构造函数方法：Array.from()\"></a></h3><pre><code>1. 将类数组或可遍历对象转换为真正的数组\n2. 该方法还可以接受第二个参数，作用类似于数组的map方\n   法，用来对每个元素进行处理，将处理后的值放入返回的\n   数组。</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arrayLike &#x3D; &#123;</span><br><span class=\"line\"> \t&quot;0&quot;: &quot;张三&quot;,</span><br><span class=\"line\">\t&quot;1&quot;: &quot;李四&quot;,</span><br><span class=\"line\">\t&quot;2&quot;: &quot;王五&quot;,</span><br><span class=\"line\">\t&quot;length&quot;: 3</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var ary &#x3D; Array.from(arrayLike);</span><br><span class=\"line\">console.log(ary)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arrayLike &#x3D; &#123;</span><br><span class=\"line\">\t&quot;0&quot;: &quot;1&quot;,</span><br><span class=\"line\">\t&quot;1&quot;: &quot;2&quot;,</span><br><span class=\"line\">\t&quot;length&quot;: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var ary &#x3D; Array.from(arrayLike, item &#x3D;&gt; item * 2)</span><br><span class=\"line\">console.log(ary)&#x2F;&#x2F;输出处理后的结果。</span><br></pre></td></tr></table></figure>\n<h3 id=\"实例方法\">实例方法<a href=\"#实例方法\" title=\"实例方法\"></a></h3><h4 id=\"find\">find()<a href=\"#find\" title=\"find()\"></a></h4><pre><code>用于找出第一个符合条件的数组成员，它的参数是一个回调\n函数，所有数组成员依次执行该回调函数，直到找出第一个\n返回值为true的成员，然后返回该成员。如果没有找到返回\nundefined</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ary &#x3D; [&#123;</span><br><span class=\"line\">    id: 1,</span><br><span class=\"line\">    name: &#39;张三&#39;</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">    id: 2,</span><br><span class=\"line\">    name: &#39;李四&#39;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">let target &#x3D; ary.find(item &#x3D;&gt; item.id &#x3D;&#x3D; 3);</span><br><span class=\"line\">console.log(target)&#x2F;&#x2F;返回undefined</span><br></pre></td></tr></table></figure>\n<h4 id=\"findindex\">findIndex()<a href=\"#findindex\" title=\"findIndex()\"></a></h4><pre><code>返回第一个符合条件的数组成员的位置，如果所有成员都不\n符合条件，则返回-1。</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ary &#x3D; [1, 5, 10, 15];</span><br><span class=\"line\">let index &#x3D; ary.findIndex((value, index) &#x3D;&gt; value &gt; 9); </span><br><span class=\"line\">console.log(index); &#x2F;&#x2F; 2(第一个符合条件的索引，即10的索引是2)</span><br></pre></td></tr></table></figure>\n<h4 id=\"includes\">includes()<a href=\"#includes\" title=\"includes()\"></a></h4><pre><code>判断某个数组是否包含给定的值，返回布尔值</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].includes(2) &#x2F;&#x2F; true </span><br><span class=\"line\">[1, 2, 3].includes(4) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>\n<pre><code>该方法的第二个参数表示搜索的起始位置，默认为0。如果第\n二个参数为负数，则表示倒数（shu）的位置，如果这时它大于数组\n长度（比如第二个参数为-4，但数组长度为3），则会重置为\n从0开始。</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].includes(3, 3);  &#x2F;&#x2F; false</span><br><span class=\"line\">[1, 2, 3].includes(3, -1); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"string-的扩展方法\">String 的扩展方法<a href=\"#string-的扩展方法\" title=\"String 的扩展方法\"></a></h3><h4 id=\"模板字符串\">模板字符串<a href=\"#模板字符串\" title=\"模板字符串\"></a></h4><pre><code>ES6新增的创建字符串的方式，使用反引号定义。\n1. 模板字符串中可以解析变量;\n2. 模板字符串中可以换行;\n3. 在模板字符串中可以调用函数。</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; &#96;张三&#96;;</span><br><span class=\"line\">console.log(name)</span><br><span class=\"line\">&lt;!--模板字符串中可以解析变量--&gt;</span><br><span class=\"line\">let sayHello &#x3D; &#96;Hello, 我的名字叫$&#123;name&#125;&#96;;</span><br><span class=\"line\">console.log(sayHello);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--模板字符串中可以换行--&gt;</span><br><span class=\"line\">&#x2F;&#x2F; let html &#x3D; &#96;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">        &lt;span&gt;$&#123;result.name&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">        &lt;span&gt;$&#123;result.age&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">        &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &#96;;</span><br><span class=\"line\">console.log(html);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tconst fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">\t\t\treturn &#39;我是fn函数&#39;</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--在模板字符串中可以调用函数--&gt;</span><br><span class=\"line\">const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class=\"line\">    return &#39;我是fn函数&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let html &#x3D; &#96;我是模板字符串 $&#123;fn()&#125;&#96;;</span><br><span class=\"line\">console.log(html)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"startswith-和-endswith\">startsWith() 和 endsWith()<a href=\"#startswith-和-endswith\" title=\"startsWith() 和 endsWith()\"></a></h4><ul><li>includes()：返回布尔值，表示是否找到了参数字符串；</li>\n<li>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值；</li>\n<li>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值。</li>\n</ul><pre><code>这三个方法都支持第二个参数，表示开始搜索的位置。</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str &#x3D; &#39;Hello ECMAScript 2015&#39;;</span><br><span class=\"line\">let r1 &#x3D; str.startsWith(&#39;Hello&#39;);</span><br><span class=\"line\">console.log(r1);&#x2F;&#x2F; true</span><br><span class=\"line\"></span><br><span class=\"line\">let r2 &#x3D; str.endsWith(&#39;2015&#39;);</span><br><span class=\"line\">console.log(r2);&#x2F;&#x2F; true</span><br><span class=\"line\"></span><br><span class=\"line\">let r2 &#x3D; str.endsWith(&#39;2016&#39;);</span><br><span class=\"line\">console.log(r2) &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n<h4 id=\"repeat\">repeat()<a href=\"#repeat\" title=\"repeat()\"></a></h4><pre><code>repeat方法表示将原字符串重复n次，返回一个新字符串。</code></pre><h2 id=\"set-数据结构\">Set 数据结构<a href=\"#set-数据结构\" title=\"Set 数据结构\"></a></h2><pre><code>ES6 提供了新的数据结构——Set。\n1. 它类似于数组，但是成员的值都是唯一的，没有重复的值。\n2. Set本身是一个构造函数，用来生成 Set 数据结构。\n3. Set函数可以接受一个数组作为参数，用来初始化。\n4. Set可以去除数组重复元素。</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const s1 &#x3D; new Set();</span><br><span class=\"line\">console.log(s1.size)&#x2F;&#x2F;返回0</span><br><span class=\"line\"></span><br><span class=\"line\">const s2 &#x3D; new Set([&quot;a&quot;, &quot;b&quot;]);</span><br><span class=\"line\">console.log(s2.size)&#x2F;&#x2F;返回2</span><br><span class=\"line\"></span><br><span class=\"line\">const s3 &#x3D; new Set([&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;]);</span><br><span class=\"line\">console.log(s3.size)&#x2F;&#x2F;返回2</span><br><span class=\"line\"></span><br><span class=\"line\">const ary &#x3D; [...s3];</span><br><span class=\"line\">console.log(ary)&#x2F;&#x2F;数组中存储了[&quot;a&quot;,&quot;b&quot;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实例方法-1\">实例方法<a href=\"#实例方法-1\" title=\"实例方法\"></a></h3><ul><li>add(value)：添加某个值，返回 Set 结构本身；</li>\n<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功；</li>\n<li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员；</li>\n<li>clear()：清除所有成员，没有返回值。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const s4 &#x3D; new Set();</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--向set结构中添加值 使用add方法--&gt;</span><br><span class=\"line\">s4.add(&#39;a&#39;).add(&#39;b&#39;);&#x2F;&#x2F;链式调用</span><br><span class=\"line\">console.log(s4.size)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--从set结构中删除值 用到的方法是delete--&gt;</span><br><span class=\"line\">const r1 &#x3D; s4.delete(&#39;c&#39;);</span><br><span class=\"line\">console.log(s4.size)</span><br><span class=\"line\">console.log(r1);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--判断某一个值是否是set数据结构中的成员 使用has--&gt;</span><br><span class=\"line\">const r2 &#x3D; s4.has(&#39;d&#39;);</span><br><span class=\"line\">console.log(r2)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--清空set数据结构中的值 使用clear方法--&gt;</span><br><span class=\"line\">s4.clear();</span><br><span class=\"line\">console.log(s4.size);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul><h3 id=\"遍历\">遍历<a href=\"#遍历\" title=\"遍历\"></a></h3><pre><code>Set 结构的实例与数组一样，也拥有forEach方法，用于对每\n个成员执行某种操作，没有返回值。</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 遍历set数据结构 从中取值</span><br><span class=\"line\">const s5 &#x3D; new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);</span><br><span class=\"line\">    s5.forEach(value &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","prev":{"title":"ES6 bilibili（92集之前）","link":"2019/10/18/note/ES6 bilibili（92集之前）"},"plink":"https://www.hansomezao.com/2019/10/13/note/ES6 bilibili（92集之后）/","toc":[{"id":"es6的新增语法","title":"ES6的新增语法","index":"1","children":[{"id":"let关键字","title":"let关键字","index":"1.1","children":[{"id":"经典面试题","title":"经典面试题","index":"1.1.1"}]},{"id":"const关键字","title":"const关键字","index":"1.2"},{"id":"let-const-var的区别","title":"let const var的区别","index":"1.3"},{"id":"解构赋值","title":"解构赋值","index":"1.4","children":[{"id":"数组解构","title":"数组解构","index":"1.4.1"},{"id":"对象解构","title":"对象解构","index":"1.4.2"}]},{"id":"箭头函数","title":"箭头函数","index":"1.5","children":[{"id":"箭头函数面试题","title":"箭头函数面试题","index":"1.5.1"}]},{"id":"剩余参数","title":"剩余参数","index":"1.6","children":[{"id":"剩余参数和解构配合使用","title":"剩余参数和解构配合使用","index":"1.6.1"}]}]},{"id":"es6的内置语法扩展","title":"ES6的内置语法扩展","index":"2","children":[{"id":"array的扩展方法","title":"Array的扩展方法","index":"2.1","children":[{"id":"扩展运算符（展开语法）","title":"扩展运算符（展开语法）","index":"2.1.1"},{"id":"构造函数方法：arrayfrom","title":"构造函数方法：Array.from()","index":"2.1.2"},{"id":"实例方法","title":"实例方法","index":"2.1.3"},{"id":"string-的扩展方法","title":"String 的扩展方法","index":"2.1.4"}]},{"id":"set-数据结构","title":"Set 数据结构","index":"2.2","children":[{"id":"实例方法-1","title":"实例方法","index":"2.2.1"},{"id":"遍历","title":"遍历","index":"2.2.2"}]}]}]}